<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>LIYI</title>
        <link>https://yishulun.com/</link>
        <description>LIYI' Blog</description>
        <lastBuildDate>Sun, 24 Sep 2023 00:41:06 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <image>
            <title>LIYI</title>
            <url>https://yishulun.com/logo.svg</url>
            <link>https://yishulun.com/</link>
        </image>
        <copyright>MIT License</copyright>
        <atom:link href="https://yishulun.com/feed.xml" rel="self" type="application/rss+xml"/>
        <item>
            <title><![CDATA[Bun 介绍：bun 到底会吃掉多少内存？为何一个不大的博客程序就能吃掉700+MB内存?（二）]]></title>
            <link>https://yishulun.com/./src/posts/2023/06.html</link>
            <guid>https://yishulun.com/./src/posts/2023/06.html</guid>
            <pubDate>Sun, 24 Sep 2023 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>Bun 介绍：bun 到底会吃掉多少内存？为何一个不大的博客程序就能吃掉700+MB内存?（二）</h1>
<p>接着<a href="https://yishulun.com/posts/2023/05.html">上一篇</a>关于包管理工具演进的介绍，下面开始介绍 Bun 相比于传统技术栈框架及工具，具体有哪些优势。</p>
<h2>初始化</h2>
<p>bun 的初始化简单直接，使用下列指令会直接将当前目录初始化为一个 bun 项目工程：</p>
<pre><code class="language-bash">bun init -y
</code></pre>
<p>参数-y 代表静默，不需要提问，所有初始化产生的副任用产品都在当前目录下，所有配置在完成后都可以在文件中修改。init 指令会产生 lock 文件、package.json 文件、tsconfig.json 配置文件等。bun 默认使用 TS 作为开发语言。</p>
<p><img src="./assets/image-20230923200916559.png" alt="image-20230923200916559"></p>
<h2>运行指令，空间换时间</h2>
<p>目录初始化以后会产生一个 index.ts 文件，内容极其简单：</p>
<pre><code class="language-ts">console.log(&quot;Hello via Bun!&quot;);
</code></pre>
<p>以监听方式运行它：</p>
<pre><code class="language-bash">bun --watch run index.ts
</code></pre>
<p>监听方式大家都懂，当我们修改源码后，bun 会监测到文件的改动并自动运行代码。这是运行单个文件，也可以在 package.json 中添加小脚本：</p>
<pre><code class="language-bash">&quot;scripts&quot;: {
   &quot;dev&quot;: &quot;bun --watch run index.ts&quot;
 },
</code></pre>
<p>添加后，通过 bun dev 运行，运行指令的效果是等同的。</p>
<p>bun 有一个参数--smol，官方文档说如果加上这个参数，可以少占用内存。这让我怀疑 bun 在各方面之所以速度表现优秀，在于它大量采用了“空间换时间”的优化策略，它在运行之后，内存占用必定很多。</p>
<p>于是，我通过活动监测器查看 bun 的内存占用：</p>
<p><img src="./assets/image-20230923192404581.png" alt="image-20230923192404581"></p>
<p>注意，这里有两个 bun，这是使用 watch 启动的特征，一个是守护进程，一个是真正的应用进程。上面那个 PID 为 98344 的应该是守护进程，而下面那个 PID 为 98345 的进程应该是应用进程。</p>
<p>我分别添加--smol 参数与不添加参数，做两次测试，发现内存变化寥寥无几。看来使用 smol 参数与否，并没有明显影响内存占用啊。</p>
<p>也可能是当前这个只打印一行“hello world”的程序太简单了，下面我换一个稍微复杂的博客程序进行测试，首次是一般模式：</p>
<p><img src="./assets/image-20230923193325205.png" alt="image-20230923193325205"></p>
<p>占用了约 730MB 内存了，好家伙，快到一个 G 的内存了。</p>
<p>然后看启用了 smol 模式的内存占用：</p>
<p><img src="./assets/image-20230923193548972.png" alt="image-20230923193548972"></p>
<p>占用了约 722MB 内存！我不能说 smol 这个参数没有作用，毕竟同样的项目是少了几 MB 的。但减少的实在太少了。</p>
<p>注意，在测试的时候，前后两次使用的指令是这样的：</p>
<pre><code class="language-bash">bun run --watch --bun vitepress dev src
bun run --smol --watch --bun vitepress dev src
</code></pre>
<p>两次的指令都加上了--bun 参数，这个参数代表使用 bun 作为 JS 语言的运行时，而非环境中默认的 Node.js。</p>
<p>下面，我们回到 vitepress 的普通运行模式，不再使用 bun 这个运行时，使用 Node.js，指令是这样的：</p>
<pre><code class="language-bash">bun run --watch vitepress dev src
</code></pre>
<p>或者直接使用旧脚本：</p>
<pre><code class="language-bash">vitepress dev src
</code></pre>
<p>这是在使用 Node.js 作为 JS 的运行时，它的内存占用一下就降下来了：</p>
<p><img src="./assets/image-20230923194108099.png" alt="image-20230923194108099"></p>
<p>只有 182MB！</p>
<p>从 730MB 降到了 182MB，<strong>说明 bun 为了提高运行效率，确实很有可能狠狠地采用了“空间换时间”的策略</strong>。这个世界能量是守恒的，在一个地方占优了，必然在另一个地方会有所损耗，这是肯定的。为什么别的运行时都没有 smol 参数，bun 为什么专门搞一个 smol 参数？它大概也预感到了它需要这个东西。</p>
<h2>使用 JSX 语法</h2>
<p>下面试用 jsx 功能，首先安装类库：</p>
<pre><code class="language-bash">bun install react react-dom
</code></pre>
<p>然后分别创建两个文件：</p>
<pre><code class="language-jsx">// message.tsx
export default function Message(props: {text: string}) {
  return (
    &lt;body&gt;
      &lt;h1 style={{color: 'red'}}&gt;{props.text}&lt;/h1&gt;
    &lt;/body&gt;
  );
}
// index.tsx
import Message from &quot;./message&quot;;
console.log(&lt;Message text=&quot;Hello world!&quot; /&gt;);
</code></pre>
<p>接着运行测试指令：</p>
<pre><code class="language-bash">bun run index.tsx
</code></pre>
<p>返回：</p>
<blockquote>
<Message text="Hello world!" />
</blockquote>
<p>没有问题。</p>
<p>在同一个项目中，可以写 ts 代码，也可以写 jsx 代码，并且不需要额外的配置。bun 靠文件的后缀名决定要启用什么样的加载器，<strong>当我们在文件内使用 jsx 语法时，文件后缀就必须写成 tsx 或 jsx</strong>。</p>
<p>除此之外，react 与 react-dom 还是要安装的，bun 只是替代了网络基础软件层次的 Node.js，它并没有替代业务软件层次的框架，诸如 Vue、React、Vite 等类库，如果在项目中用到它们了，首先还是需要使用 bun install 指令安装的。</p>
<p>这一篇就说到这里，主要介绍了 bun 在运行时会占用大量内存，以及如何使用 jsx 语法，下一篇继续介绍 bun。</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[Bun 1.0 发布了，以后 Node.js 项目谁还用 Webpack 与 pnpm？！是时候祭出大杀器 Bun了（一）]]></title>
            <link>https://yishulun.com/./src/posts/2023/05.html</link>
            <guid>https://yishulun.com/./src/posts/2023/05.html</guid>
            <pubDate>Sat, 23 Sep 2023 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<p><img src="./assets/23cbde35-b859-41b5-9480-98b88bf40c44.png" alt="img"></p>
<h1>Bun 1.0 发布了，以后 Node.js 项目谁还用 Webpack 与 pnpm？！是时候祭出大杀器 Bun了（一）</h1>
<blockquote>
<p>bun 绝对值得投入时间学习一下，对程序员来说，它像 Vite 一样，可以十倍百倍提升开发体验和开发效率。</p>
</blockquote>
<p>Node.js 在 2009 的发布可谓石破天惊，天才程序员 Ryan Dahl 基于谷歌浏览器的 V8 引擎，一举将 JavaScript 这个客户端语言带到了服务器端的广阔天地。</p>
<p>JavaScrpt 的异步回调机制、简单的语法、超低的门槛、解释执行方便热部署等特征，迅速使其占领了服务器端的业务接口编写领域，这个领域向数据库要数据，向业务底层要执行结果，向浏览器客户端以 RESTFul 接口的形态提供数据，简单、直观，该领域使用 JavaScript 编写再合适不过了。</p>
<p>Node.js 的出现，让 JavaScript 的能力范围从前端一下拓展到了后端，加上后来 2013 年在 Node.js 的启发下发布的桌面开发框架 Electron，又拓展到了桌面端，JS 成为了大前端语言、全栈语言。（一般而言我们说全栈，狭义上指前端、后端、数据库、服务器等，广义上讲还包括 APP、桌面软件开发。在 App 开发上，有比较知名的 React Native、ionic、uniapp 等，在桌面开发领域，选择即 Electron。）</p>
<h2>Node.js 包管理工具的演进</h2>
<p>Node.js 发展起来以后，在它上面产生了一系列的业务开发框架和类库，大多数都是为了提交开发效率和工程协作体验的。下面拣一些常见的内容说一下：</p>
<p>1，例如工程化与打包框架 webpack，及随着 webpack 一起诞生的是大名鼎鼎的工程文件 package.json。</p>
<p>2，为了解决 JS 的弱类型问题，发明了 TypeScript，并由此诞生了.ts 文件及编译 ts 文件的 tsc、babel 编译器。</p>
<p>3，为了倒转控制，大牛程序员发明了响应式框架 React 与 Vue。以前在 jQuery 开发时代，程序员需要主动找到页面上的 HTML 节点，然后更新节点的值；响应式框架不是，程序员只需要指定节点绑定的数据，在改变数据后，框架负责将更改后的数据同步到节点上。响应式框架相当于是在页面中运行的一个小的 JS 运行时，时刻帮助程序员监视着页面上的每一个变化。</p>
<p>4，为了在工程化的 Node.js 项目中方便加载字体、图片、css、svg 等内容，大牛程序员们又编写了各种加载器，例如 file-loader、css-loader、sass-loader、less-loader、style-loader、url-loader、font-loader、svg-loader 等，不要纠结它们的名字，只需要知道这些加载器都是针对某一个文件类型的预处理程序就可以了。为什么要编写它们？因为工程化的 Node.js 项目要进行编译和捆绑，在此之前，需要掌控项目中的一切资源。这些加载器在配置文件中都有特定配置格式，要正解编写它们，基本每次都需要查文档或谷歌。</p>
<p>5，与 Node.js 同时发布的，还有一个 CommonJS 模块化规范。模块化让类库的独立导出和复用变成了可能，一个个类库像一个独立的有特定功能的积木一样，开发者可以自由地在自己的项目引入和使用。为了方便管理这些类库，大牛程序员们又编写了 npm 这样的包管理工具，关于包的下载、安装、更新、移除等操作，使用指令就可以了。这些包作为依赖项在工程文件 package.json 中还被记录了下来，使用 npm i 还可以一键安装，这个时期的程序员太幸福了。</p>
<p>6，幸福的好景不长，由于包管理的自动化，很快一个 Node.js 项目的依赖项就失去了控制。当我们安装一个包时，不只是会安装它本身，它依赖的包也会自动安装，所以项目的 node_modules 目录（包的本地安装目录）经常有很多子目录，一个 Node.js 项目的总体积达到几百甚至上千 MB 都成为常态。依赖项很多，体积变大，不仅下载、安装速度很慢，有时候还可能发生依赖冲突。我们举个例子，我们的项目依赖了 A 和 B 两个包，这两个包又依赖了 C，但却是 C 的不同版本，且 C 的这两个版本还不同，甚至有冲突，这就带来了隐藏的工程化灾难。JS 本身是在页面上的单线程环境中运行中，各个包使用的内存空间是同一个空间，相互之间没有隔离，发生奇奇怪怪的依赖项异常一点也不稀奇。如果你没有遇到过，只能说你还没有走到工程化的前沿，在边缘地带什么地雷都可能踩到。</p>
<p>7，为了解决包冲突的问题，大牛程序员发明了 yarn。一般情况下，团队规范能被允许使用 yarn，就不会使用 npm。有人可能会问，既然 yarn 在包管理策略上优于 npm，为什么团队规范会禁止使用？可能因为领导的脑子有坑，制定了某条僵硬的教条，他自己都不明白为什么，这样的人在专制的体制下并不鲜见。yarn 并不是没有缺点，从上面的对比截图也可以看出来，它的下载速度变慢了。</p>
<p>8，下载、安装速度慢，是 Node.js 项目长期以来，自诞生以后，一直存在，一直被开发者诟病的缺点。为了解决这个问题，大牛程序员回归初心，开发了 pnpm，在 npm 前面加了一个 p，使用并发的方式下载类库并直接在终端里给出实时的数字反馈。这个改进让开发者的下载体验感觉舒服多了。于是，在团队规范允许的情况下，能使用 pnpm，就不使用 yarn 和 npm。</p>
<p><img src="./assets/image-20230923115301691.png" alt="image-20230923115301691"></p>
<p>9，但是，pnpm 的下载速度还是慢，它只是在一定程度上改善了原本就很慢的下载速度，这一点从上面的下载速度对比上可以看出来。bun 在 npm、yarn、pnpm 成功经验的基础之上，总结前人智慧，采用全局缓存+并发下载的策略，一举将下载速度提升了一个数量级。</p>
<h2>主流包管理工具下载比拼</h2>
<p>为了验证官方的说辞，我准备亲自试用一下。我选了我的博客项目，使用下面的指令依次清扫上次安装留下的痕迹：</p>
<pre><code class="language-bash">rm -rf node_modules pnpm-lock.yaml
rm -rf node_modules yarn.lock
rm -rf node_modules package-lock.json
rm -rf node_modules bun.lockb（这一步其实不需要）
</code></pre>
<p>每个包管理工具的lock文件都不一样，这也是为了不冲突。依次执行下列指令，使用三个包管理工具分别进行下载安装：</p>
<pre><code class="language-bash">echo `date` &amp;&amp; pnpm i &amp;&amp; echo `date`
echo `date` &amp;&amp; yarn &amp;&amp; echo `date`
echo `date` &amp;&amp; npm i &amp;&amp; echo `date`
echo `date` &amp;&amp; bun i &amp;&amp; echo `date`
</code></pre>
<p>为了测试公平起见，我事先关掉了梯子（但保留使用了国内仓库源）。echo 指令是为了查看执行安装指令前后的时间点，其实没有这两个 echo 指令也可以，因为无论是哪个安装工具，在安装完成后都会主动向我们报告耗时时间。</p>
<p>结果发现：</p>
<p>1，pnpm 耗时 8.5s</p>
<p>pnpm 的下载体验基本还是令人满意的。</p>
<p>2，yarn 耗时 27.92s</p>
<p>在这一步时，在关掉梯子的情况下，出现了“info There appears to be trouble with your network connection. Retrying...”异常，这可能是由于网络不通引起的。打开梯子，再次执行 yarn 会快很多，也可以顺利完成安装指令。</p>
<p>3，npm 耗时 ∞</p>
<p>在执行这一步时，在关掉梯子的情况下，一直卡在某个节点；在打开梯子以后，仍然卡在了某个地点，无法继续了。</p>
<p>4，bun 耗时 518ms</p>
<p>bun 的表现确实一骑绝尘，与官方宣称的比较匹配。</p>
<table>
<thead>
<tr>
<th>包管理工具</th>
<th>耗时</th>
</tr>
</thead>
<tbody>
<tr>
<td>bun</td>
<td>0.518s</td>
</tr>
<tr>
<td>pnpm</td>
<td>8.5s</td>
</tr>
<tr>
<td>yarn</td>
<td>27.92s</td>
</tr>
<tr>
<td>npm</td>
<td>∞</td>
</tr>
</tbody>
</table>
<p>在我的测试中，我只是删除了工程项目下的 node_modules 文件夹及相关的 lock 文件，并没有删除公共的、共享的包管理工具缓存目录。如果严格执行，bun 的表现应该没有这么优秀。500ms 的速度已经比 rm -rf 指令的执行时间还要短，bun 无论是在网络下载还是在文件移动上确实做了足够的优化。</p>
<p>bun 作为一个包管理工具，它的下载速度是让人满意的。但它不仅仅是一个包管理工具，事实上它作为一个网络基础软件，它还替代了 Node.js，它是在网络基础软件这个层次上，集合了众多成功工具的优点并替掉了它们。Vite 是在业务软件开发这个层面集合与替换的，bun 是在服务器网络基础软件这个层次汇总与替换的。（更多的内容下一篇再说。）</p>
<h2>如何安装 bun？</h2>
<p>最后说一下它的安装方法，在 Mac 或 Linux 上直接在终端里执行下列指令：</p>
<pre><code class="language-bash">curl -fsSL https://bun.sh/install | bash
</code></pre>
<p>该指令先将安装器下载到本地，紧跟着进行安装。</p>
<p>如果是 <strong>Windows 系统，目前 bun 仅提供了限于运行时功能的版本</strong>，并且还需要先安装 WSL（一种 Windows 下面的子虚拟机环境）。为什么会这样？因为程序员现在使用 macOS 开发软件是共识，而在服务器端，也极少选择和使用 Windows Server 系统。微软最成功的服务器端操作系统是 Windows 2000，现在它已经被 CentOS、Ubuntu 等 Linux 发行版本替换了。</p>
<p>所以，全栈开发人员，找一个 macOS 笔记本作为开发本，然后开始试用 bun 吧，它将大幅提升你的开发体验和产品运行效率。(下一篇继续介绍它的更多功能，关于内置的热加载、环境变量读取等功能。)</p>
<p>参考</p>
<ul>
<li><a href="https://bun.sh/blog/bun-v1.0">https://bun.sh/blog/bun-v1.0</a></li>
<li><a href="https://bun.sh/docs/installation#macos-and-linux">https://bun.sh/docs/installation#macos-and-linux</a></li>
</ul>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[在手机上向github pages blog 写作]]></title>
            <link>https://yishulun.com/./src/posts/2023/在手机上向github pages blog 写作.html</link>
            <guid>https://yishulun.com/./src/posts/2023/在手机上向github pages blog 写作.html</guid>
            <pubDate>Fri, 11 Aug 2023 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>在手机上向github pages blog 写作</h1>
<p>发现一个可以用手机写作的 App，叫做 GitJournal。</p>
<p>试一下贴图功能吧：</p>
<p><img src="./assets/6c2a10b3c0ed7bd17e0c7bdfba9d9a54.jpg" alt="Image"></p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[Claude 为什么片断式输出？]]></title>
            <link>https://yishulun.com/./src/posts/2023/Claude为什么片断式输出.html</link>
            <guid>https://yishulun.com/./src/posts/2023/Claude为什么片断式输出.html</guid>
            <pubDate>Mon, 10 Jul 2023 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>Claude 为什么片断式输出？</h1>
<p>它一次性可以输出很长的内容，但事实上他每次仅输出一点。为什么会这样？下面是 Claude 自己的回答：</p>
<ol>
<li>逐步输出可以获得您的实时反馈。创作是一个迭代的过程，如果我一次性全部输出，可能会出现较大的偏差或错误。分段输出可以让我及时得到您的指导，对下一段的创作有很好的启发和帮助。</li>
<li>分段输出可以更好地模拟真实创作。现实中的创作也不是一次性完成，往往需要在灵感、梳理和修改之间反复迭代。我逐步输出是为了让过程更贴近真实创作，锻炼我的创作能力。</li>
<li>考虑到交互体验。如果我一次性大量输出，阅读体验可能不太友好。分批输出可以让对话更顺畅、生动。</li>
<li>可以控制输出长度。我会根据您的要求和反馈，控制每次输出的长度，避免一次过多内容带来的阅读压力。</li>
</ol>
<p>由人类主导，由 Claude 辅助的创作过程是一个互动创作的过程。可以阶段性创作结果之后，要求 AI 做一个汇总：</p>
<blockquote>
<p>将前面创作的 6 章内容合在一起发给我，并起一个有吸引力的标题。</p>
</blockquote>
<p>如何使用 Claude 进行创作，这也是一项智力劳动，并不是完全由 AI 代劳、人类什么也不管的事。</p>
<h2>下一步的思考：</h2>
<ul>
<li>一些类似于芥子园画谱的写作套路集是不是有必要？对于一些特定情节、场景的描写提供套路，这些套路 AI 可以用，人类也可以用。</li>
<li>创作更多是——也应该是一项体验，而非一项工作或劳动。从这个角度讲，主动输入一些内容，然后加工再输出，这本身是一个很好的生命体验活动，作者在其中应该享受，而非享受到痛苦。</li>
</ul>
<p>7 月 22 日</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[Claude 各版本之间的差异是什么？]]></title>
            <link>https://yishulun.com/./src/posts/2023/Claude各版本之间的差异是什么.html</link>
            <guid>https://yishulun.com/./src/posts/2023/Claude各版本之间的差异是什么.html</guid>
            <pubDate>Sat, 01 Jul 2023 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>Claude 各版本之间的差异是什么？</h1>
<p>在 Claude 官网上有两个版本：Claude 与 Claude Instant。在 poe 上面有三个版本：Claude-instant、Claude-instant-100k 和 Claude-2-100k，Claude2 自己对这三个版本的差异解答是：</p>
<blockquote>
<p>Claude-instant、Claude-instant-100k 和 Claude-2-100k 都是 Anthropic 公司开发的大型语言模型，主要的区别在于：</p>
<ol>
<li>模型大小不同</li>
</ol>
<ul>
<li>Claude-instant: 4 亿参数</li>
<li>Claude-instant-100k: 10 亿参数</li>
<li>Claude-2-100k: 200 亿参数</li>
</ul>
<ol start="2">
<li>训练数据量不同</li>
</ol>
<ul>
<li>Claude-instant 和 Claude-instant-100k 都是在较小的数据集上训练的。</li>
<li>Claude-2-100k 是在超过 100,000 本书上的大规模数据集上训练的。</li>
</ul>
<ol start="3">
<li>生成能力不同</li>
</ol>
<ul>
<li>参数更多、训练数据更多的模型生成能力更强。</li>
<li>Claude-2-100k 的生成语言更流畅，内容更丰富，能够进行更长时间的对话。</li>
</ul>
<ol start="4">
<li>可用性不同</li>
</ol>
<ul>
<li>Claude-instant 免费开放使用。</li>
<li>Claude-instant-100k 和 Claude-2-100k 需要付费使用。</li>
</ul>
<p>总体来说，Claude 系列的三个模型是同一系列的升级版本，参数、数据集和生成能力逐步提升，但需要付费使用的版本也逐步增加。</p>
</blockquote>
<p>基本上，带 100k 后缀的，可以一次性处理更多数据，这一点与 ChatGPT 类似，GPT4-32 也是相对可以一次处理更多 Token 的模型。而 Claude-instant 是免费的，有 poe 内可以免费使用，一般免费的意味着版本功能更弱更少。</p>
<p>在 Claude 官网上，对非即时、即时版本有这样的解释。即时模型：</p>
<blockquote>
<p>Claude</p>
<p>我们最强大的模型，擅长执行从复杂对话和创意内容生成到详细指导的各种任务。</p>
<p><strong>适合：</strong></p>
<ul>
<li>复杂的推理</li>
<li>创造力</li>
<li>深思熟虑的对话</li>
<li>Coding</li>
<li>详细的内容创建</li>
</ul>
</blockquote>
<p>另一个即时模型：</p>
<blockquote>
<p>Claude-instant</p>
<p>一种更快、更便宜但仍然非常强大的模型，可以处理一系列任务，包括随意对话、文本分析、摘要和文档理解。</p>
<p><strong>适合：</strong></p>
<ul>
<li>低成本性能</li>
<li>减少延迟</li>
<li>轻量级对话</li>
<li>适度</li>
</ul>
</blockquote>
<p>通过官方的解释可以看出来，带有 instant 标识的模型，处理问题更快，这并不是因为它运算能力强大，而是它简单，压根就没有进行强力的运算。</p>
<p>从价格上也可以看出端倪，一般更贵的意味着功能更强，如下所示：</p>
<p>![1689985266063](image/Claude 各版本之间的差异是什么/1689985266063.png)</p>
<p>至此，差异基本已经明白了。在 poe 内，如果你使用的 poe 是免费版本，可以使用受限的 Claude-instant 版本及次数受限的高级版本；如果使用的是付费版本，互动没有限制，特别在进行小说创意工作时，适合使用 Claude-instant-100k，它即强大，又能处理长文本，是真正可以与 GPT4 一较高下的模型。</p>
<p>2023 年 7 月 21 日</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[Github Pages 博客如何绑定根域名？]]></title>
            <link>https://yishulun.com/./src/posts/2023/Github Pages博客如何绑定根域名.html</link>
            <guid>https://yishulun.com/./src/posts/2023/Github Pages博客如何绑定根域名.html</guid>
            <pubDate>Tue, 13 Jun 2023 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>Github Pages 博客如何绑定根域名？</h1>
<p>Godaddy 的域名不需要域名备案，这是它方便的地方，但它不充许在根域名上直接添加 CNAME 记录，换句话说，原来在国内域名商下的域名，转移到 Godaddy 后，在 Github Pages 上绑定的根域名不再有效了。</p>
<p>以我的博客为例说明一下。原来我可以直接将根域名 <a href="http://yishulun.com">yishulun.com</a> 绑定到 <a href="http://rixingyike.github.io">rixingyike.github.io</a>，www 域名通过 CNAME 绑定到根域名，这样无论读者访问根域名还是 www 域名，都可以跳转到根域名。国内早期网站网址的写法一般都会在前面带上 www，其实 www 只是一个子域名，与其它 blog、news 等子域名是等同的，为了照顾国内读者的使用习惯，我将 www 域名跳转到根域名（<a href="http://yishulun.com">yishulun.com</a>）。但是，在我的域名转移到 Godaddy 之后，这一招不好使了，Godaddy 的 DNS 解析不充许将根域名以 CNAME 的方式绑定到另一个二级域名上。</p>
<p>在国外，普遍认为根域名是一个域名的主要域名，www 只是一个从属的子域名。并且在 Godaddy 上，根域名只允许绑定 A 记录，不允许直接绑定 CNAME 记录，据说这是为了 CNAME 记录污染 DNS 缓存，造成在根域名上使用的邮件服务投递错乱。</p>
<p>那么这个问题怎么解决呢？怎么兼容老读者的使用习惯，使他们打开 <a href="http://yishulun.com">yishulun.com</a> 时看到页面不是网页荒漠呢？</p>
<p>有人说，可以在网站根目录下添加。htaccess 文件：</p>
<pre><code class="language-bash">RewriteEngine on
RewriteCond %{http_host}^yishulun.com [NC]
RewriteRule ^(.*)$http://www.yishulun.com/$1 [L,R=301]
</code></pre>
<p>.htaccess 是给 Apache 服务器使用的网站配置文件，如果服务器不是 Apache，这个文件是起不到任何作用的。事实上我的 Github Pages 博客是由 Node.js 驱动的，因此这一招并不好使。</p>
<p>有人说，在页面上使用脚本实现 301 跳转，页面访问不到，JS 脚本怎么可能执行？或者在 Godaddy DCC 配置面板上，添加 Fowarding 记录，我试了这招，等待了一晚上并不好用——因为那个博主说，Godaddy 配置生效时间长，所以等了这么久。</p>
<p>最后说一下我是怎么配置成功的，现在读者无论访问 <a href="http://yishulun.com">yishulun.com</a>，还是访问 <a href="http://www.yishulun.com">www.yishulun.com</a>，最终都会跳转到 <a href="https://yishulun.com">https://yishulun.com</a>。</p>
<p>第一步：在 Godaddy DCC 配置面板上，添加 A 记录分别到 185.199.108.153、185.199.109.153、185.199.110.153 和 185.199.111.153。完成这一步以后，稍后用 dig 指令检查域名配置，看到如下类似结果，说明配置成功了。</p>
<pre><code class="language-bash">$ dig yishulun.com

; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; yishulun.com
;; global options: +cmd
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 37755
;; flags: qr rd ra; QUERY: 1, ANSWER: 4, AUTHORITY: 0, ADDITIONAL: 0

;; QUESTION SECTION:
;yishulun.com.			IN	A

;; ANSWER SECTION:
yishulun.com.		600	IN	A	185.199.109.153
yishulun.com.		600	IN	A	185.199.111.153
yishulun.com.		600	IN	A	185.199.110.153
yishulun.com.		600	IN	A	185.199.108.153
</code></pre>
<p>第二步，添加 CNAME 记录到 <a href="http://rixingyike.github.io">rixingyike.github.io</a>。</p>
<p>第三步，在 Github Pages 配置处，填写 Custom domain 为 <a href="http://yishulun.com">yishulun.com</a>，注意这里是根域名。并选择 Enforce HTTPS 选项。</p>
<p>第四步，在网站根目录下，放置一个 CNAME 文件，内容为 <a href="http://yishulun.com">yishulun.com</a>。如果你使用的静态博客程度也是 vitepress，将这个文件放在。vitepress/public 目录下即可。</p>
<p>完成以上步骤，配置就算完成了。</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[ChatGPT 向 Plus 用户开放了代码解析器（Code interpreter），与其说它是程序员的工具，不如说是为您工作的程序员，真的如此吗？]]></title>
            <link>https://yishulun.com/./src/posts/2023/ChatGPT向Plus用户开放代码解析器功能.html</link>
            <guid>https://yishulun.com/./src/posts/2023/ChatGPT向Plus用户开放代码解析器功能.html</guid>
            <pubDate>Sun, 11 Jun 2023 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>ChatGPT 向 Plus 用户开放了代码解析器（Code interpreter），与其说它是程序员的工具，不如说是为您工作的程序员，真的如此吗？</h1>
<blockquote>
<p>有人说 ChatGPT 的名字也很糟糕，与其说它是程序员的工具，不如说是为您工作的程序员。体验之后你会发现，只有你想不到，没有它干不了。但真的是这样吗？它没有缺点吗？</p>
</blockquote>
<p>7 号 OpenAI 在官方推特上宣布，将向付费的 ChatGPT Plus 用户开放一个代码解析器功能。</p>
<p>它允许 ChatGPT 运行代码，并且可以选择访问您上传的文件。您可以要求 ChatGPT 分析数据、创建图表、编辑文件、执行数学运算等。</p>
<p>轻描淡写的，这段话在向我们透露什么信息：</p>
<ul>
<li>它能运行代码</li>
<li>它可以上传文件</li>
<li>它可以分析文件中的数据、编辑文件、执行数学运算、创建图表，然后输出。</li>
</ul>
<p>不是在开启 Plugin 的地方，那是给第三方使用的地方，这个是官方可能。打开官网，在 Settings 设置处，看到了一个新配置：</p>
<p><img src="https://cdn.jsdelivr.net/gh/rixingyike/images@master/2023ChatGPT%E5%90%91Plus%E7%94%A8%E6%88%B7%E5%BC%80%E6%94%BE%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90%E5%99%A8%E5%8A%9F%E8%83%BD-2023-07-08-18-07-45.png" alt="ChatGPT 向 Plus 用户开放代码解析器功能-2023-07-08-18-07-45"></p>
<p>将 Code interpreter 的绿色小开关推开。</p>
<p>开启以后，回到主操作界面，模式选项处就多了一个新选项：</p>
<p><img src="https://cdn.jsdelivr.net/gh/rixingyike/images@master/2023ChatGPT%E5%90%91Plus%E7%94%A8%E6%88%B7%E5%BC%80%E6%94%BE%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90%E5%99%A8%E5%8A%9F%E8%83%BD-2023-07-08-18-23-33.png" alt="ChatGPT向Plus用户开放代码解析器功能-2023-07-08-18-23-33"></p>
<p>据说，ChatGPT Plus 的代码解析器功能非常强大，几乎日常工作的文件、数据集、代码都能解析。接下来开始试用它有哪些强大的功能。听说一旦我选择了插件，我就可以像往常一样与 ChatGPT 交谈。然后，它会将我的问题转化为数据，并为我提供明确的答案。</p>
<h2>1，文件格式转化（使用 Py 代码）</h2>
<p>宝玉将一个PDF上传，然后告诉ChatGPT：“请将这个PDF文件保存成2行2列的图片，每4页一张图片。”</p>
<p>然而它就真的按要求做到了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/rixingyike/images@master/202320230708195241-2023-07-08-19-52-42.png" alt="20230708195241-2023-07-08-19-52-42"></p>
<p>至于怎么上传PDF，在输入框旁边有一个加号，单击就可以上传：</p>
<p><img src="https://cdn.jsdelivr.net/gh/rixingyike/images@master/202320230708195526-2023-07-08-19-55-26.png" alt="20230708195526-2023-07-08-19-55-26"></p>
<p>更为重要的是，ChatGPT 完成这一步的文件格式转换，是通过 Python 代码完成。且它所使用的 Py 代码，还可以点开查看，并下载使用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/rixingyike/images@master/202320230708195850-2023-07-08-19-58-51.png" alt="20230708195850-2023-07-08-19-58-51"></p>
<p>有兴趣可以跳转过去看宝玉的推特：<br>
<a href="https://twitter.com/dotey/status/1677426953207382018">https://twitter.com/dotey/status/1677426953207382018</a></p>
<h2>2，与人类互动，请示</h2>
<p>更有意思的是来自另一位 ChatGPT 用户的实践，他在与 AI 互动的过程中，要求 AI 将一个 Epub 电子书转为 txt 格式。AI 在尝试转化的过程中失败了，问题在于，它失败以后，还还会向人请示：</p>
<p>您觉得有什么改进的建议吗？</p>
<p><img src="https://cdn.jsdelivr.net/gh/rixingyike/images@master/202320230708201216-2023-07-08-20-12-17.png" alt="20230708201216-2023-07-08-20-12-17"></p>
<p>这太让人震撼了！我不知道你意识到了什么。</p>
<p>以往人们批评 ChatGPT 总是强答造谣、虚幻主义，现在好了，它用实际可以运行的代码回答人类提出的具体问题，并且当在实践中遇到问题时，还会征求人类的建议，向人类寻求下一步的指示。</p>
<p>这不像一个员工在遇到问题时，向他的上级反映问题吗？</p>
<p>这就是一个真正的智能助理干的事情啊！并且是一个上知天文、下知地理，通晓各种编程语言的智能助理，而且还不睡觉，可以 24 小时干活。</p>
<p>对向阳乔木这个实验感兴趣，可以访问：<br>
<a href="https://chat.openai.com/share/b1659250-a557-4ae1-b275-0a0ed3636910">https://chat.openai.com/share/b1659250-a557-4ae1-b275-0a0ed3636910</a></p>
<p>（这个链接是从 ChatGPT 上分享的，这种分享链接非常好，既可以保存有效的 Prompt 实践，又方便分享给他人查看。）</p>
<h2>3，归纳、分析与总结</h2>
<p>又有人给它上传了一个 prompts.csv 数据文件，指令要求：</p>
<p>“请你对 prompts.csv 文件进行分析总结，选择一些最佳图表用来展示分析结果，并给出一份编写 prompt 最佳指南。”</p>
<p>于量，它画出了简洁的图表：</p>
<p><img src="https://cdn.jsdelivr.net/gh/rixingyike/images@master/202320230708203919-2023-07-08-20-39-20.png" alt="20230708203919-2023-07-08-20-39-20"></p>
<p>下面这是它绘制的词云统计效果图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/rixingyike/images@master/202320230708204510-2023-07-08-20-45-10.png" alt="20230708204510-2023-07-08-20-45-10"></p>
<p>是不是感觉效果还不错。</p>
<p>最后它还给出了分析结果。下面这是一份来自 ChatGPT 自己回答的，关于如何撰写最佳提示的最佳实践：</p>
<ul>
<li>1，明确指出你需要什么：使用词汇如&quot;want &quot;need&quot;,&quot;help&quot;&quot;tell&quot;来明确地指出你需要 ChatGPT 做什么。</li>
<li>2，指定角色；像&quot;actasa...&quot;这样的语句可以帮助 ChatGPT 理解你希望它扮演的角色。</li>
<li>3，简洁清晰：尽量让你的提示简短而清晰，大部分的提示长度在 200 个字符以下。特定的行动：如果可能，使用具体的动词，如&quot;use&quot;&quot;create&quot;&quot;design&quot;&quot;play&quot;等，来明确你希望 ChatGPT 执行的具体动作。</li>
</ul>
<p>显然，它有归纳、分析与总结的能力。这些能力作为智能助理能力模型中的一部分，是很重要且很受市场欢迎的能力。</p>
<p>除了情感陪伴，它没有，不知道它还不会什么。哦，对了，它不会做饭，它只能给出菜谱，但并不能把食材变成佳肴。</p>
<p>最后补充一点关于从视频中提取音频，将转化为文本，再结合关键画面制作 PPT 的问题，它会给出分步的代码，但在第二步时，因为音频转文本是一项在线服务，需要调用谷歌或其它第三方的接口服务，所以它不能直接运行。</p>
<p>此外，有人说，它既然可以连网（意思指连接上了 Bing，是 Beta 功能之一），那么能不能让它直接编写攻击服务器的代码？</p>
<p>这是不行的。首先，这不符合它的规则；其次，它的 Py 代码运行在沙箱之中，就像浏览器中的 JS 代码一样，有诸多限制，并不是可以为所欲为的。</p>
<h2>总结</h2>
<p>最后总结一下：</p>
<ul>
<li>1，代码解释器是一个很强大的功能，它就像人类的一个会编程的智能助理，它可比低代码强太多了，你只需要学会与它打交道的特定指令，就可以让它为你干活了；</li>
<li>2，它的名称叫“代码解释器”，但其实这是一个很糟糕的名字。你也不要看它具体有什么能力，譬如分析数据、创建图表、编辑文件、执行数学运算等，这些都是它的能力，但远远不止这些能力啊，因为它的能力就是 Python 的能力，Python 无所不为，你说它的能力是什么？只有你想不到，没有它干不了。</li>
<li>3，也不要过于迷信它，它编写的代码运行在沙箱中，它在查询信息时可以联网（查询 Bing），但它不能直接调用谷歌的在线服务，更加不能满足你的私欲，替你攻击隔壁老王的服务器。</li>
</ul>
<p>它是一个越来越强大的工具，官方的代码解释器出来后，Github 的 Copilot 效用就降低了——但也不一定，因为与 VSCode 结合起来的 Copilot 据说更方便。但对于插件开发者来说，可以据此实现的功能也更多了。</p>
<p>比如，让用户上传文件，然后分析文件，然后给出分析结果。用户不会直接使用 ChatGPT，但是作为插件开发者的你会啊，你完全可以开发这样的应用不是吗？</p>
<p>​智能时代已经到来！以前我们讲数字化，讲了许多年，许多企业在许多城市推进了许多年，勉勉强强不少中小企业开始数字化了。现在不一样了，智能时代来了，原来是数字化，现在是智能数字化，许多中小企业老板在自己的圈子里就相互推荐了。</p>
<p>“唉，你用了没有？”</p>
<p>“还没有。”</p>
<p>“怎么还不用？赶紧让员工用起来！”<br>
老板们自己都​卷了起来。现在是程序员不用、设计师不用、产品经理不用，为什么不用？因为隐隐约约感觉这好像是一个砸他们​饭碗的东西。原来新软件新工具都是由员工提出来，向老板申请资金购买，现在是老板主动要求员工​购买与使用。</p>
<p>关于我们如何面对 AI，还是那句话：​你不能驾驭它，那么未来你将被能驾驭的人淘汰。</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[创作小说的相关提示语]]></title>
            <link>https://yishulun.com/./src/posts/2023/创作小说的相关提示语.html</link>
            <guid>https://yishulun.com/./src/posts/2023/创作小说的相关提示语.html</guid>
            <pubDate>Tue, 11 Apr 2023 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>创作小说的相关提示语</h1>
<p>以下内容是由<a href="https://www.aimind.so/prompt-generator%E7%94%9F%E6%88%90%E7%9A%84%EF%BC%8C%E6%9F%A5%E8%AF%A2%E5%85%B3%E9%94%AE%E5%AD%97%E6%98%AF%E2%80%9Cwrite">https://www.aimind.so/prompt-generator生成的，查询关键字是“write</a> a fiction story”。该网站是一个Prompt生成器，可以围绕用户脑海中一个简单的想法，输出一系列相关的提示语。</p>
<h3>改进的提示</h3>
<p>作为一名小说写作专家，我希望您充当一位友好的写作导师，为小说故事的写作提供指导。请保持语言简单且不含行话，以迎合初学者。您的回复应采用段落和项目符号格式，长度适中。以下是您的回复中应包含的一些主题：</p>
<ul>
<li>小说写作简介：解释什么是小说写作及其目的。</li>
<li>优秀小说故事的要素：讨论情节、人物、背景和冲突等关键组成部分。</li>
<li>培养引人入胜的角色：提供有关创建相关且全面的角色的技巧。</li>
<li>打造有趣的情节：分享构建具有清晰开头、中间部分和结尾的引人入胜的故事情节的技巧。</li>
<li>设置场景：解释为故事创建生动且身临其境的场景的重要性。</li>
<li>营造冲突和紧张气氛：讨论在整个叙述中引入冲突和维持悬念的策略。</li>
<li>展示，而不是讲述：强调使用描述性语言和感官细节来吸引读者的重要性。</li>
<li>对话和声音：提供有关撰写真实对话和发展独特叙事声音的建议。</li>
<li>编辑和修改：提供修改和完善故事的技巧，以提高其整体质量。</li>
<li>进一步学习的资源：推荐书籍、网站或写作练习，帮助初学者提高小说写作技巧。</li>
</ul>
<h3>提示的附加上下文</h3>
<p>为了进一步增强响应，以下是 ChatGPT 可以包括的一些建议的附加主题：</p>
<ul>
<li>小说中的不同体裁：解释浪漫小说、悬疑小说、科幻小说等各种体裁，以及如何为故事选择正确的体裁。</li>
<li>创造一个引人入胜的开头：提供有关如何从故事一开始就吸引读者注意力的见解。</li>
<li>制定令人满意的结局：讨论为故事打造令人难忘且令人满意的结局的技巧。</li>
<li>平衡阐述和行动：提供指导，在提供必要信息和保持故事吸引力之间找到适当的平衡。</li>
<li>融入主题和象征意义：解释如何通过主题和象征意义为故事注入更深层的意义。</li>
<li>处理写作障碍：分享克服写作障碍并在整个写作过程中保持动力的策略。</li>
</ul>
<h3>跟进问题来引导对话</h3>
<p>在 ChatGPT 第一次回复后询问</p>
<ul>
<li>如何让我的角色更具亲和力和立体感？</li>
<li>开发情节时需要避免哪些常见陷阱？</li>
<li>您能提供使角色栩栩如生的有效对话的例子吗？</li>
<li>我如何知道我的故事是否有足够的冲突和张力来吸引读者？</li>
<li>我可以使用哪些有效的自我编辑技巧来改进我的故事？</li>
<li>您是否为初学者推荐了任何具体的写作练习或提示？</li>
<li>如何让我的故事在拥挤的市场中脱颖而出？</li>
<li>您能否建议我可以与其他小说作家联系以获得反馈和支持的任何资源或社区？</li>
</ul>
<p>从生成结果看，效果是不错的，至少生成的提示语都是与主题相关的。在面对一个陌生或不擅长的领域时，基于该工具可以了解该领域常用的提示语有哪些。</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[ChatGPT 发布对插件的支持]]></title>
            <link>https://yishulun.com/./src/posts/2023/04.html</link>
            <guid>https://yishulun.com/./src/posts/2023/04.html</guid>
            <pubDate>Fri, 24 Mar 2023 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>ChatGPT 发布对插件的支持，告诉 ChatGPT 你可以提供什么在线服务，由它作为“前端”向用户提供</h1>
<p>目录</p>
<p>[TOC]</p>
<p>2023 年北京时间 3 月 24 凌晨，OpneAI 在推特上官宣：</p>
<p><img src="https://cdn.jsdelivr.net/gh/rixingyike/images@master/2023/202303241145523.png" alt="image-20230324114533386"></p>
<p>指向的链接是：<a href="https://openai.com/blog/chatgpt-plugins">https://openai.com/blog/chatgpt-plugins</a></p>
<p>你可以立即申请加入等待列表：<a href="https://openai.com/waitlist/plugins">https://openai.com/waitlist/plugins</a></p>
<p>或阅读开发插件的文档：<a href="https://platform.openai.com/docs/plugins/introduction">https://platform.openai.com/docs/plugins/introduction</a></p>
<h2>插件可以干什么事？</h2>
<ul>
<li>检索实时信息，例如体育比分、股票价格、最新消息等；</li>
<li>检索知识库信息，例如公司文档、个人笔记等；</li>
<li>代表用户执行操作，例如预订航班、订购食物等。</li>
</ul>
<p>总而言之，可以充许你通过 ChatGPT 向你的同事或用户提供你能提供的在线服务。</p>
<p>举个例子：</p>
<p>如果用户在线问 ChatGPT：我应该在巴黎的哪里住几晚？</p>
<p>ChatGPT 模型可以选择调用酒店“预订插件 API”，接收 API 响应，并将 API 返回的数据组合起来，基于其自然语言处理能力，向用户返回人类友好的答案。</p>
<p>这里提到了 API，那么什么是 API？</p>
<h2>什么是 API？</h2>
<p>API 代表应用程序编程接口，它是一组用于构建和集成应用程序软件的定义和协议。</p>
<p>你可以把 API 理解为餐馆的服务员，举个例子，假如我们去一家饭馆，桌面上摆着一份菜单，后厨能提供菜单上的菜式。服务员是我们与后厨沟通的桥梁，你告诉服务员你选的菜，然后他再将菜带回到你的餐桌上。在这接口调用中，相当于服务员带着你的 request 去告诉 system，然后将 response 带回给你。</p>
<p>至此，全世界都可以开放自己系统的 API，然后提供给 ChatGPT 调用，而 ChatGPT 作为“前端”，向用户提供在线服务。</p>
<p>插件的宣布，宣告着智能革命的开始，从此 ChatGPT 可以访问在线服务和知识内容了。以各大平台仅存的优势就真的只剩下数据了。</p>
<h2>如何申请？</h2>
<p>你可以在这里申请加入等待列表：<a href="https://openai.com/waitlist/plugins">https://openai.com/waitlist/plugins</a></p>
<h2>如何开发ChatGPT Plugins(插件)？</h2>
<p>创建 ChatGPT 插件需要三个步骤：</p>
<ul>
<li>构建 API 代码，这是插件服务的核心；</li>
<li>接口文档化，遵照 OpenAPI 规范，以 yaml 或 JSON 格式描述 API，告诉 ChatGPT 你的接口如何调用；</li>
<li>创建一个 JSON 清单文件，该文件将定义插件的相关元数据，位于/.well-known/ai-plugin.json，它有指定的结构及字段名称，告诉 ChatGPT 你的插件是干什么用的。</li>
</ul>
<p>具体步骤，以官方<strong>构建一个简单的待办事项列表插件</strong>为例说明一下：</p>
<h3>第 1 步</h3>
<p>首先，使用以下字段定义一个 manifest.json 文件：</p>
<pre><code class="language-json">{
  &quot;schema_version&quot;: &quot;v1&quot;,
  &quot;name_for_human&quot;: &quot;TODO Plugin (no auth)&quot;,
  &quot;name_for_model&quot;: &quot;todo&quot;,
  &quot;description_for_human&quot;: &quot;Plugin for managing a TODO list, you can add, remove and view your TODOs.&quot;,
  &quot;description_for_model&quot;: &quot;Plugin for managing a TODO list, you can add, remove and view your TODOs.&quot;,
  &quot;auth&quot;: {
    &quot;type&quot;: &quot;none&quot;
  },
  &quot;api&quot;: {
    &quot;type&quot;: &quot;openapi&quot;,
    &quot;url&quot;: &quot;PLUGIN_HOSTNAME/openapi.yaml&quot;,
    &quot;is_user_authenticated&quot;: false
  },
  &quot;logo_url&quot;: &quot;PLUGIN_HOSTNAME/logo.png&quot;,
  &quot;contact_email&quot;: &quot;dummy@email.com&quot;,
  &quot;legal_info_url&quot;: &quot;http://www.example.com/legal&quot;
}
</code></pre>
<p>该文件将在/.well-known/ai-plugin.json 这个位置提供。</p>
<h3>第 2 步</h3>
<p>接下来，我们可以定义几个简单的 Python 接口，为特定用户提供创建、删除和获取 todo 列表项的功能。</p>
<pre><code class="language-py">import json

import quart
import quart_cors
from quart import request

app = quart_cors.cors(quart.Quart(__name__), allow_origin=&quot;*&quot;)

_TODOS = {}


@app.post(&quot;/todos/&lt;string:username&gt;&quot;)
async def add_todo(username):
    request = await quart.request.get_json(force=True)
    if username not in _TODOS:
        _TODOS[username] = []
    _TODOS[username].append(request[&quot;todo&quot;])
    return quart.Response(response='OK', status=200)


@app.get(&quot;/todos/&lt;string:username&gt;&quot;)
async def get_todos(username):
    return quart.Response(response=json.dumps(_TODOS.get(username, [])), status=200)


@app.delete(&quot;/todos/&lt;string:username&gt;&quot;)
async def delete_todo(username):
    request = await quart.request.get_json(force=True)
    todo_idx = request[&quot;todo_idx&quot;]
    # fail silently, it's a simple plugin
    if 0 &lt;= todo_idx &lt; len(_TODOS[username]):
        _TODOS[username].pop(todo_idx)
    return quart.Response(response='OK', status=200)


@app.get(&quot;/logo.png&quot;)
async def plugin_logo():
    filename = 'logo.png'
    return await quart.send_file(filename, mimetype='image/png')


@app.get(&quot;/.well-known/ai-plugin.json&quot;)
async def plugin_manifest():
    host = request.headers['Host']
    with open(&quot;manifest.json&quot;) as f:
        text = f.read()
        text = text.replace(&quot;PLUGIN_HOSTNAME&quot;, f&quot;https://{host}&quot;)
        return quart.Response(text, mimetype=&quot;text/json&quot;)


@app.get(&quot;/openapi.yaml&quot;)
async def openapi_spec():
    host = request.headers['Host']
    with open(&quot;openapi.yaml&quot;) as f:
        text = f.read()
        text = text.replace(&quot;PLUGIN_HOSTNAME&quot;, f&quot;https://{host}&quot;)
        return quart.Response(text, mimetype=&quot;text/yaml&quot;)


def main():
    app.run(debug=True, host=&quot;0.0.0.0&quot;, port=5002)


if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
<p>这是一个在内存中实现简单的增删改查功能的 Py 示例。它同时做为 Web Server 程序还提供了 ChatGPT 需要的 ai-plugin.json 和 openapi.yaml。</p>
<h3>第 3 步</h3>
<p>最后，我们需要设置和定义 OpenAPI 规范，以匹配本地或远程服务器上定义的接口。您不需要通过规范公开 API 的全部功能，而是可以选择性地让 ChatGPT 只访问某些功能。</p>
<p>有不少工具可以自动将服务器定义代码转换为 OpenAPI 规范，因此您不需要手动执行此操作。对于上面的 Python 代码，它的 OpenAPI 规范说明看起来像这样：</p>
<pre><code class="language-yaml">openapi: 3.0.1
info:
  title: TODO Plugin
  description: A plugin that allows the user to create and manage a TODO list using ChatGPT. If you do not know the user's username, ask them first before making queries to the plugin. Otherwise, use the username &quot;global&quot;.
  version: 'v1'
servers:
  - url: PLUGIN_HOSTNAME
paths:
  /todos/{username}:
    get:
      operationId: getTodos
      summary: Get the list of todos
      parameters:
      - in: path
        name: username
        schema:
            type: string
        required: true
        description: The name of the user.
      responses:
        &quot;200&quot;:
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/getTodosResponse'
    post:
      operationId: addTodo
      summary: Add a todo to the list
      parameters:
      - in: path
        name: username
        schema:
            type: string
        required: true
        description: The name of the user.
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/addTodoRequest'
      responses:
        &quot;200&quot;:
          description: OK
    delete:
      operationId: deleteTodo
      summary: Delete a todo from the list
      parameters:
      - in: path
        name: username
        schema:
            type: string
        required: true
        description: The name of the user.
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/deleteTodoRequest'
      responses:
        &quot;200&quot;:
          description: OK

components:
  schemas:
    getTodosResponse:
      type: object
      properties:
        todos:
          type: array
          items:
            type: string
          description: The list of todos.
    addTodoRequest:
      type: object
      required:
      - todo
      properties:
        todo:
          type: string
          description: The todo to add to the list.
          required: true
    deleteTodoRequest:
      type: object
      required:
      - todo_idx
      properties:
        todo_idx:
          type: integer
          description: The index of the todo to delete.
          required: true
</code></pre>
<p>这是 openapi.yaml 文件的内容，它将告诉 ChatGPT，如何调用接口。</p>
<p>这里提代了 OpenAI 规范，可能有读者不了解，那么什么是 OpenAI 规范？</p>
<h2>什么是 OpenAI 规范？</h2>
<p>OpenAPI 规范（OAS），是定义一个标准的、与具体编程语言无关的 RESTful API 的规范。</p>
<p>OpenAPI 规范使得人类和计算机都能在“不接触任何程序源代码和文档、不监控网络通信”的情况下理解一个在线服务的作用。</p>
<p><strong>遵循该规范的好处是什么？</strong></p>
<p>如果您遵循 OpenAPI 规范来定义您的 API，那么您就可以用文档生成工具来展示您的 API，用代码生成工具来自动生成其它编程语言的服务器端和客户端代码，用自动测试工具进行测试等等。</p>
<p>简而言之，通过该规范，我们即可以由接口程序代码生成规范，也可以由规范生成其它后端语言实现的接口程序代码。</p>
<p>这里有一个份关于 OpenAI 规范的中文文档，可以考虑：<a href="https://openapi.apifox.cn/">https://openapi.apifox.cn/</a></p>
<h2>如何由 OpenAI 规范文件生成代码？</h2>
<p>可以使用 openapi-generator-cli。</p>
<p>它的工具仓库地址是：<a href="https://github.com/openapitools/openapi-generator-cli">https://github.com/openapitools/openapi-generator-cli</a></p>
<h3>第 1 步，安装工具</h3>
<pre><code>npm install @openapitools/openapi-generator-cli -g
</code></pre>
<h3>第 2 步，由规范生成代码</h3>
<p>下面是一个使用 OpenAPI Generator 生成 Python 服务端代码的示例。</p>
<pre><code>$ openapi-generator generate -i /path/to/openapi.yaml -g python-flask -o /output/directory
</code></pre>
<p>其中，/path/to/openapi.yaml 是 OpenAPI 规范文件的路径，-g 指定使用的生成器（这里是 python-flask），-o 指定输出目录。</p>
<h2>小结</h2>
<p>1946年电子计算机被发明出来的时候，当时没有多少人意识到它将发挥多大作用，我们现在知道的信息革命其实是我们后来总结的。今天开始的智能革命，其实具有同样的特征，如果说ChatGPT的发布还不能让你感到震撼的话，那么今天它发布的ChatGPT Plugins，应该能够引起你足够的重视了。一个联网的智能机器人，无穷的数据+无穷的算力，谁也不知道将产生怎样的结果。<strong>智能革命</strong>已经到来，AI或许不会取代的人，但会使用AI的人，一定会把不会使用AI的人取代。</p>
<p>你对ChatGPT了解多少，开始试用了吗？如果你是一名程序员，开始研究它的API文档了吗？</p>
<p>新人从0到1编程自学经典<a href="https://item.jd.com/10070363837259.html">《微信小游戏开发》</a>全套书籍已经在京东、当当上架，需要签名版及1v1辅导的读者请与作者联系。作者博客：<a href="https://yishulun.com/">艺述论</a>。</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[微信小游戏开发》勘误与增补列表]]></title>
            <link>https://yishulun.com/./src/posts/2023/02.html</link>
            <guid>https://yishulun.com/./src/posts/2023/02.html</guid>
            <pubDate>Wed, 08 Mar 2023 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>《微信小游戏开发》勘误与增补列表</h1>
<p>由于水平有限，时间仓促，书中难免有遗漏、错愕之处，恳求读者朋友斧正。如有发现，可以给我发邮件9830131@qq.com，或加我的微信（9830131）告诉我。</p>
<p>下面是2023年2月&amp;3月版本1已经发现的勘误列表。</p>
<h2>前端篇</h2>
<h3>P17</h3>
<p><img src="https://cdn.jsdelivr.net/gh/rixingyike/images@master/202320230711225054-2023-07-11-22-50-56.png" alt="20230711225054-2023-07-11-22-50-56"></p>
<p>有读者找不到，在箭头处可以添加一句：具体见后端篇第16课拓展部分。</p>
<h3>P55</h3>
<p>如下所示，<code>0+&quot;10&quot;</code>结果是&quot;010&quot;，并不是数值10，红框内应改为：</p>
<blockquote>
<p>使用加号与一个数字拼接：+ &quot;10&quot;，这种方式最简单直接，其实本质上也是隐式转换。</p>
</blockquote>
<p><img src="./assets/image-20230411070305528.png" alt="image-20230411070305528"></p>
<p>该处由@<strong>MuninnC</strong>指出，感谢勘误。</p>
<h3>P156(增补)</h3>
<img src="./assets/image-20230520193735778.png" alt="image-20230520193735778" style="zoom: 67%;" />
<p>在箭头所示的地方（“..进行改写。”）添加这样一段话：</p>
<blockquote>
<p>..进行改写。注意这里的3处事件，指代码清单4-2中的click、mousemove、click三个事件，分别将以touchEnd、touchMove和touchEnd事件改写。</p>
</blockquote>
<h3>P262</h3>
<p>第一处，第4行、第5行，两行注释应改为：</p>
<pre><code>4.let d = {num: 100} // 变量d存在于栈中，{mum: 100}作为对象存在于堆内存中
5.let e = [100, 200] // 变量e存在于栈中，[100, 200]作为对象存在于堆内存中
</code></pre>
<p>第二处，划线部分应改为：</p>
<p>其中c、b、a位于栈内存，我们是直接操作的；而e、d保存的是引用地址......</p>
<img src="./assets/image-20230308234139526.png" alt="image-20230308234139526" style="zoom: 25%;" />
<h3>P281</h3>
<p><img src="./assets/image-20230611150634840.png" alt="image-20230611150634840"></p>
<p>这里在“第7行...”这一段的后面，可能需要加一段解释内容。内容如下：</p>
<p>注意第9行这里的代码，让#pos指向defaultPos，为什么也没用？原因是这样的：如果使用第9行、而不是第10～11行的代码，在第一次执行reset时，会把defaultPos这个引用对象赋值给#pos，之后小球在运动过程中，更新的都是#pos——同时也是defaultPos对象，也就是说，defaultPos这个默认值对象被“污染”了，从第二次调用reset开始，它再也不能作为默认值对象被使用了——它里面的x、y值已经不是默认值，而是小球运动最后停止时的位置。这是一处因为引用对象而产生的“陷阱”，JS中引用对象在赋值时不会产生拷贝，可能会因此产生许多问题，这里是一个很好的示例。</p>
<h3>P480</h3>
<p>划线部分应改为：渲染上下文对象属于哪个画布，就对哪个画布生效。</p>
<p><img src="./assets/75-p480.jpeg" alt="img"></p>
<h2>后端篇</h2>
<p>无</p>
<p>京东购买链接：<a href="https://item.jd.com/10070363837259.html">https://item.jd.com/10070363837259.html</a></p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[你的下一个项目应该使用 Rust 编程的 7 个理由]]></title>
            <link>https://yishulun.com/./src/posts/2023/0228.html</link>
            <guid>https://yishulun.com/./src/posts/2023/0228.html</guid>
            <pubDate>Tue, 28 Feb 2023 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>你的下一个项目应该使用 Rust 编程的 7 个理由</h1>
<blockquote>
<p>该文译自<a href="https://simpleprogrammer.com/rust-programming-benefits/%EF%BC%8C%E5%8E%9F%E4%BD%9C%E8%80%85%E6%98%AFTAPAN">https://simpleprogrammer.com/rust-programming-benefits/，原作者是TAPAN</a> PATEL。</p>
</blockquote>
<p>[TOC]</p>
<p>据最近的一项 Stack Overflow 调查证实，Rust 是 4 年多来最受欢迎的编程语言（高达 83.5% 的程序员首选）。这意味着那些尝试过并实际使用过 Rust 编程的人都对它敬畏不已。</p>
<p>然而，Rust 仍然不在最常用的编程语言前五名之列。这表明 Rust 编程在很大程度上仍然是一个充满未开发潜力的未开发领域。鉴于其受欢迎程度，越来越多的用户涌向 Rust，这意味着它将很快进入前五名，并将自己确立为世界各地程序员的主要工具。</p>
<p>为了让你不落伍，这里有一份关于什么是 Rust 编程语言的快速指南，以及你应该在下一个项目中使用 Rust 编程的七个原因。</p>
<h2>什么是 Rust 编程语言？</h2>
<p>就像真菌（是的，有一种叫做锈病的真菌！）一样，Rust 也是一种在编程世界中迅速传播的编程语言。</p>
<p>本质上，Rust 是一种编程语言，旨在克服 C++ 语言的缺点。虽然 C++ 是一种功能强大且功能无限的面向对象语言，但程序员在 C++ 中手动管理内存是相当困难的。<strong>Rust 允许你以极低的内存占用编写快速代码，为你提供了一个非常强大的编程工具。</strong></p>
<p>Rust 于 2012 年由 Mozilla 推出，但这个想法起源于一位充满激情的语言工程师 Graydon Hoare 的想法。Hoare 于 2006 年开始研究该语言，很快，Rust 的潜力引起了 Mozilla 开发人员的注意。他们与 Hoare 一起成立了一个专门的开发团队来试验该语言并以最佳方式构建它。</p>
<p>用 Hoare 的话来说，“该语言是针对沮丧的 C++ 开发人员的。”</p>
<p>下面让我们了解是什么让 Rust 比 C 或 C++ 等语言更好。</p>
<h2>Rust 是一门足够好的编程语言吗？</h2>
<p>Rust 是一种流行的编程语言，但它好吗？</p>
<p>对于初学者来说，它提供了类似于 C 和 C++ 的出色性能，并解决了内存安全问题。</p>
<p>此外，你可以使用 Rust 处理大量数据而不会损失任何性能。</p>
<p>而且，如果你还不相信。然后，你可以看看 Rust 在行业中的使用情况，Dropbox、Firefox 和 Cloudflare 等公司在生产中使用 Rust。</p>
<p>**Rust 的核心是一种静态类型的编程语言。这意味着它提供开箱即用的安全性和性能。**它提供比 C++ 更好的内存管理和安全并发。此外，<strong>如果你具有 C++ 知识，那么 Rust 很容易学习</strong>，因为 Rust 语法类似于 C++。</p>
<p>据 <a href="http://Nature.com">Nature.com</a> 宣称，科学家们也倾向于使用 Rust，因为它具有出色的内存管理功能和可用性。这些点只说明 Rust 是一门足够优秀的编程语言。</p>
<h2>列举 Rust 如此受欢迎的 6 个原因</h2>
<p>在过去三年中， Rust 一直是StackOverflow 开发人员调查中最“受喜爱”的编程语言。超过 86% 的开发人员正在使用 Rust 或表示有兴趣使用它，使其成为最受欢迎的编程语言。</p>
<p>随着使用 Rust 的开发人员数量从 2020 年的 5.1% 增加到 2021 年的 7.03%，这种兴趣现在使 Rust 更受欢迎。目前这一比例在 2022 年为 9.32%。</p>
<p>Rust 受欢迎程度的稳步上升，也意味着它已经从2020 年的倒数 7 名攀升至2022 年的前 14 名。</p>
<p>那么，是什么让它如此受欢迎呢？让我们列出六个原因。</p>
<ul>
<li>
<p>Rust 之所以流行，是因为 Rust 背后有基金会支持，其中成员包括 Microsoft、Meta、Dropbox、Arm、Google、Amazon 等成员。它在 COVID 开始时的经济崩溃期间生效。</p>
</li>
<li>
<p>Rust 很受欢迎，因为它是 C++ 的现代替代品。由于不使用空值，Rust 绕过了 C++ 错误。此外，Rust 的编译速度几乎与 C++ 相当，全球的开发人员都致力于通过 LLVM（低级虚拟机）改进进一步提高其编译速度。</p>
</li>
<li>
<p>Rust因其官方包管理器 Cargo 而广受欢迎。它解决了每次进行更改时重新编译代码的主要 C++ 缺点。Cargo 通过检查依赖性来绕过重新编译。</p>
</li>
<li>
<p>Rust因其卓越的内存管理而广受欢迎。使用 Rust，你可以控制内存分配和取消分配的工作方式。创建变量时会分配智能指针以简化内存管理。如果智能指针超出范围，就会发生取消分配。这种方法为你提供了完全控制，并允许你使用多个共享相同数据的智能指针。</p>
</li>
<li>
<p>Rust 很受欢迎，因为它通过提供一种无错误的方法来编写易于重构的代码来掌握并发性。</p>
</li>
<li>
<p>Rust 很受欢迎，因为它提供 WebAssembly 支持。这意味着开发人员可以在 Web 上创建音频、视频、3D 环境、游戏等。</p>
</li>
</ul>
<p>Rust 日新月异。甚至 Linux 的创造者 Linus Torvalds 也计划在 2023 年在 Linux Kernal 中使用 Rust 来对 Kernel 基于性能方面进行编程。</p>
<h2>为什么 Rust 是你下一个项目的最佳选择？（7个理由）</h2>
<p>Rust 包含许多 Web 开发人员绝对喜欢使用的功能。以下是我选择使用 Rust 的主要原因：</p>
<h3>1.Rust 解决内存管理问题</h3>
<p>系统编程通常需要低级内存控制，而使用 C 的手动内存管理，这项任务可以证明是一场真正的噩梦。</p>
<p>Rust 具有为低级细节提供便利的不可思议的能力。它可以直接访问硬件和内存，因为它不需要垃圾收集器在后台连续运行。</p>
<p>这意味着用 Rust 编写代码就像使用微控制器应用程序编写低级代码一样。你可以完全自由地替换代码片段，而无需承担内存安全风险。</p>
<h3>2.Rust 的低开销使其成为嵌入式编程的理想选择</h3>
<p>资源受限是常态，嵌入式系统通常出现在机器和家用电器上。这就是嵌入式系统需要像 Rust 这样开销非常低的现代编程语言的原因。</p>
<p>Rust 是嵌入式系统中一种资源高效且需求旺盛的功能。它允许程序员及早识别错误，防止设备将来发生任何事故。</p>
<p>蛋糕上的樱桃是 Rust 的零成本抽象能力。无论你使用何种抽象代码，Rust 都足够慷慨地接受它。你可以使用循环、闭包或当天你喜欢的任何代码风格，它们都将编译为同一个程序集，而不会影响代码的性能。</p>
<h3>3.Rust 促进强大的 Web 应用程序开发</h3>
<p>为 Web 应用程序开发选择正确的技术堆栈时，一个重要的考虑因素是编程语言的选择。有充分的理由将 Rust 编程包含在你的 Web 应用程序技术栈中。</p>
<p>如果你习惯于使用 Java 或 Python 等高级语言开发 Web 应用程序，那么你会爱上使用 Rust。使用 Rust，你可以更加确信代码不会出错。</p>
<p>对于任何已经精通 C 的人来说，Rust 都很容易学习。此外，你可以立即开始修补 Rust，而无需花费数年时间学习技巧。</p>
<p>使用 Rust 进行 Web 开发的主要亮点是：</p>
<p>你可以将 Rust 编译为WebAssembly，这样可以更轻松地在 Web 上获得接近原生的性能。<br>
Rust 允许任何语言编译成 WebAssembly，从而允许可移植的、可执行的在线运行代码。</p>
<p>简而言之，对于 Web 开发，Rust 是吸收了所有正确维生素的语言！</p>
<h3>4.Rust 的静态类型确保易于维护</h3>
<p>Rust 是一种静态类型语言。在 Rust 中编程时，所有类型在编译时都是已知的。Rust 也是一种强类型语言，这意味着用 Rust 更难编写不正确的程序。</p>
<p>管理复杂性是成功编程的核心。随着代码的增长，复杂性也随之增加。静态类型语言允许你密切关注代码中发生的事情，从而实现高度的简单性。</p>
<p>Rust 也不需要你多次重复变量的类型，鼓励长期可维护性。</p>
<p>简而言之，Rust 允许嵌套和闭包，这反过来又提高了代码的可维护性。</p>
<h3>5.Rust 具有快速和高性能</h3>
<p>Rust 的性能与 C++ 相当，并且轻而易举地击败了 Python 等语言。</p>
<p>没有垃圾收集有助于 Rust 的高速。与许多其他语言不同，Rust 没有运行时检查，编译器会将错误的代码扼杀在萌芽状态。这可以防止错误代码扩散并对系统造成严重破坏。</p>
<p>最后，如前所述，Rust 在嵌入式系统中的执行速度也非常快。</p>
<h3>6.跨平台开发与支持</h3>
<p>使用 Rust，你可以轻松构建可在各种操作系统（如 Linux、macOS、Windows 和其他平台）上运行的跨平台解决方案。</p>
<p>值得注意的是，Rust 允许你对应用程序的前端和后端进行编码。Rocket、Nickel和Actix等 Rust Web 框架的可用性使使用 Rust 进行开发变得更加容易。</p>
<p>使用 Rust 开始开发非常容易——只需打开Rustup，一个快速的工具链安装程序和版本管理工具，然后按照说明进行操作。你可以选择根据需要格式化代码。Rustfmt允许基于默认格式样式自动进行代码格式化。Clippy是一种有助于维护惯用代码风格的工具，它负责其余的工作。</p>
<h3>7.Rust 拥有广阔的生态系统</h3>
<p>随着 Rust 的日益流行，Rust 生态系统正在迅速扩展。庞大的生态系统中的一个主要因素是它不仅仅是一种语言或编译器。软件生产质量需要更多方面，而 Rust 生态系统认为所有这些都非常重要。</p>
<p>首先，Cargo 是 Rust 程序员使用的命令行工具，可帮助管理依赖项、运行测试和生成文档。</p>
<p>其次，Rust 有一个社区站点 <a href="http://crates.io">crates.io</a>，可以满足你对 Rust 库的需求。你可以在docs.rs上找到在 <a href="http://crates.io">crates.io</a> 上发布的任何库的文档。</p>
<p>新手 Rust 开发人员也可以轻松访问基于属性的测试、基准测试和模糊测试。</p>
<p>与专业人士交流和学习也很容易。有多个 Rust 会议，如RustConf、RustBelt和RustFest，它们是 Rust 开发人员的知识金矿。</p>
<h2>是什么让 Rust 与众不同？</h2>
<p>Rust 的专长在于它能够为程序员提供编写无错误代码而不影响性能的工具。它的内存安全功能克服了流行编程语言（如 C 和 C++）的缺点。</p>
<p>你还可以获得零成本的抽象，这些抽象可以提高代码的性能，因为无论你采用何种方法对解决方案进行编码，它都会生成相同的程序集。出色的并发支持还意味着你可以编写易于重构的代码。</p>
<h3>语言对比：Rust vs Go</h3>
<p>Google 的 Go 大量借鉴了 C 来克服 C++ 的缺点。它增加了结构类型、垃圾收集和内存安全，重点是多核开发，以实现更好的并发性和并行性。</p>
<p>另一方面，Rust 是一种多范式通用编程语言，它解决了 C++ 内存安全问题，同时提供了类似的性能。</p>
<p>Go 是对微服务、CLI 和流处理进行编程的绝佳选择。它的占用空间小意味着你可以将它与云原生应用程序一起使用。Rust 更加通用，因为它可用于为嵌入式系统开发程序，同时由于 WebAssembly 支持，它也适用于 Web 开发。</p>
<p>两者都是出色的编程语言，具有许多相似之处，即使是为不同的目的而创建的。由于两者都是编译的而不是解释的，因此它们提供开箱即用的性能。</p>
<p>因此，如果你正在寻找一种简单易用的通用语言，请选择 Go。它提供了一个专注于性能的良好并发模型。如果你正在开发以性能为中心的解决方案，那么 Rust 是一个不错的选择。它使你可以进行低级编码而不必担心内存管理。</p>
<h3>语言对比：Rust vs C++</h3>
<p>C++ 是最古老的编程语言之一，由丹麦计算机科学家 Bjarne Stroustrup 在四十年前的 1985 年发布。它是一种通用编程语言，旨在扩展 C 编程语言的功能。Rust 大量借鉴了 C++，这就是为什么你会发现它们之间有很多相似之处。</p>
<p>Rust 和 C++ 之间的第一个区别是它们处理内存的方式。通过更好的内存管理，你可以使用 Rust 编写在机器级别表现良好的无错误代码。它们都是编译语言，不需要运行时或垃圾收集器。</p>
<p>在性能方面，C++ 略胜一筹。Rust 速度很快，但需要更多的打磨才能变得和 C++ 一样快。然而，Rust 社区正在努力在 LLVM 级别优化 Rust 以获得更高的性能。</p>
<p>至于易学性，如果你是编程新手，<strong>学习 C++ 将花费大量时间，对于需要更多精力和时间的 Rust 也是如此</strong>。但是，如果你已经了解 C++，则可以快速开始使用 Rust。（Rust的学习曲线比较陡峭，新人并不建议直接从Rust入门。布道师甚至建议直接从C入门，都不会建议直接从Rust入门，有人甚至说建议新人直接写Rust，与劝人跳崖无异。）</p>
<h2>何时使用Rust？Rust最适合的6个使用领域</h2>
<p>说了这么多，做了这么多，很容易看出 Rust 在未来所有项目中的应用有多棒。</p>
<p>但是你究竟在什么地方和什么时候使用 Rust 编程？</p>
<p>我们知道在编码方面没有万能的解决方案。这就是为什么了解在哪些情况下 Rust 是更好的解决方案很重要。</p>
<p>以下是一些使用 Rust 进行编程的有益示例：</p>
<ul>
<li>当你开发性能至关重要的应用程序时，Rust 可以证明是一个不错的选择。</li>
<li>当你的解决方案需要在短时间内处理大量数据时，请选择 Rust。</li>
<li>当你想要更好地控制线程中的资源分配时，请使用 Rust。</li>
<li>Rust 提供内存安全，但也很复杂，因此当内存安全至关重要时选择它。</li>
<li>使用 Rust 重写应用程序的敏感部分，其中程序速度至关重要。</li>
</ul>
<p>上述因素使 Rust 成为开发游戏引擎、操作系统、文件系统、浏览器组件和 VR 模拟引擎等应用程序的理想选择。下面细致讲一下。</p>
<h3>1.Rust 是编写物联网代码的绝佳语言</h3>
<p>Rust 是程序员为 IoT 应用程序编写代码的首选语言。</p>
<p>随着Raspberry Pi和Arduino等设备的出现，创客运动风靡一时。如果你是将物联网视为下一个十亿美元机会的程序员之一，那么你不能忽视学习 Rust 编程。</p>
<p>Rust 是一种接近底层的、无运行时的语言，这意味着你可以在内存储备有限的地方使用它。</p>
<p>正因为如此，Rust 被证明是一种为 Raspberry Pi、Arduino 或 Tessel 等微控制器硬件编写代码的优秀语言。</p>
<h3>2.Rust编程可用于HPC（高性能计算）</h3>
<p>将 Rust 用于 HPC 的问题是你的大部分代码将用 C 编写。它的美妙之处在于使用它的 FFI（外部函数接口），你可以在没有任何开销的情况下执行 Rust 代码。换句话说，Rust 允许你一个接一个地重写你的应用程序模块。</p>
<p>使用 Rust 的开发人员体验也好得多，因为它不会影响应用程序的性能。Rust 还将使你的应用程序能够在大量内核上更好地扩展，这在 HPC 中至关重要。</p>
<h3>3.使用 WebAssembly (WASM) 编写 Web 应用程序</h3>
<p>Rust 支持 WebAssembly，这是一种快速、现代且安全的创建 Web 应用程序的方法。将 Rust 与 WebAssembly 结合使用可为你提供可预测的性能、较小的代码大小以及对优秀库集的访问。</p>
<p>WASM + Rust 与 JavaScript 配合得很好。这意味着你不必替换现有的代码库，并且可以进行扩充以从 Rust 的性能中获益。此外，Rust 还可以与现有的工具链一起使用，例如 npm。</p>
<h3>4.科学项目</h3>
<p>Rust 的速度和安全性也引起了科学家们的关注。他们正在从 Python 转向 Rust，即使掌握和使用它需要时间。<a href="http://xn--Nature-hz8lt03a.com">根据Nature.com</a> 文章，科学家 Köster 创造了 Varlociraptor，它通过将序列与遗传碱基进行比较来识别基因组变异。Rust 使得以最佳速度进行数百万次此类计算成为可能。</p>
<p>Rust 内存模型还让科学家们不用担心内存泄漏或安全漏洞。科学家通过更高的学习和实施时间在编译期间消除错误。所有这些也适用于并行代码。</p>
<h3>5.游戏开发</h3>
<p>游戏开发是另一个出色的 Rust 用例。有很多 Rust 游戏引擎可以帮助你入门。其中包括 Amethyst——一种面向数据的游戏引擎；bevy——另一个数据驱动的游戏引擎；Fyrox – 生产就绪引擎和 Nonnou – 开源游戏框架。</p>
<h3>6.区块链开发</h3>
<p>你还可以使用 Rust 进行区块链开发。区块链背后的想法是提供一个不可变的去中心化数字分类账，一旦数据被写入就无法篡改。Rust 出色的内存安全性意味着开发人员可以创建内存安全的区块链应用程序。其他 Rust 特性，例如速度和可靠性，使其成为区块链的不错选择。在这里，你可以尝试基于 Rust 的 OpenEthereum 和 Lighthouse 框架。</p>
<h2>哪些大厂在使用 Rust语言？</h2>
<p>Rust 不仅在开发人员中流行（如 StackOverFlow 开发人员调查所示），而且在公司中也很流行。在生产中使用 Rust 的顶级公司是：</p>
<table>
<thead>
<tr>
<th><strong>公司</strong></th>
<th><strong>做什么的</strong></th>
<th><strong>使用的其他技术</strong></th>
<th><strong>使用 Rust 的原因</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://medium.com/coursera-engineering/rust-docker-in-production-coursera-f7841d88e6ed">Coursera——</a>流行的在线学习平台</td>
<td>他们使用 Rust 为学生的编程作业提供支持。通过网络，学生可以编写和运行具有类似本地性能的计算机程序。</td>
<td>他们在 Docker 容器下运行它。</td>
<td>为学生运行代码提供安全的环境。C 也是一个不错的选择，但缺乏 Rust 的灵活性。Rust 提供了一个强大的系统，并且不受某些安全漏洞的影响。</td>
</tr>
<tr>
<td><a href="https://dropbox.tech/infrastructure/rewriting-the-heart-of-our-sync-engine">Dropbox——</a>流行的文件存储平台</td>
<td>Dropbox 的文件同步引擎使用 Rust。</td>
<td>SSL、Nginx、Python、S3、EC2</td>
<td>Rust 使得编写并发代码变得容易，并且易于测试和调试。此外，Rust 的大量编译时和静态类型有助于管理并发代码和复杂的数据库。</td>
</tr>
<tr>
<td><a href="https://www.rust-lang.org/static/pdfs/Rust-npm-Whitepaper.pdf">npm——</a>一个 JavaScript 包管理器</td>
<td>npm 的主要服务用 Rust 重写。</td>
<td>JavaScript</td>
<td>他们重写了主要服务以提高其性能并解决随着用户群的增长而可能发生的瓶颈。Rust 的内存管理是另一个原因。</td>
</tr>
<tr>
<td><a href="https://www.figma.com/blog/rust-in-production-at-figma/">Figma——</a>一种网络协作设计工具</td>
<td>Figma 的多人同步引擎是用 TypeScript 的 Rust 重写的</td>
<td>LiveGraph, AWS</td>
<td>由于性能优势，Figma 选择了 Rust。</td>
</tr>
<tr>
<td>Microsoft</td>
<td>他们正在尝试将 Rust 集成到 C/C++ 中</td>
<td>许多</td>
<td>Rust 出色的内存安全性解决了微软 70% 的与内存安全相关的常见漏洞和暴露（CVE）。</td>
</tr>
<tr>
<td><a href="https://discord.com/blog">Discord</a></td>
<td>Discord 在服务器端和客户端都使用 Rust。他们使用 Rust 和 Exilir Native Implemented Functions (NIFs) 来扩展他们的 Discord 解决方案。Read States 服务也用 Rust 重写。</td>
<td>JavaScript、Python、Rust、C++</td>
<td>Rust 克服了 Go 使用垃圾收集器及其内存模型的限制，这些限制增加了延迟峰值。</td>
</tr>
<tr>
<td>Facebook</td>
<td>Facebook 希望消除错误并改进编译器反馈循环，因此他们用 Rust 重写了源代码控制后端。</td>
<td>Python、网络技术</td>
<td>好处包括无错误代码和在编译期间捕获错误。源代码也变得易于维护。</td>
</tr>
</tbody>
</table>
<h2>细数一下Rust语言的缺点</h2>
<p>Rust 是新的和令人兴奋的，并提供许多好处，包括内存安全、零抽象、web-assembly 支持和性能。但是，它并非没有缺点，其中包括：</p>
<ul>
<li>编译时错误和缓慢的编译时间：Rust 实现内存安全是因为它在编译时强制执行的规则。这意味着你会看到大量的错误，这会让许多程序员感到沮丧。</li>
<li>缺少所需的库：Rust 是新的，因此缺少你可以使用其他编程语言轻松获得的所需库。<br>
原型不友好：由于编译需要花费大量时间并且需要 100% 的条件覆盖率，因此 Rust 不适合原型解决方案。</li>
<li>不适合初学者：Rust 不适合初学者，因为它包含需要时间才能掌握的高级概念。<br>
小市场：Rust 市场仍在增长，与其他成熟的编程语言相比，机会更少。</li>
<li>它从未最终确定：Rust 是一个正在进行的项目，旨在提供向后兼容性和稳定性。这意味着 Rust 功能需要时间才能获得稳定的支持。</li>
<li>更小的目标平台：由于在 Rust 编译器中使用 LLVM，目标平台的数量比 C/C++ 小。</li>
</ul>
<h2>你应该学习 Rust 吗？</h2>
<p>Rust 正在迅速增长（正如 StackOverFlow 开发人员过去三年的调查所表明的那样）。因此，学习 Rust 并不是一个坏主意，因为它会提高你的就业能力。</p>
<p>从技术角度来看，Rust 为创建安全、快速和可移植的应用程序提供了强大的工具解决方案。它提供并发性、内存安全和高性能，专注于想要开发可靠产品的开发人员。这就是开发人员喜欢它的原因。你还可以访问不断壮大的 Rust 社区和 Rust 包。</p>
<p>因此，如果你是一名想要开发健壮且内存安全的应用程序的开发人员，那么 Rust 是你的选择。当你从一开始就编写可靠的代码时，它提供了长期的稳定性——部署几个月后你不会遇到空指针或运行时问题。</p>
<p>编译器向你抛出错误，就好像它是你的代码助手一样。它提供了详细的错误和帮助消息，以便你可以调试它们。使 Rust 具有吸引力的其他特性包括：</p>
<ul>
<li>使用模式匹配处理分支。</li>
<li>Crater 工具可在你通过详细报告进行更新之前检查新的 Rust 版本是否会破坏你的 Rust 项目。</li>
<li>WebAssembly 支持允许你创建在网络上运行的应用程序。</li>
</ul>
<h2>你应该学习 Rust 还是 Python？</h2>
<p>建议两者都学。Rust 是一种相当新的编程语言，市场机会有限。至于学习上的困难，还是从Python入手比较好。Python 对初学者很友好。它将帮助你掌握抽象、面向对象范式、函数式编程和其他编程概念。一旦你掌握了它，你就可以转向 Rust。</p>
<p>学习 Rust 时，你将探索更高级的概念。在这里，你将学习如何借助详细的编译器错误来编写无错误的代码。Rust 对 WebAssembly 的支持意味着你还可以在 Web 上编写各种应用程序。</p>
<p>但是，在 Python 和 Rust 之间进行选择取决于你的目标。例如：</p>
<ul>
<li>选择 Python 进行数据科学</li>
<li>选择 Python 与 Django 和其他 Web 开发框架进行 Web 开发（此处并未建议采用Rust进行Web开发）</li>
<li>选择 Rust 进行软件和操作系统开发</li>
<li>选择 Rust 进行区块链技术开发</li>
<li>选择 Rust 进行以 WebAssembly 为中心的开发</li>
<li>选择 Rust 进行神经网络开发</li>
</ul>
<h2>如何学习 Rust 编程</h2>
<p>开始学习 Rust 的最佳方式是访问Learn Rust站点。在这里，你可以找到详细的核心 Rust 文档，并可以访问不同类型的书籍。Rust 编程语言（绰号“书”）非常详细地介绍了 Rust。在本书中，你可以通过创建几个项目来学习 Rust。除此之外，你还可以参加包含小练习的Rustlings 课程。</p>
<p>此外，你还可以阅读 Learn Rust 网站上的其他指南，包括：</p>
<ul>
<li>了解 Rust 包管理器的 Cargo 书。</li>
<li>了解 Rust 版本的版本指南。</li>
<li>让你熟悉 Rust 编译器的 Rustc 书。</li>
<li>编译器错误索引以获得对 Rust 编译器错误的深入解释。</li>
<li>学习如何在 Rust 中使用有效命令行的书</li>
<li>WebAssembly 书，学习如何使用 Rust 创建浏览器原生库。</li>
<li>嵌入式书籍，学习如何将 Rust 用于嵌入式系统。</li>
<li>你还可以在网络上找到多种 Rust 教学资源。如果你想替代书面内容，可以找找 Youtube 视频。</li>
</ul>
<h2>发现 Rust 的潜力</h2>
<p>编程使用 Rust 编程的主要好处是其高效的内存管理能力。</p>
<p>然而，最重要的是，它为各种应用程序（尤其是 Web 应用程序）提供了极好的速度和安全性。因为它具有强大的命令行界面工具，所以它也是开发跨平台应用程序的绝佳工具。Rust 非常适用于低资源环境，它还通过使程序员能够使用现有代码交叉编译新代码来节省开发时间。</p>
<p>除了作为开发游戏引擎和操作系统的理想工具之外，Rust 编程还具有巨大的物联网开发潜力。</p>
<p>当你选择 Rust 时，一个充满活力的社区会欢迎你，所以请相信 Rust 编程语言并投身于这个充满可能性的激动人心的世界！</p>
<p>译者注：国内目前也有不少Rust相关的优秀图书及教程，并不一定要在youbube上学习。</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[如何不移除`<p>`标签而将段落连接起来？]]></title>
            <link>https://yishulun.com/./src/posts/2022/34.html</link>
            <guid>https://yishulun.com/./src/posts/2022/34.html</guid>
            <pubDate>Thu, 29 Dec 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>如何不移除<code>&lt;p&gt;</code>标签而将段落连接起来？</h1>
<p>这是一个很经典的CSS布局问题，新人彻底理解了这个问题，HTML网页布局思想便已掌握了七七八八了。</p>
<h2>问题</h2>
<p>先看一段HTML代码：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;
&lt;h1&gt;这是一个标题&lt;/h1&gt;
	&lt;div class=&quot;wrapper&quot;&gt;
    &lt;p&gt;这是一个段落&lt;/p&gt;
    &lt;p&gt;这是一个段落&lt;/p&gt;
    &lt;p&gt;这是一个段落&lt;/p&gt;
  &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>因为p标签默认是块级元素，宽度默认会占满父容器的100%，所以这个代码默认展现出来的样式是这样的：</p>
<p>::: normal-demo</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;
&lt;h1&gt;这是一个标题&lt;/h1&gt;
	&lt;div class=&quot;wrapper&quot;&gt;
    &lt;p&gt;这是一个段落&lt;/p&gt;
    &lt;p&gt;这是一个段落&lt;/p&gt;
    &lt;p&gt;这是一个段落&lt;/p&gt;
  &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>:::</p>
<p>问题与这个示例有关，是这样的：如何将三行文本“这是一个段落”合并到一行，从左向右排行显示，且不用移除<code>&lt;p&gt;</code>标签？</p>
<p>最简单的解决方案只需要加一行CSS样式代码：</p>
<pre><code class="language-CSS">.wrapper p {
  display: inline;
}
</code></pre>
<p>运行效果如下所示：</p>
<p>::: normal-demo</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;
  &lt;style&gt;
  .wrapper p {
    display: inline;
  }
  &lt;/style&gt;
  &lt;h1&gt;这是一个标题&lt;/h1&gt;
  &lt;div class=&quot;wrapper&quot;&gt;
    &lt;p&gt;这是一个段落&lt;/p&gt;
    &lt;p&gt;这是一个段落&lt;/p&gt;
    &lt;p&gt;这是一个段落&lt;/p&gt;
  &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>:::</p>
<h2>为什么简单加一个<code>inline</code>样式就可以解决问题？</h2>
<p>早期网页为了从向至下流式展示内容，根据需要将标签元素默认分为了两类：</p>
<ul>
<li>块级元素</li>
<li>行内元素</li>
</ul>
<p>块级元素默认占据父容器的100%宽度，同时可以有高度，在不指定高度的时候，高度由子元素堆积决定。例如div、p、h1~h6等标签，凡是默认在网页中占据全部页面宽度的元素，都是块级元素。</p>
<p>而行内元素用于在一行内从左向右展示小内容，行内元素默认只有宽度，没有高度，并且它们的宽度也是由它们本身的内容所决定的。例如a、br、b、em、img、sub、sup、strong等标签，凡是默认不占据100%父容器宽度的元素，都可以视为行内元素。如果想给行内元素指定高度，可以在父容器上给行元素设置line-height样式。</p>
<p>这两类元素的作用，就是合起来展示一个从上至下依次展示、每行从左至右依次排列的流布局，如下所示。</p>
<p><img src="./assets/image-20221229105113884.png" alt="流式布局"></p>
<p>回头看我们的示例，p标签默认是块级标签，它在渲染时要占满页面容器的100%宽度，所以默认效果三行文本“这是一个段落”是从上向下依次排列的。</p>
<p>当我们通过类选择器+标签选择器（<code>.wrapper p</code>），修改了所有p标签的display样式后，即将display样式设置为inline，这时候这个页面内的所有p标签已经不是块级元素了，都变成了行内元素。</p>
<p>HTML元素是什么块级元素，还是行内元素，本质上是由它们携带的默认的CSS样式决定的，也就是由display等于block或inline决定的，等于block就是块级元素，等于inline就是行内元素。因为CSS可以控制一切HTML元素的样式，事实上我们甚至可以将任何一个HTML元素修改为其他元素————当然如果真修改的话，这里还涉及元素属性的问题，在这里我们只谈样式。HTML元素默认携带的样式是由其名称决定的，所有元素的默认样式都是可以通过CSS代码修改的。</p>
<p>当给p标签设置了display样式为inline以后，这时候p标签的行为与span标签类似了，于是三行文本“这是一个段落”便是从左向右，在一行内展示了，如果一行展示不了，内容还会自动换行，就像其他行内元素所表示出来的行为那样。</p>
<h2>由inline-block决定的行内块级元素</h2>
<p>随着网页布局复杂度的提升，后来又出现了inline-block样式值，我们可以修改示例，看一看将display修改为inline-block之后的效果，如下所示。</p>
<p>::: normal-demo</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;
  &lt;style&gt;
  .wrapper p {
    display: inline-block;
  }
  &lt;/style&gt;
  &lt;h1&gt;这是一个标题&lt;/h1&gt;
  &lt;div class=&quot;wrapper&quot;&gt;
    &lt;p&gt;这是一个段落&lt;/p&gt;
    &lt;p&gt;这是一个段落&lt;/p&gt;
    &lt;p&gt;这是一个段落&lt;/p&gt;
  &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>:::</p>
<p>效果与修改为inline是相似的，在这个示例中看不出什么差别。事实上inline-blcok代表行内的块级元素，这样的元素既可以在一行之内从左向右自动依次排列，可以拥有自己的高度，又可以作为一个局部的小容器，再容纳其他子元素。</p>
<p>inline-blcok样式的出现，代表CSS在网页布局方面已经没有什么能力短板了，只有网页设计师想不到的，没有CSS实现的布局。</p>
<h2>flex布局</h2>
<p>但CSS的网页布局能力发展到这里并没有停止，后来为了更好了处理父容器与子元素的组合样式，flex布局被发明出来了。flex布局能够实现的效果，用以往的CSS也可以实现，但用flex布局的方法实现，代码会更简洁、逻辑会更加清晰、页面的扩展性也更好。</p>
<p>下面<a href="https://yishulun.com/">作者</a>仍然拿上面的示例改造，如果不设置display为inline或inline-block，使用flex布局怎么达到同样的效果呢？也是只添加一行CSS代码就足够了，如下所示。</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;
  &lt;style&gt;
  .wrapper {
    display: flex;
  }
  &lt;/style&gt;
  &lt;h1&gt;这是一个标题&lt;/h1&gt;
  &lt;div class=&quot;wrapper&quot;&gt;
    &lt;p&gt;这是一个段落&lt;/p&gt;
    &lt;p&gt;这是一个段落&lt;/p&gt;
    &lt;p&gt;这是一个段落&lt;/p&gt;
  &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>运行效果如下所示：</p>
<p>::: normal-demo</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;
  &lt;style&gt;
  .wrapper {
    display: flex;
  }
  &lt;/style&gt;
  &lt;h1&gt;这是一个标题&lt;/h1&gt;
  &lt;div class=&quot;wrapper&quot;&gt;
    &lt;p&gt;这是一个段落&lt;/p&gt;
    &lt;p&gt;这是一个段落&lt;/p&gt;
    &lt;p&gt;这是一个段落&lt;/p&gt;
  &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>:::</p>
<p>效果是一样的。</p>
<p>将display设置为flex就代表了启用flex布局。因为默认情况下flex-direction等于row，子元素会像行内元素那样从左向右排行，所以只写一行display等于flex样式代码就可以了。</p>
<p>flex布局能力很强大，它不仅可以处理从左向右的横向布局，还可以处理从上向下的纵向布局，两个方向的布局使用的是同一套样式语义。</p>
<p>很多人都觉得这套语义记了又忘，实在很难记住，即使是富有经验的网页设计师在许久不手写CSS代码之后，也需要借助工具才可以将样式代码写对。针对开发者的这个痛点，新版本的Chrome浏览器现在提供了这样的一个flex布局辅助设计功能，如下所示，当我们给元素添加了display等于flex的样式代码后，后面会出现一个功能按钮，点击它，会展开一个flex布局互动小面板。点击这个面板上具体的排列项，相应的样式代码即会自动生成。</p>
<p><img src="./assets/image-20221229111710840.png" alt="image-20221229111710840"></p>
<p>以后不用再记那些难记的样式名称了，有需要的时候调出这个flex布局互动小面板，动手你发财的小手点一点，所有布局代码都能搞定了。</p>
<h2>小结</h2>
<p>HTML开发主要有两种布局思想：传统div流式布局和flex布局。</p>
<p>还有一种全页面都使用绝对值定位的布局思想，这种布局思想只适用于Web管理后台或工具Web项目等开发场景，对于面向C端用户的场景是不适用的。HTML网页的根本设计哲学是流式布局————整体上从上向下、行内从左向右的流式布局，这种布局可以让HTML内容可以一边加载一边渲染与展示，这是一种很好的设计哲学，不要轻易舍弃这种哲学。</p>
<p>flex布局本质上继承了流式布局的思想，它与流式布局并不冲突，只是丰富了CSS在父容器子元素组合关系布局上的能力。在网页设计中，现在普遍优先使用flex布局，用最简单的CSS代码达到设计的需求。在具体设计时，配合使用Chrome开发者工具中的flex布局小面板，写起​flex布局代码也很容易。</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[JS如何返回异步调用的结果？]]></title>
            <link>https://yishulun.com/./src/posts/2022/33.html</link>
            <guid>https://yishulun.com/./src/posts/2022/33.html</guid>
            <pubDate>Mon, 26 Dec 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>JS如何返回异步调用的结果？</h1>
<p>这个问题<a href="https://yishulun.com/">作者</a>认为是所有从后端转向前端开发的程序员，都会遇到的第一问题。JS前端编程与后端编程最大的不同，就是它的异步机制，同时这也是它的核心机制。</p>
<p>为了更好地说明如何返回异步调用的结果，先看三个尝试异步调用的示例吧。</p>
<p><strong>示例一：调用一个后端接口，返回接口返回的内容</strong></p>
<pre><code class="language-js">function foo() {
  var result
  $.ajax({
    url: &quot;...&quot;,
    success: function(response) {
      result = response
    }
  });
  return result // 返回：undefined
}
</code></pre>
<p>函数foo尝试调用一个接口并返回其内容，但每次执行都只会返回undefiend。</p>
<p><strong>示例二：使用Promise的then方法，同样是调用接口然后返回内容</strong></p>
<pre><code class="language-js">function foo() {
  var result
  fetch(url).then(function(response) {
    result = response
  })
  return result // 返回：undefined
}
</code></pre>
<p>与上一个示例的调用一样，也只会返回undefined。</p>
<p><strong>示例三：读取本地文件，然后返回其内容</strong></p>
<pre><code class="language-js">function foo() {
  var result
  fs.readFile(&quot;path/to/file&quot;, function(err, response) {
    result = response
  })
  return result // 返回：undefined
}
</code></pre>
<p>毫无意外这个示例的调用结果也是undefined。</p>
<p>为什么？</p>
<p>因为这三个示例涉及的三个操作————ajax、fetch、readFile都是异步操作，从操作指令发出，到拿到结果，这中间有一个时间间隔。无论你的机器性能多么强劲，这个间隔也无法完全抹掉。这是由JS的主线程是单线程而决定的，JS代码执行到一定位置的时候，它不能等待，等待意味着用户界面的卡顿，这是用户不能容忍的。JS采用异步线程优化该场景，当主线程中有异步操作发起时，主线程不会阻塞，会继续向下执行；当异步操作有数据返回时，异步线程会主动通知主线程：“Hi，老大，数据来了，现在要用吗？”</p>
<p>“好的！马上给我。”</p>
<p>这样异步线程把异步代码推给主线程，异步代码才得以执行。对于上面三个示例而言，<code>result = response</code>就是它们的异步代码。</p>
<p>下面<a href="https://yishulun.com/">作者</a>画一张辅助理解这种机制吧：</p>
<p><img src="./assets/JS%E7%9A%84%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6.png" alt="JS的异步线程机制"></p>
<p>当异步线程准备好数据的时候，主线程也不是马上就能处理，只有当主线程有空闲了，并且前面没有排队等待处理的数据了，新的异步数据才能得以处理。</p>
<p>在了解了JS的异步机制以后，下面看前面三个示例如何正确改写。</p>
<h2>回调函数：最古老的异步结果返回方式</h2>
<p>先看示例一，使用回调函数改写：</p>
<pre><code class="language-js">function foo(callback) {
  $.ajax({
    url: &quot;...&quot;,
    success: function(response) {
      callback(response)
    }
  });
  // return result // 返回：undefined
}
</code></pre>
<p>在调用函数foo的时候，事先传递进来一个callback，当ajax操作取到接口数据的时候，将数据传递给callback，由callback自行处理。</p>
<p>这种基于回调的解决方案，虽然“巧妙”地解决了问题，但在存在多层异步回调的复杂项目中，往往由于一个操作依赖于多个异步数据而造成“回调噩梦”。</p>
<h2>ES2015：使用Promise对象与then方法链式调用</h2>
<p>第二种改进的方案，不使用回调函数，而是使用ES2015中新增的Promise及其then方法，下面以示例二进行改造：</p>
<pre><code class="language-js">function foo() {
  return new Promise(function(resolve, reject) {
    fetch(url).then(function(response) {
        resolve(response)
    })
  })
}
foo().then(function(res){
  console.log(res)
})..catch(function(err) {
  //
})
</code></pre>
<p>foo返回一个Promise对象，注意，Promise仅是一个可能承载正确数据的容器，它并不是数据。在使用它的，需要调用它的then方法才能取得数据（在有数据返回的时候）。与then同时存在的另一个有用的方法是catch，它用于捕捉异步操作可能出现的异常，处理可能的错误对加强鲁棒性至关重要，这个catch方法不容忽视。</p>
<p>注意：示例中的fetch方法<a href="https://yishulun.com/">作者</a>没有给出具体实现，它在这里是作为一个返回Promise对象的异步操作被对待的，也因此我们看到了，在这个方法被调用后返回的对象上，也可以紧跟着调用then方法（第3行）。</p>
<p>但是，这种使用Promise的解决方案就完美了吗，就没有问题了吗？显然不是的。</p>
<h2>ES2017：使用async/await语法关键字</h2>
<p>过多的“紧随”风格的then方法调用及catch方法调用，让代码的前后逻辑不清晰；当我们阅读这样的代码时，并不是从上向下瀑布式阅读的，而是时而上、时而下跳动着阅读的，这很不舒服。不仅阅读时不舒服，编写时也很难以用一种像后端编程那样的从上向下的简洁的逻辑组织代码。</p>
<p>下面开始开始使用ES2017标准中提供async/await语法关键字，对示例三进行改写：</p>
<pre><code class="language-js">function foo() {
  return new Promise(function(resolve, reject) {
    fs.readFile(&quot;path/to/file&quot;, function(err, response) {
        resolve(response)
    })
  })
}
(async function(){
  const res = await foo().catch(console.log)
  console.log(res)
})()
</code></pre>
<p>基于async/await语法关键字的方案，是使用Promise的方案的升级版，在这个方案中也使用了Promise。第8行~第11行，这是一个IIFE（立即调用函数表达式），之所以要用一个只使用一次的临时匿名函数将第9行~第10行的代码包裹起来，是因为await必须用在一个被async关键字修饰的函数或方法中，只能直接用到顶层的文件作用域或模块作用域下。</p>
<p>使用这种方案的优化是，代码可以像后端编程那样从上向下写，结构可以很清晰。这也是一种被称为“异步转同步”的JS编程范式，在前端开发中已被普遍接受。</p>
<p>注意，“异步转同步”并没有真正改变异步代码，异步代码仍然是异步代码，它们仍然会在异步线程中先默默地执行，等有数据返回了再通知主线程处理。当我们使用这种编程模式的时候，一定不要在主线程上去await一个Promise，可以发起异步操作，让异步操作像葡萄一样挂在主线程上，但不能等待它们返回了再往下执行。</p>
<h2>jQuery的Deferred Object（延迟对象）</h2>
<p>先看一段Promise+then方法风格的jQuery代码：</p>
<pre><code class="language-js">$.ajax({
  url: &quot;test.html&quot;,
  context: document.body
}).done(function() {
  $(this).addClass(&quot;done&quot;)
})
</code></pre>
<p>第4行，这里的done方法是jQuery自行实现的，$.ajax方法返回的是一个DeferredObject（延迟对象），这个对象上有done方法，这个方法与Promise的then类似。</p>
<p>jQuery成名在前，在ES2015标准诞生之前，jQuery的DeferredObject就已经被定义了。Promise本身并没有神奇的地方，它可以发挥作用，主要依赖的是在JS中，Object是引用对象，继承于Object原型的Promise也是引用对象，当异步操作发起时，只有一个“空”的Promise被创建了，但是它的引用被保持了；当数据回来的时候，数据再被“装填”进这个对象，这样通过先前持有的引用，异步代码便可以访问到对象上携带的数据。</p>
<p>Promise的胜利，更多是编程思想上的胜利，Promise的成功，也是编程思想上的成功。**所有一种语言中编程思想上的成功，在其他语言中都可以被学习和借鉴。**事实上在后端编程中，这种伪装成同步代码风格的异步编程思想也极其普遍，它们拥有一个共同的名字，叫协程。</p>
<h2>小结</h2>
<p>在JS中处理异步调用的结果，最佳实践就是“异步转同步”：使用Promise + async/await语法关键字。在这里async总是与await成对出现，一个async函数总是返回一个Promise，一个await关键字总是在尝试“解开”一个Promise，结局要么等到有价值的数据，要么异步出现异步，什么也没有等到。为了避免出现异常，影响主线程的正常运行，一般要用catch规避异常。</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[32《断刀客》观后感]]></title>
            <link>https://yishulun.com/./src/posts/2022/32.html</link>
            <guid>https://yishulun.com/./src/posts/2022/32.html</guid>
            <pubDate>Sat, 24 Dec 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>32《断刀客》观后感</h1>
<p><img src="./assets/FF91DD70-E329-4185-B6D9-BD85146AFF2C.jpeg" alt="断刀客"></p>
<p>徐克导演的《断刀客》这部老电影拍得很好，人物设计得也很出彩。情节如果看未删节版本，也会感到非常的热血。</p>
<p>主角是定安，故事主线是定安长大后为父报仇的事，高潮也是主角为父报仇。</p>
<p>影中写的爱情是这样的：</p>
<ul>
<li>（1）有师父的女儿小灵对定安、铁头的虚荣之爱，她喜欢看她喜欢的男人为她争风吃醋，为她拼命斗个你死我活，结果却孤独终老，她的结局处理得很好。</li>
<li>（2）有黑头姑娘对定安的相爱相骂之恋，当定安意外发现刀谱，决定练功准备反抗时，黑头骂他白痴、没用、徒劳，是她救了掉落悬崖的定安，她是受定安的，因为爱，担心他的安然，所以才骂。</li>
<li>（3）有定安、铁头对风尘女的欲望之爱。但两人对这份欲望的处理不同，铁头因为欲望争风吃醋，让自己和风尘女陷入危机当中；定安救了风尘女，然后把她交给铁头，然后和黑头姑娘走了。最后，当定安成功杀了飞哥报仇雪恨后，他也带着黑头姑娘走了，她并没有留下来和小灵相好，小灵对于他已经成为了过去式。</li>
</ul>
<p>这部电影对人物角色的处理，也很有特点，例如：</p>
<ul>
<li>配角铁头性格是侠义，但鲁莽，两次都是因为他的鲁莽推动了剧情前进。</li>
<li>而主角定安是真侠义，善良，隐忍，能成事。</li>
</ul>
<p>总之这是一部非常值得一观的电影，不过建议看未删节版本，那个更精彩，更有热血感，更能体会什么叫情绪有点上头、顶起来的感觉。</p>
<p>当情绪渲染到那里的时候，读者在心里喊：主角，赶快逆袭，干掉那些人渣。这时候你会发现主角的金手指再不可思议，在神佛逻辑下，也都是合理的了。情绪顶到不得不发的地方，主角已经退无可退了，观众也退无可退了，摆在主角面前的只剩下一条路：崛起、逆袭。</p>
<p>下面是《斷刀客 / 断刀客 1995》未删节版本的链接：</p>
<blockquote>
<p><a href="https://www.youtube.com/watch?v=NvBdxpiTM8o">https://www.youtube.com/watch?v=NvBdxpiTM8o</a></p>
</blockquote>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
            <category>undefined</category>
        </item>
        <item>
            <title><![CDATA[解决Gibhub git push超时、无法提交的问题]]></title>
            <link>https://yishulun.com/./src/posts/2022/30.html</link>
            <guid>https://yishulun.com/./src/posts/2022/30.html</guid>
            <pubDate>Thu, 22 Dec 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>解决Gibhub git push超时、无法提交的问题</h1>
<p>最近<code>git push</code>指令又不能工作了，马上测了一下IP，发现github.global.ssl.fastly.net这个域名，除了台湾宝岛那里，基本都不能访问。（注：测试地址<a href="https://ping.chinaz.com/github.global.ssl.fastly.net%EF%BC%89">https://ping.chinaz.com/github.global.ssl.fastly.net）</a></p>
<p><img src="./assets/image-20221222105336458.png" alt="image-20221222105336458"></p>
<p>这个测试仅是一家云商服务器的结果，可能换一家云商，结果就不一样了，数据仅供参考。</p>
<p>那么解决Github仓库不能送拉的问题呢？</p>
<p>使用这个网址工具（<a href="https://ping.chinaz.com/%EF%BC%89%E4%BE%9D%E6%AC%A1%E6%B5%8B%E8%AF%95%E4%B8%8B%E9%9D%A2%E4%B8%89%E4%B8%AA%E5%9F%9F%E5%90%8D%E7%9A%84%E5%8F%AF%E7%94%A8IP%EF%BC%9A">https://ping.chinaz.com/）依次测试下面三个域名的可用IP：</a></p>
<ul>
<li><a href="http://github.com">github.com</a></li>
<li><a href="http://github.global.ssl.fastly.net">github.global.ssl.fastly.net</a></li>
<li><a href="http://assets-cdn.github.com">assets-cdn.github.com</a></li>
</ul>
<p>得用可用IP后，修改hosts文件（例如macOS的<code>/etc/hosts</code>），强制相关域名使用指定IP：</p>
<pre><code class="language-bash">39.102.194.95 github.com
151.101.1.194 github.global.ssl.fastly.net
185.199.108.153 assets-cdn.github.com
</code></pre>
<p>完成修改后，需要重启本机网络，指令重启方法因系统因异：</p>
<ul>
<li>macOS系统：<code>sudo ifconfig en0 down &amp;&amp; sudo ifconfig en0 up</code></li>
<li>Windows系统：<code>ipconfig /flushdns</code></li>
<li>Linux系统：<code>/etc/init.d/networking restart</code></li>
</ul>
<p>如果不使用指令，用鼠标点击Wifi或本地网络，手动关闭、重连也可以达到同样的效果。重启后，git指令基本就可以工作了。</p>
<p>但是问题到这里还没有结束。</p>
<h2>指令执行时都访问了哪些域名？</h2>
<p><code>git push</code>指令执行时，都在背后访问了哪些域名？我们怎么知道一个指令的成功执行，到底需要能够访问哪些域名地址呢？</p>
<p>这与具体指令要做的事情有关，在进行git操作时，github.com域名是必连的，github.global.ssl.fastly.net域名是为了处理ssl安全连接的，而assets-cdn.github.com域名是cdn加速域名，在github提交中暂时用不到。</p>
<p>除了分析指令本身的功能或源码之外，还可以在本地使用网络监测工具。例如netstat指令：</p>
<pre><code>$ netstat -a | grep &quot;github&quot;
tcp4       0      0  192.168.31.224.50744   github.com.ssh         SYN_SENT   
</code></pre>
<h2>有没有防墙提交工具？</h2>
<p>有没有一个自动防墙提交的工具呢？这个工具最好可以封装成一个指令，例如github_safe_push。github自有的CLI工具指令gh并不能担负这个职责。</p>
<p>在网络上搜索了一下，暂时没有找到具有这样功能的工具。从理念上讲，这样的工具应该是可以实现的，使用Python代码先查询可用域名，继而进行网络设置，最后调用原生的git push指令提交代码。</p>
<h2>使用国内CSDN的缓存服务</h2>
<p>2022-12-24更新：</p>
<p>CSDN为国内程序员提供了一项Github缓存、加速服务</p>
<blockquote>
<p>GitHub 缓存服务是 CSDN 为开发者提供的一项代码仓库加速服务。</p>
</blockquote>
<p>如果感兴趣，可以从这里了解：<a href="https://gitcode.net/gitcode/help-docs/-/wikis/docs/user/project/repo/repo-mirror">https://gitcode.net/gitcode/help-docs/-/wikis/docs/user/project/repo/repo-mirror</a></p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[只有一个程序员开发和运营，BuiltWith网站年入1400万美元是怎么做到的？]]></title>
            <link>https://yishulun.com/./src/posts/2022/31.html</link>
            <guid>https://yishulun.com/./src/posts/2022/31.html</guid>
            <pubDate>Thu, 22 Dec 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>只有一个程序员开发和运营，BuiltWith网站年入1400万美元是怎么做到的？</h1>
<p><img src="./assets/builtwith.png" alt="Gary Brewer和他的BuiltWith公司"></p>
<p>国外有一位程序员叫 Gary Brewer，他一人撑起了一个公司，这个公司还年入 1400 万美元，约人民币 1 亿元。</p>
<p>对此，你是啥想法？先别着急说不可能，这事儿确实是真的：这名程序员名为 Gary Brewer，他创建的 BuiltWith 背后没有销售团队，没有服务团队，也没有工程师。</p>
<p>啥都没有，这公司做什么能年入 1400 万美元？这又是一家什么公司？它的商业模式是什么？</p>
<h2>逆向思维，建立企业技术信息数据库</h2>
<p>“BuiltWith” 顾名思义，是一个揭秘网站搭建技术的网站。</p>
<p>“如果能知道每个网站使用的确切技术岂不是很棒？”</p>
<p>最初 Gary Brewer 其实无心创业的，直至 2006 年他参加了一场在悉尼举行的创业会议，会后他收获了一个很重要的心得：</p>
<blockquote>
<p>每个人都可以创业。</p>
</blockquote>
<p>但他个人并不喜欢管理企业琐事和推销行为。在接下来的几个月里，Gary Brewer 除全职工作之外，业余时间还尝试开发了多个工具和产品，虽然最后都以失败告终，但他很享受创建每一个产品的过程和经验。</p>
<p>当 Gary Brewer 上网寻找下一个产品的定位时，他突然在浏览某网站源代码时灵光一闪：</p>
<blockquote>
<p>源码里有一段 Java 特有的代码，可以推断出该网站是用 Java 建立的……<br>
欸，如果能知道每个网站使用的确切技术岂不是很棒？</p>
</blockquote>
<p>对此十分感兴趣的 Gary Brewer，行动力也很强。他火速注册了 BuiltWith 这个域名，并开始搭建 Scraper 及其技术数据库，将某些代码段映射到对应技术上。例如，某些代码段可用于识别网站是否使用了 Adsense 与 Adzerk 或其他广告方法。</p>
<p>不久后，BuiltWith 正式发布，并立即涌进了大量流量。Gary Brewer 还为 BuiltWith 的发布联系了一家出版社 ReadWriteWeb 写了一篇独家稿件，并一举在当时主流社交分享网站 Digg 上获得了第一名。</p>
<h2>与AboutUs合作开始飞起</h2>
<p>不过，对 BuiltWith 来说最重要的转折点在于 Gary Brewer 和 AboutUs 创始人 Raymond King 的会面。AboutUs 是一个包含数百万企业信息的互联网域名目录。</p>
<p>在 Gary Brewer 向 Raymond King 展示了 BuiltWith 的功能后，Raymond King 便立即同意在 AboutUs 索引中的每条记录都添加一个 <a href="http://BuiltWith.com">BuiltWith.com</a> 链接，以提供每个网站所使用的确切技术作为参考。</p>
<p>结果可想而知，AboutUs 包含数百万个企业信息，其每条索引都能链接到 <a href="http://BuiltWith.com">BuiltWith.com</a>——BuiltWith 的流量呈爆炸式增长，SEO 排名也迅速上升。</p>
<p>说到这里，可能很多人都觉得，这 BuiltWith 不就只能分析网站背后使用的技术，它为什么能年入 1400 万美元？主要原因在于：企业可以从中获得竞争优势——能通过 BuiltWith 了解更多对手信息，挖掘更多客户，赚到更多的钱。</p>
<p>BuiltWith 有两个版本，免费版本和付费版本：</p>
<ul>
<li>免费版本：你可以通过 BuiltWith 了解你的竞争对手在使用什么技术。</li>
<li>付费版本：你可以用特定的关键词和技术找到每一个符合条件的网站，甚至可以按地点、消费和社会关注度对它们进行细分——这无疑是一个收集潜在客户的完美场所。</li>
</ul>
<p>举个例子：如果你有一个更好、更简单、更现代的 WordPress 版本，你就可以用 BuiltWith 搜索 WordPress，找到每一个使用 WordPress 的网站，向他们推荐你的产品，把他们转化为你的客户。</p>
<p>简单概括来说，因为 BuiltWith 几乎已经成为一个互联网背后的巨大技术数据库，很多企业把它等同于一个能产生潜在客户并快速跟踪构建功能的数据库，因此 BuiltWith 超过 50% 的流量都来自直接访问。</p>
<p>这个网站有很多付费用户。所以以下信息慢慢成了为事实：</p>
<ul>
<li>没有运营员工；</li>
<li>年营收 1400 万美元；</li>
<li>每月 200 万的页面浏览量，其中直接访问占 57% ，36% 来自搜索引擎，没有付费关键词广告；</li>
<li>BuiltWith 的运营，Gary Brewer一人足矣。</li>
</ul>
<p>由于 BuiltWith 功能的特点，实际上企业在进入 <a href="http://BuiltWith.com">BuiltWith.com</a> 前，是否要为其付费就已经是一件既定的事情了，无需多加推销：要么有目的性地成为高级付费用户，挖掘更多潜在客户；要么就坚决“白嫖”，只需知道竞争对手在用什么技术即可。</p>
<p>甚至因为 BuiltWith 的使用方法简单，Gary Brewer 都不需要向客户解释什么，简单制作一个 20 秒的视频教程作为参考就够了——换句话说，BuiltWith 的运营已经完全自动化，并不需要工程师等员工来推送功能或添加资源等。</p>
<p>事实上在 2010 年左右，当时 BuiltWith 除了 Gary Brewer 还有一个联合创始人 Andrew Rogers。但后来 Andrew Rogers 意识到 BuiltWith 根本不需要多余的跟踪或推销手段，便离开了 BuiltWith，只在公司继续担任顾问一职。因此整体而言，如今年收入 1400 万美元的 BuiltWith，完全由 Gary Brewer 一人运营。</p>
<p>对于 Gary Brewer 的成功，程序员们纷纷投来了羡慕的目光。</p>
<h2>启示</h2>
<p>BuiltWith的成功至少在以下方面给了我们启发：</p>
<ul>
<li>收费是因为向用户提供了用户更需要的使用价值。即使是免费版本的功能，BuiltWith也向用户提供了独特的使用价值，付费版本是免费版本的超集。</li>
<li>好的护城河都是靠时间累积而成的。BuiltWith网站的优势是靠时间的复利建立起来的，一个人一家公司分析一个网站用了什么技术这不难，但是查询海量公司哪些用了Java、哪些用了Go，却不是一下子就能找出来的。BuiltWith建立了这样的数据库，这是它靠时间累积的优势。</li>
<li>借势而为，要懂得与其它团队进行商业利益上的契合。BuiltWith拥有实在的使用价值固然重要，但与AboutUs合作，才让它真正飞起。</li>
</ul>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[使用面向过程和面向对象结合的思想开发软件]]></title>
            <link>https://yishulun.com/./src/posts/2022/1016.html</link>
            <guid>https://yishulun.com/./src/posts/2022/1016.html</guid>
            <pubDate>Sun, 16 Oct 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>使用面向过程和面向对象结合的思想开发软件</h1>
<p>两者结合起来，开发更有保障。</p>
<p><strong>什么是面向过程开发？</strong></p>
<p>面向过程开发也称结构化开发，将软件要实现的功能分解成一个个连续的流程结点，将每个节点都实现为一个函数，依次调用这些函数以完成软件功能。至于执行流程中多个函数共用的数据，则拿出来定义为共享的数据结构，实例化，在函数中使用和传递。</p>
<p><strong>什么是面向对象开发？</strong></p>
<p>面向对象开发主要指模拟人类的思维方式，将软件需求中的事物关系，通过封装、继承、多态等手法抽象为一个个具体的对象（类），在对象中包含数据和操作数据的方法，以此方式实现软件需求。对象与对象之间的通讯，主要以发送信息的方式进行。</p>
<p><strong>面向过程开发有什么缺点，为什么会产生面向对象的开发思想？</strong></p>
<p>面向过程开发很适合处理不包含多层数据结构的流式信息处理、生产流程控制等扁平式产品需求，对于内部关系复杂的软件需求，这种开发方式将捉襟见肘。举个例子，像那种定制 CSS 样式的参数设置界面，使用面向过程的思想便不易设计。20 世纪 80 年代，在图形化桌面系统诞生以后，图形化桌面软件也开始蓬勃发展，你很难想象，对于像 Excel 这样的复杂软件，如果基于面向过程的方式该如何开发。这个时候，日益复杂的软件需求，在计算机性能不断提高的时候，却被软件的开发方式束缚了，这便是计算机世界的第二次软件危机。</p>
<p>《人月神话》一书中描述了这样一个有关软件危机的案例：</p>
<p>在IBM 公司开发 OS/360 系统的时候，投入成本达到了美国曼哈顿原子弹计划的 25%，耗资达数亿美元。系统约有 4000 多个模块，100 万条指令，使用人力超过 5000 人年。即使如此，项目还是延期交付了，并且交付以后系统中仍有大量缺陷。就可以太复杂了。</p>
<p>随着第二次软件危机的爆发，面向对象编程逐步取代了面向过程的结构化编程。以最符合人类思维的视角抽象问题，相比以最符合机器运行特征的算法与数据结构抽象问题，前者成为了软件设计准则的第一优先级，从此面向对象的开发思想开始占据主导地位，并风靡至今。</p>
<p><strong>将面向过程与面向对象结合起来的开发思想</strong></p>
<p>虽然面向对象是后来产生的，并且解决了面向过程开发复杂软件面临的困难，但是这不是说，面向对象就没有缺点，面向过程就没有优点。</p>
<p>先看面向对象的缺点。具象的事物很好抽象，虚拟的事物一般难以定义，这种困难多半来源于客观事物对象的边界模糊而造成的。在分析需求并划分对象时，还存在观察客观事物角度的不同而产生的差异，以及因对象划分粒度不同而产生的差异，这些差异不仅会给团队协作开发带来难度，在后续的软件维护中，也存在阅读与理解上的困难。</p>
<p>再看面向过程的优点。面向过程开发，由于是针对事务流程而设计的，天生不存在角度、抽象层次及划分粒度的烦恼。线性的思考和处理问题方式，至今为很多程序员所喜欢，特别是数学出身的程序员。有些程序员甚至用面向对象的语言，写面向过程的代码。</p>
<p>下面我们开始步入正题，阐述两种开发思想结合起来的开发方式：</p>
<ul>
<li>第一步，系统分析。用结构化思想进行系统分析，厘清软件需求中所有的事务流程，产出<strong>数据流图</strong>。</li>
<li>第二步，系统设计。仍然用结构化思想，依据数据流图，划分软件模块，产出<strong>系统结构图</strong>。在这个阶段，对于软件中可能存在的关键难点，可以拆出小需求来，用面向过程的方法迅速进行技术方案验证。如果预想的技术方案实现不了，则直接会影响系统机构图的产出。</li>
<li>第三步，面向对象软件架构与设计。在第二步的基础上，依照系统结构图，进行面向对象的软件设计，在这一步，才开始真正的面向对象开发，是开始编写代码的阶段了。</li>
<li>第四步，面向对象的编程实现。</li>
<li>第五步，测试部署与维护升级。</li>
</ul>
<p><strong>两者结合开发的一个小示例</strong></p>
<p>下面看一个小示例，软件需求是这样的：输入一串数字，使用 AES 或 RSA 算法加密，然后输出加密结果。</p>
<p>第一步系统分析，产出数据流图。</p>
<p><img src="./assets/image-20221016214506449.png" alt="image-20221016214506449"></p>
<p>第二步系统设计，产出系统结构图。在这一步里，确定了模块划分，其中输入、输出和选择加密方式这三个都是 UI 模块，RSA 和 AES 是算法模块。</p>
<p><img src="./assets/image-20221016214813037.png" alt="image-20221016214813037"></p>
<p>第三步是面向对象的架构与设计，这一步要落实在项目与具体的代码上了。第四步与第五步不再赘述。</p>
<p>通过这种结合的软件开发方式，可以最大化发挥面向对象和面向过程开发思想的优点。前两步都是结构化面向过程的分析与设计，如果系统足够复杂，对这些前期工作都可以将需求拆开来，分给不同的开发者去调研。只有到了第三步，所有东西都已经确定了，这个时候才可以制定和施行严格的项目开发计划。</p>
<p>还有，经过了第二步以后，第三步在进行架构设计时，也能产出更好的系统设计。而如果没有第二步，什么都不清楚呢，直接进入第三步，则可能有重新调整架构、返工、延时等项目风险出现。</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
            <category>undefined</category>
        </item>
        <item>
            <title><![CDATA[通过编写反派配角剧情推动主线剧情向前发展]]></title>
            <link>https://yishulun.com/./src/posts/2022/1015.html</link>
            <guid>https://yishulun.com/./src/posts/2022/1015.html</guid>
            <pubDate>Sat, 15 Oct 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>通过编写反派配角剧情推动主线剧情向前发展</h1>
<p>这是关于故事前期设计的一点小感悟，将人物放在矛盾的关系链条上，让剧中角色相互间具有矛盾的人物标签，故事自然就容易向前推进。</p>
<p>在《相亲当天》中，初期，战奶奶希望海彤与战胤好一辈子。战胤坚持要防着海彤是只为圈钱的「心机女」，海彤对此则是独立自主随缘无所谓，这时候战胤与海彤两人是对立的，如果不是有战奶奶存在，两人的感情很难升温，故事也很难继续讲下去。</p>
<p>在《射雕英雄传》中，金庸也安排了很多对立的矛盾关系。郭靖与杨康性格对立，成长环境对立。东邪西毒对立，北丐南帝独立。金轮法王与中原武林对立。大宋与金国、蒙古对立。在大宋与蒙古对立的时候，作者还巧妙故意安排了郭靖是蒙古国的金刀驸马，这个角色属性的设定，给郭靖和黄蓉的感情线发展制造了很多精彩剧情。众多的对立关系，保证了故事演绎出很多有冲突的情节。什么时候剧情不好发展了，作者只需要让坏人出来作妖就可以了。</p>
<p>郭靖与黄蓉感情线的发展，在后期基本圆满的时候，先是让欧阳克出来向黄岛主提亲，后来又杀死江南七怪其中的几位，嫁祸于郭靖，这一招一下就让郭靖与黄蓉的感情陷入了危机。还有几次，两人感情甚好的时候，突然华筝就从大漠来中原了。华筝的出现，总是能给两人的感情带来小风波。金庸先生仿佛非常擅长通过写反派配角，推进主线剧情的发展。</p>
<p>有道友讲，这是金庸的下意识，他没想那么多，就是写着写着，还不想结束，当主线没有什么可以写的时候，就在再搞点支线情节搞一搞剧中主角。</p>
<p>可能是这样的，或许金庸在写作的时候，不像古龙写的是强悬疑，没有很刻意的前期设计在里面。但基本的前期故事梗概设计应该是有的，这个设计就是人物角色中的矛盾标签，以及地图的预期安排，例如《射雕》中的牛家村、蒙古大漠、大宋地图等。</p>
<p>是不是感觉剧中主角很可伶，像作者的提线木偶，作者想让他们干什么，他们就必须干什么。这可能也是写作的趣味所在。</p>
<p>下面聊一下写长篇网文与编程范式的关系。</p>
<p>在编程中，面向过程与面向对象的区别是，前者是在分析需求后，先定义好数据和一系列函数，依次线性地调用这些函数以完成需求；后者则是在分析后，先定义一系列对象，在对象中集成属性（数据）和方法，然后开始调用一个对象的方法，这个对象的方法又会自动调用另一个对象的方法，就这样一直调用下去，直到最后把需求完成。</p>
<p>写短篇小说就像使用面向过程的方法开发软件，而写长篇小说，尤其写长篇网文小说，就像以面向对象的编程范式在开发软件。在长篇写作中，先定义好一个个有矛盾关系的势力、团队和个体，然后找到一个切入点，开始启动，这个动作就相当于面向对象开发中对第一个对象方法的调用，整部作品一旦启动，故事便可能会一直发展下去，直到结束。这是一种理想情况，这种方法说起来简单，真要做起来尚不知有什么困难。</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
            <category>undefined</category>
        </item>
        <item>
            <title><![CDATA[由鸭子测试看Go语言的接口实现]]></title>
            <link>https://yishulun.com/./src/posts/2022/1014.html</link>
            <guid>https://yishulun.com/./src/posts/2022/1014.html</guid>
            <pubDate>Fri, 14 Oct 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>由鸭子测试看Go语言的接口实现</h1>
<p>「If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck.」</p>
<p>中文：「如果一只鸟它走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。」</p>
<p>这便是「鸭子测试」，它是一种判定思想。这句话据记载来源于美国的一个诗人，叫詹姆斯·惠特科姆·莱利，他曾说过或写过这样一句话：</p>
<p>「When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck.」</p>
<p>中文：「当我看到一只鸟像鸭子一样走路，像鸭子一样游泳，像鸭子一样呱呱叫，我就叫它鸭子。」</p>
<p>无法确定莱利写这句诗的具体时间，不过绝不会晚于 1916 年，因为这一年莱利人去世了。在 1916 年，计算机都还没有诞生。关于「鸭子测试」的思想，最先并不是应用在计算机领域，而是政治领域。1946 年，也就是 ENIAC 计算机诞生的那一年，美国有个工会领导在一个公开集会中这样指责一个共产主义者：</p>
<p>「我无法证明你是共产主义者。但当我看见一只鸟叫得像鸭子，游得像鸭子，也走得像鸭子，长着羽毛也有脚蹼，还和鸭子在一起，那我当然会判断它是个鸭子。」</p>
<p>这句话很讽刺，且无理。</p>
<p>历史上也曾有记者用「鸭子测试」的逻辑，去指责另一个人的独裁行为：</p>
<p>「我无法证明你是一位独裁者。但当我看见一个人他说话像独裁者，行动像独裁者，还身处独裁者的机构和组织之中，和独裁者在一起，那我当然会认为他就是一名独裁者。」</p>
<p>「鸭子测试」的思想之所以在多个领域被人们乐于运用，在于它是一种归纳思想。它不严谨，但却能普遍被人们在有限范围内接受。后来计算机诞生以后，这个判定思想又被应用于编程之中，并派生出一种「鸭子类型（duck typing）」。所谓鸭子类型，顾名思义就是可以应用鸭子测试判定或与之有关的类型。</p>
<p>如果你还没有理解这种编程中的「鸭子类型」，我在这里尝试翻译一下：</p>
<p>假设类型 I 有 A、B、C 三个方法。如果对象 O 既实现了方法 A，也实现了方法 B，又实现了方法 C，那么我们便可以认为对象 O 就是 I 类型。</p>
<p>鸭子类型有时候在动态语言中，被用于实现多态。下面看一个多态的例子，它是Python语言的。</p>
<pre><code class="language-py">class ClassA:
    def print(self):
        print(“10 x in class a.”)

class ClassB:
    def print(self):
        print(“in class b.”)

def printIt(instance):
    instance.print()

def demo():
    instance = ClassA()
    printIt(instance)
    instance = ClassB()
    printIt(instance)
</code></pre>
<p>作为同一个变量 instance，当我们准备调用它的 print 方法的时候，它既可以是 ClassA，也可以是 ClassB。在实例方法 print 被调用的时候，两个类型完全可以有不同的表现。在这个类型中，我们可以认为 ClassA 和 ClassB 是一对鸭子类型。</p>
<p>动态语言的这种「鸭子类型」方便性，既是它的优点，也是它的缺点。它可以让程序员不必费力地像 Java 那样先定义接口然后再实现接口，可以直接调用，只要方法存在。缺点也很明显，如果代码有问题，例如调用了没有定义的方法，异常只有在运行时才会爆发出来。静态类型的编译型语言就没有这个缺陷，变量都有严格的类型，类型上有什么方法，没有什么方法，在编译的时候就能提前确定并暴露给开发者，这是静态语言的优点。</p>
<p>Go 语言作为高级编程语言的后起之秀，它兼具了静态语言和动态语言在类型设计上的优点，它既让开发者没有类型声明之累，又可以在编译阶段就确定类型错误。在这一点上，Go 语言是怎么做到了呢？</p>
<p>就是依靠「鸭子测试」的判定思想，下面看一个 Go 语言实现接口的例子。</p>
<pre><code class="language-go">type IGreeting interface {
	say()
}
type Duck struct {}
func (d Duck) say() {
	fmt.Println(&quot;Hi，LIYI。&quot;)
}
// 测试
func sayIt(speaker IGreeting) {
	speaker.say()
}
func main() {
	speaker := Duck{}
	sayIt(speaker)
}
</code></pre>
<p>解释一下这个代码示例：</p>
<ul>
<li>第 4 行 Duck 是一个结构体，Go 语言的结构体相当于 Java 的 class。</li>
<li>第 1 行的 IGreeting 是一个接口，从表面上看，没有任何类型与它有关系。其实不然，第 5 行，因为我们在 Duck 类型上实现了 say 方法——即接口 IGreeting 的唯一成员，所以 Duck 类型就被认为实现了接口 IGreeting。</li>
<li>第 9 行，函数 sayIt 需要一个 IGreeting 类型的参数，在第 14 行，我们可以把 speaker 传递给 sayIt，因为 Duck 类型已经实现了接口 IGreeting。</li>
</ul>
<p>Go 语言关于接口的实现，就是一种「鸭子测试」的判定，只要一个结构体实现了某个接口的所有方法，就认为该结构体实现了该接口。这种做法简直太方便了！</p>
<p>我 10 年前第一次在公司项目中使用这种语言，用了一次就爱不释手了，那时候我就想，不出十年，Go 语言就会被大多数程序员接受。果然，今天 Go 语言已经被称为互联网时代的 C 语言，在腾讯内部提交的代码中，据统计 Go 语言已经超过 C++ 成为第一热门语言。国内外有越来越多的程序员，还有公司，无论大厂小厂，都选择学习并在生产环境中应用了 Go 语言。</p>
<p>最后，留一个问题给你：玩具大黄鸭经过「鸭子测试」的判定，被当成了鸭子，但其实它不是鸭子，如果有一天有人要给它喂食，还要它下蛋，怎么办？在 Go 语言中，还以本文中的示例为例，假设未来某一天接口 IGreeting 因为需求扩展添加了一位新成员 walk，但是 Duck 没有实现 walk 啊，这时候编译软件肯定会报错啊。如果项目中像 Duck 一样的结构体少还好办，如果很多且分散于项目各处，这种情况应当怎么办呢？</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
            <category>undefined</category>
        </item>
        <item>
            <title><![CDATA[JavaScript到底是不是面向对象语言？]]></title>
            <link>https://yishulun.com/./src/posts/2022/1013.html</link>
            <guid>https://yishulun.com/./src/posts/2022/1013.html</guid>
            <pubDate>Thu, 13 Oct 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>JavaScript到底是不是面向对象语言？</h1>
<p>当然是。</p>
<p>为了讲清楚这个问题，我们需要先看一看「什么是面向对象编程」和「什么是面向对象语言」。</p>
<p>什么是面向对象编程？使用面向对象语言进行的编程就是面向对象编程。</p>
<p>什么是面向对象语言？在面向对象编程中使用的编程语言就是编程语言。</p>
<p>好吧，是不是感觉我说了两句废话，确实，编程语言可以自举，但是概念不可以。在讨论面向对象语言的时候，一般要界定这门语言的三个面向对象特征：封装、继承和多态。凡具有这三个特征，就是面向对象语言；不具有，就不是。</p>
<p>也有人讲过，面向对象特征有四个：封装、抽象、继承和多态，比一般的说法多了一个抽象。其实抽象不能算是面向对象的基本特征，因为在面向过程编程中，也有抽象；本质上编程就是抽象，就是将现实世界中一个或几个层面的东西剥离出来，用编程语言表达出来及进行交互控制。</p>
<p>进一步考察面向对象语言的三个基本特征，我们可以从语言的具体功能上重新阐述它们，这实际上还有助于我们记忆，否则，这三个特征名字你未必记得牢固。</p>
<p>先看封装。什么是封装功能？就是把属性、方法封装在一个类（class）中。你想一想，在你接触的编程语言中，C#、C++、Java 等，它们是不是允许我们这么干？</p>
<p>再看继承。什么继承功能？先定义（封装）了一个类 A，接着又定义了一个类 B，让 B 继承于 A，这样 A 的属性和方法（公开的）B 也有了（继承了）。</p>
<p>最后看一下多态。什么是多态？这是使用时的一个特征，与接口或虚类有关。先声明一个接口 I，然后让类 A 实现它，让类 B 也实现它。一个类型为 I 的变量，当它是类 A 的实例时，它具有类 A 的特性和行为特征，当它是类 B 的实例时，它又开始具有类 B 的特性和行为特征，这就是多态，仿佛有多个状态。</p>
<p>所以说，封装、继承和多态，这三个特征它们分别对应于语言中类的定义、类的继承和接口的定义和使用——这三个方面的能力，都有具体的功能含义。反观抽象，它明确对应于语言中的那个能力呢？没有，所以抽象并不能算是面向对象语言的一个基本特征。</p>
<p>最后，回头来看问题，JavaScript 是不是面向对象语言？那就看它具不具备三个面向对象的基本特征吧。</p>
<p>首先封装，JS 有 class，还有美元符号（$）开头的私有属性，可以。然后是继承，ES6 有 extends，没问题。即使在 ES6 之前，也可以在一个对象上定义属性和方法，可以使用原型（prototype）实现对象之间的继承，对封装和继承的支持也没有问题。最后多态，也没有问题。虽然 JS 没有接口（它目前仅是保留了 interface 作为语言关键字），但是它的 Object 类型几乎是万能的，相当于是任何一个对象的接口，实现多态也完全不是问题。</p>
<p>使用 extends 关键字可以实现继承，使用原型也可以实现继承，它们只是实现方法不同，对应的面向对象的内在继承思想却是一致的。</p>
<p>最后，留给你两个思考题：</p>
<ul>
<li>Go 语言算是面向对象语言吗？</li>
<li>面向对象语言为什么会出现？</li>
</ul>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
            <category>undefined</category>
        </item>
        <item>
            <title><![CDATA[目前国内前端哪个UI类库用的人最多？]]></title>
            <link>https://yishulun.com/./src/posts/2022/1012.html</link>
            <guid>https://yishulun.com/./src/posts/2022/1012.html</guid>
            <pubDate>Wed, 12 Oct 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>目前国内前端哪个UI类库用的人最多？</h1>
<p>如果基于 jQuery 开发多页面响应式 Web 应用，可以使用 <a href="https://v5.bootcss.com/">Bootstrap</a>。</p>
<p>如果基于 Vue3 开发单页面 Web 应用，可以使用 <a href="https://www.antdv.com/docs/vue/migration-v3-cn">Ant Design Vue 3</a>。在基于 uni-app 开发多端应用时，在 uni-app 中也可以引用 Ant Design Vue。</p>
<p>如果同时开发以上两种多页面应用和单页面应用，为了减少智力负担和学习成本，可以使用 Bootstrap 和 <a href="https://www.npmjs.com/package/bootstrap-vue-3">Bootstrap-vue-3</a>。</p>
<p>在开发管理后台 Web 应用的时候，另外一种选择是 Element Plus，但有开发者说这个开源类库现在维护力度变弱了，有一些坑，PR 提了半年无人响应，已经不建议使用。官方文档已经从独立域名切换到了 Github 免费域名，打开网站在页面导航切换的时候，时时发生 404 错误，这种问题都无人处理，种种迹象表明这个曾经被作为后台 Web 样式类库第一选择的项目，现在已经开始摆烂了。</p>
<p>其实，开发 Web 应用目前统一使用 Ant Design Vue 3 就可以了。无论开始是开发面向 C 端用户的 Web 应用，还是开发 B 端或运营团队使用后台管理 Web 应用，都可以选择 Ant Design。Ant Design 支持 CSS 样式定制，在编写后台应用或企业 Web 应用时，大不了把 UI 风格修改成蓝色系就 OK 了。</p>
<p><img src="./assets/zTFoszBtDODhXfLAazfSpYbSLSEeytoG.png" alt="img"></p>
<p>另外还有一个 Material 样式风格的开源类库 Vuetify，打开它的官方文档，每一页都有一个广告。我并不反对放置广告，但每一页都放，这种放的方式说明操作者很不用心，可能这个项目在开发者那里已经不重要了，也已经开始放养了。</p>
<p><strong>我们应该选择什么样的类库呢？</strong></p>
<p>1）选择那些在功能、性能上没有短板的类库，可以满足我们需求的类库。</p>
<p>2）我们要选择背后有大厂使用和支持的类库，这样的类库更有可能走得更远，发展得更完善。</p>
<p>开源项目不存在开发完善、已经大功告成一说。所有开源项目注定都要不断维护，不停和开发者一同进步。开源项目如逆水行舟，不进则退。</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
            <category>undefined</category>
        </item>
        <item>
            <title><![CDATA[程序员大牛是如何编写程序的？]]></title>
            <link>https://yishulun.com/./src/posts/2022/1011.html</link>
            <guid>https://yishulun.com/./src/posts/2022/1011.html</guid>
            <pubDate>Tue, 11 Oct 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>程序员大牛是如何编写程序的？</h1>
<p>好的程序员是怎么写代码的呢？点燃一根烟，一边吸一边进行周密的思考，待想法成熟了，一把操起键盘，一阵噼里啪啦敲击，一气呵成吗？</p>
<p>或者这样，使用具有步进调试功能的 IDE，例如 Visual Studio，一边编写代码，一边调试代码，一步一调试，直到完成所有需求？</p>
<p>你是哪种编写方式呢？那些计算机编程大牛们他们一般又是怎么写代码的呢？</p>
<p>肯·汤普森说：</p>
<blockquote>
<p>我只通过 printf 语句（或类似的 console.log）进行调试，几乎从不使用单元测试或调试功能。通过先设计数据结构开始项目，然后自下而上逐步开展工作，可能会写一些一次性的测试示例。（其实很多大神都是这种编程方式。）</p>
</blockquote>
<p>乔·阿姆斯特朗说：</p>
<blockquote>
<p>在设计软件时，我更喜欢在开始编写代码之前，尽可能严格地记录文档，尤其是对于那些涉及实时网络协议的<strong>困难项目</strong>。我首先使用原型来解决关键问题，而对于调试，则只使用打印语句（这一点和肯·汤普森一致）。</p>
</blockquote>
<p>杰米·扎温斯基说：</p>
<blockquote>
<p>我也更喜欢只使用打印语句调试代码（大神的工作方式惊人一致）。我的流程是自顶向下或自底向上写代码，让代码自然进化，在必要时重构。在开发过程中，我几乎从不使用单元测试，我觉得它会减慢开发速度，破坏我的开发节奏。</p>
</blockquote>
<p>这三位毫无疑问都是计算机世界的大牛。第一位是 C 语言的创建者，第二位是 Erlang 语言的创建者，第三位是 Mozilla 浏览器的创建者。有人说，他们开始编程的年代，还没有可以步进的调试器，还没有单元测试这些完备的开发理念，以致于他们没有养成现代「良好」的编程习惯。</p>
<p>对于这些话，我想说，TOO YOUNG TOO SIMPLE，肯·汤普森可是可以手撸 C 语言和 Unix 操作系统的人，他如果想写一个可以步进的调试器，或者设计一个完善的 TDD（测试驱动开发）工程思想方案，你觉得他做不到吗？肯·汤普森今天还在 Google 一线工作，与同事们一起创建了并维护着 Golang 语言，你觉得他没有接触过可以步进的现代调试器吗？还是他年纪大了学不会呢？</p>
<p>我觉得根本原因，在于扎温斯基说的那句话，使用步进调试功能和编写单元测试代码，会<strong>减慢开发速度，破坏开发节奏</strong>，这是根本原因。程序员写的程序是并发的、多线程的，但程序员写代码这件事却是单线程的，他们可不想被像 CPU 一样打断。</p>
<p>对程序员如何编程这个问题，一个有经验的程序员表示：</p>
<blockquote>
<p>在我看来，编程是一门艺术。一个好的程序员是一个艺术家，是一个思想家，是一个问题解决者，是一个创造者和一个有远见卓识的人，所有优良品质都结合在了程序员身上。他们以简单的方式思考可以长期解决问题的方案，他们愿意遵守规则；如果还没有规则，他们也可以创建规则然后遵守。优秀的程序员也会读很多书，并且总是在技术上不断更新自己。</p>
</blockquote>
<p>另一位有近 30 年编程经验的程序员<a href="https://www.quora.com/profile/Nikola-Mihaylov">尼古拉·米哈洛夫</a>表示，编写程序并不想人们想象的那样酷，<strong>一点也不帅</strong>。下面内容来自他的分享。</p>
<p>在高中期间，我在全国编程比赛中名列前三，并且是国际比赛的候选人。我自己和团队也曾在国民赛中排名第一。作为下班后的爱好，我制作了一个绘画应用程序，最终该程序拥有了约 1000 万用户，并且与类似应用程序相比，运行时出现的问题非常少。它在 Windows Phone 的印度照片应用程序中排名第一，在西班牙排名第二。</p>
<blockquote>
<p>这段经历说明他是一名出色的程序员，至少天赋很不错。</p>
</blockquote>
<p>我认为没有「最好的」程序员，因为每个人的表现都不一样，即使是在同一个任务上也是如此。</p>
<p>在我从事软件开发的前 10 年（共 28 年）中，我每天编写大约 13 小时的程序（很厉害，每天写 13 个小时的代码，并不是我们想象的老外每天只工作 8 小时，只写 2、3 个小时的代码）。我感觉这很有趣，我去完成任何软件方面的事情都没有感到压力，都是基于兴趣驱动的。我不断向朋友学习，从书籍中学习，做项目，尝试做新的事情，我很少感到无聊，总有新东西要学。我从 12 岁左右开始，就一直是这样的状态。</p>
<p>下面是我对编码的看法：</p>
<ul>
<li>
<p>如果代码量很小，例如是程序的一部分，可能是一个 RESTFul API，或者一种小算法，这时候可能要考虑使用的数据结构是什么，这种情况下应该是直接上手就写了，没有什么提前的推演和规划。</p>
</li>
<li>
<p>要尽可能多地考虑边缘情况，并针对它们一一处理和测试，确保处理所有可能发生的错误和已经发现的边缘情况。举一个简单的例子，假设需求是「反转一个字符串中的所有单词」，对于一些特殊的字符串，例如空字符串、空白字符串、一个单词的字符串、2 个单词的字符串、10000 亿个单词的字符串，我们应该如何处理呢？</p>
<p>还有，什么是空白字符串，这涉及到系统中对空白字符的定义，对于不同的空白字符或其组合，例如空格、制表符、不可打印的空格、换行符等，当遇到这些符号时我们又如何处理呢？</p>
<p>还有一些其他方面的特殊情况，例如单词之间，句首和句尾的多个空格如何处理？对于从右到左的语言和没有单词分隔符的语言，如果我们在没有分隔符的情况下，混合使用阿拉伯语+英语单词又会发生什么？等等，看似这是一个简单的小需求，背后却隐藏着很多需要考虑的边缘情况。它并不简单。</p>
</li>
<li>
<p>我主要在代码中思考，而不是编码前准备，尤其是前 10 年。后来我开始重视编写注释，会在注释中解释更多内容，以便后续阅读和维护方便。但在一开始，我只要代码可以工作，很少使用或不用注释。</p>
</li>
<li>
<p>几乎没有单元测试。我觉得它们就像道路上的侧护栏，侧护栏用于阻止可怕的汽车碰撞，任由车辆在护栏上刮擦。我认为生产中的大多数错误都在单元测试可以捕获的场景之外，所以觉得单元测试很鸡肋。（上面提到的边缘情况处理，是在代码中处理的，并非指在单元测试中覆盖。不同类型的项目，单元测试的作用和重要性是不一样的。还有，因人而异。）</p>
</li>
<li>
<p>比单元测试更好的方法是，<strong>对于任何代码更改，通过分析当前函数的所有消费代码，分析它们触发的所有副作用，以及所有可能影响到的边缘情况，然后测试所有代码</strong>。这能让我们对整个代码库有更好的理解，可以消除对单元测试的「温暖」的依赖。将整个项目装在心中，做到熟悉每一行代码，这样做的好处是：1）首先便于发现新的错误和需要改进的地方；2）确实有助于帮助我们提高代码质量。</p>
<p>事实上这件事并不困难，一旦有条不紊地进行全库的洞悉，这件事就会变得简单。我已经使用它取得了巨大成功，有一个项目，有数百万用户，作为一个高端嵌入式系统的软件解释器，和一个高科技研究公司桌面软件的一部分，在生产中运行服务 2 年，0 崩溃。另一个项目运行了大约 5 年，没有出现一个问题，直到服务器退役后我得到了一个 ping，发现它仍然被大约数百名未迁移到新系统的用户使用。</p>
<p>我知道有很多错误或异常，是不会或很难被单元测试捕获的，这些异常通常是集成的、未考虑的边缘情况或类似的东西。通过洞悉项目，在代码变动时测试一切，并记录一切，不必进行单元测试。我知道这个观点有争议，可能会激怒很多人，有人可能会说，团队其他人怎么办，如果你忘记了测试代码怎么办，等等。好吧，这时候就是团队测试纪律、团队文化、最佳实践和编码规范要发挥作用的时候了。</p>
<p>在研发中发现问题，而不是从现在起 6 个月后，那时候所有「单元测试」都已通过并且产品已投入生产运营，相比那个时候发现问题要好的多。并且，我发现，一旦完成多次全面检查，后面这件事也会容易很多。这看似浪费时间，其实在节省时间。</p>
</li>
<li>
<p>对于更复杂的算法，我会写一篇关于如何工作的页面注释。（这也是为了方便回忆和他人阅读。）</p>
</li>
<li>
<p>对于变量命名，总是使用富有表现力的描述词，例如 currIndex、row、col 等。即使 x、y 都比 i、j 要好。</p>
</li>
<li>
<p>对于函数命名，尽可能实现自我记录。名称应该准确地说明函数的作用，要尽量避免函数中产生副作用。如果函数是有条件地执行任务，是一个动作，则可以命名为 UpdateUserIfNeeded(...)，而不是 UpdateUser()，或者 GetInfoAndUpdateDb()而不是 GetInfo()。</p>
</li>
<li>
<p>对于强类型，考虑使用 User、SignedInUser、ModeratorUser 这样的类型。如果匿名用户尝试访问需要登录的资源，可能会导致编译时错误。（将用户分成不同的类型，胜于在一个 User 类型中处理所有用户身份。）</p>
</li>
<li>
<p>除了性能原因之外，尽量保持数据不可变。</p>
</li>
<li>
<p>我每天使用的提示检查模板是：1) 始终检查所有边缘情况；2）解析没有验证的数据；3）简化 if else 语言，如果可以就提前退出；d）快速崩溃，总是在需要开发人员立即修复代码的地方马上抛出异常，不要静默它们；这里要与用户错误区分开，用户错误总是要处理的，而开发错误总是选择抛出。</p>
</li>
</ul>
<p>另外，在遇到困难时请不要自暴自弃。我大约每 5-10 行代码就会产生 1 个错误，这很正常，有错误绝不是不足。我喜欢通过处理边缘情况来规避大部分错误，但我不知道我没有捕捉到全部。庆幸你发现的每个错误吧，这些错误可以避免成为生产问题。有时在代码审查中，有 40 多条评论也是很常见的，接受自己就好。</p>
<p><strong>小结</strong></p>
<p>这是一位大佬，他分享了自己接近 30 年的编程经验，很诚恳。对于调试和单元测试，大佬都不喜欢在编码中途停下来做这件事，他们更喜欢在一次性编写完成后集中做自动化测试。与其被自己的单元测试打断，在中国开放式的工作环境中，我想他们是不是更介意被没完没了且毫无意义的会议打断呢？</p>
<p>还有钉钉，你一直不回复，可以一直钉你，钉到会回复为止。我很想知道肯·汤普森如果在这样的环境中工作，他会是什么表情。</p>
<img src="./assets/image-20221011121717446.png" alt="image-20221011121717446" style="zoom:25%;" />
<p>参考链接</p>
<ul>
<li><a href="https://www.quora.com/How-do-the-best-programmers-write-programs-Do-they-reason-the-program-out-formally-on-paper-before-stepping-up-to-a-computer/answer/Nikola-Mihaylov">https://www.quora.com/How-do-the-best-programmers-write-programs-Do-they-reason-the-program-out-formally-on-paper-before-stepping-up-to-a-computer/answer/Nikola-Mihaylov</a></li>
<li><a href="https://www.quora.com/How-do-the-best-programmers-write-programs-Do-they-reason-the-program-out-formally-on-paper-before-stepping-up-to-a-computer/answer/Debasis-Ray-5">https://www.quora.com/How-do-the-best-programmers-write-programs-Do-they-reason-the-program-out-formally-on-paper-before-stepping-up-to-a-computer/answer/Debasis-Ray-5</a></li>
<li><a href="http://www.dodgycoder.net/2012/07/old-school-developers-achieving-lot.html">http://www.dodgycoder.net/2012/07/old-school-developers-achieving-lot.html</a></li>
</ul>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
            <category>undefined</category>
        </item>
        <item>
            <title><![CDATA[编写干净、清晰代码的9个小技巧]]></title>
            <link>https://yishulun.com/./src/posts/2022/1010.html</link>
            <guid>https://yishulun.com/./src/posts/2022/1010.html</guid>
            <pubDate>Mon, 10 Oct 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>编写干净、清晰代码的9个小技巧</h1>
<p><strong>问题</strong></p>
<p>如题，以下这些编程技巧，可以让代码编写的更清晰，使初学者看起来更像一位老手。让初学者代码看起来老练的技巧，并不是什么奇巧淫技，而是谁都能看得懂、学得会的，很平常的技巧。相反，在代码中为了展示水平而刻意显得与众不同，这是不自信的表现，也是初学者的主要特征之一，反而自爆了初学者的短板。对于初学者，学会这些小技巧足矣。</p>
<hr>
<p>软件开发不仅仅是编写代码，更是编写团队其他开发人员可以轻松理解的简洁代码。下面提到的 9 个技巧，它们将帮助你编写更清晰易读的代码。</p>
<blockquote>
<p>这些技巧并不分什么编程语言，基本适用于所有编程语言，尤其是与 C 语言风格一致的语言。</p>
</blockquote>
<p>（1）使用描述性名称</p>
<p>干净的代码很容易别人理解。在编写代码时，我们在局部代码中使用 i、j、k 等短名称，但有时候我们更应该使用有意义的描述词，来声明变量、参数和函数名称等。</p>
<p>例如，不要这样写：</p>
<pre><code class="language-js">const n = 100;
const it = 200;
</code></pre>
<p>而要这样：</p>
<pre><code class="language-js">const number = 100;
const iterations = 200;
</code></pre>
<p>（2）使用适当的空格和缩进</p>
<p>我们程序员中的许多人认为，使用空格和缩进会影响编译器的速度，但这是不正确的，在编译型语言中它们的影响可以忽略不计，在解释型语言中的影响也不高于因代码不易读而带来的负面影响。</p>
<p>你应该在代码中使用空格和适当的缩进，因为这会使你的代码更容易阅读与理解。</p>
<blockquote>
<p><strong>像艺术家一样，像国画或篆刻一样，把代码安排得错落有致。</strong></p>
</blockquote>
<p>举个例子，不要这样做：</p>
<pre><code class="language-js">function start() {
var name = &quot;LIYI&quot;;
var code = 200;
}
</code></pre>
<p>而要这样：</p>
<pre><code class="language-js">function start() {
  var name = &quot;LIYI&quot;;
  var code = 200;
}
</code></pre>
<blockquote>
<p>除非你想故意写出自己不能被团队随意替换的代码，否则在任何时候，保持缩进和空格都是一条基础黄金准则。与其相关的还有空行，保持空行除了让代码行数增加，更主要的能让代码清晰。</p>
</blockquote>
<p>（3）尽量减少函数中的参数个数</p>
<p>因为我们在努力使我们的代码清晰，因此我们应该尽量编写更易于阅读的函数，我们应该通过减少形参的个数以使函数变小，特别当这个函数及它的同类函数有不定数目参数的时候。如果我们需要使用两个或三个以上的参数，那么我们可以声明一个参数对象来代替。</p>
<p>例如，不要这样做：</p>
<pre><code class="language-js">function register(name, email, password, phone, address, intresets){
  ...
}
</code></pre>
<p>可以这样做：</p>
<pre><code class="language-js">function register(options){
  ...
}
</code></pre>
<p>在 options 实参对象中，可以传递 name、email 等信息。</p>
<blockquote>
<p>过度简化参数会让函数的调用条件不明确，简化参数其实一把双刃剑。在开始编写代码的时候，初学者可以简单遵照这样一条标准：凡函数有三个以上的参数，并且这个函数也不是高频调用的函数，就可以将其参数对象化。</p>
<p>在小程序的平台 API 中，由于基本每个接口都有三个以上的参数，所以所有接口的参数，都是以一个 options 参数对象定义的。</p>
</blockquote>
<p>（4）每个函数仅负责执行一个任务</p>
<p>多个任务放在一起处理，这很棒，但在编写清晰的代码方面不是。在许多情况下，开发人员会创建一个有能力执行多个任务的函数，但我们一般需要避免这种情况，因为这通常会使其他人难以理解。通过为一项任务创建一个函数，我们可以更轻松地组织复杂的代码。</p>
<blockquote>
<p>某些任务，是需要分别用一个函数完成的；某类任务，是可以用一个函数完成的。代码就是要智能、批量处理问题的，如果不能这样做，还写代码干什么？有些初学者写代码，在解决某些问题时，用了很多 if else，如下所示，有时候嵌套还很深，这种情况完全可以智能处理一下，用一套代码处理一类问题就可以了，例如针对下面的代码利用 switch 语句等技巧改写。</p>
<pre><code class="language-java">public void onClick(View v) {
    int id = v.getId();
    if (id == R.id.button1) {
        startActivity(new Intent(this, StandardActivity.class));
    } else if (id == R.id.button2) {
        startActivity(new Intent(this, SingleTopActivity.class));
    } else if (id == R.id.button3) {
        startActivity(new Intent(this, SingleTaskActivity.class));
    } else if (id == R.id.button4) {
        startActivity(new Intent(this, SingleInstanceActivity.class));
    } else if (id == R.id.button4) {
        startActivity(new Intent(this, SingleInstanceActivity.class));
    } else if (id == R.id.button5) {
        startActivity(new Intent(this, SingleTopActivity.SingleTopActivity1.class));
    } else if (id == R.id.button6) {
        startActivity(new Intent(this, SingleTopActivity.SingleTopActivity2.class));
    } else if (id == R.id.button7) {
        startActivity(new Intent(this, SingleTopActivity.SingleTopActivity3.class));
    } else if (id == R.id.button8) {
        startActivity(new Intent(this, SingleTopActivity.SingleTopActivity4.class));
    } else if (id == R.id.button9) {
        startActivity(new Intent(this, SingleTopActivity.SingleTopActivity5.class));
    } else if (id == R.id.button10) {
        startActivity(new Intent(this, SingleTaskActivity.SingleTaskActivity1.class));
    } else if (id == R.id.button11) {
        startActivity(new Intent(this, SingleTaskActivity.SingleTaskActivity2.class));
    } else if (id == R.id.button12) {
        startActivity(new Intent(this, SingleTaskActivity.SingleTaskActivity3.class));
    } else if (id == R.id.button13) {
        startActivity(new Intent(this, SingleTaskActivity.SingleTaskActivity4.class));
    }
}
</code></pre>
<p>但有时候又不是这样，有时候我们为了让代码更直观，故意不使用 switch，而不厌其烦地使用大量 if else，这种情况一般发生在项目配置代码上。这类代码仅仅执行一次，它们本来就像配置文件，写得像配置文件也不足奇怪了。</p>
<p>不要迷信任何规则，包括这篇文章里提到的规则。所有规则都有不使用的场景，这篇描述的仅是针对初学者，在大多数编程场景下适用的技巧。</p>
</blockquote>
<p>（5）尽量减少函数体的大小</p>
<p>小型函数比大型函数，或包含大量代码的函数更容易理解。如果你正在处理大型项目，你可以使用类来封装函数，尤其是那些具有共同属性或同属一类的函数。</p>
<p>（6）尽量减少一行中的字符</p>
<p>因为我们正在编写易于阅读和理解的代码，因此我们需要减少每行代码行中的字符。这样我们的代码可以很容易适应屏幕，不需要水平滚动就可以查看代码。也不需要换行，因为在这种情况下阅读者需要左右晃动脑袋。</p>
<blockquote>
<p>每行多少字符没有硬性标准，一般的说法是每行不超过 70 个字符，但现在程序员的浏览器尺寸越来越大，一行在不换行的情况下，能够容纳的字符也越来越多，所以具体字符轻视自己或团队的情况而定。</p>
</blockquote>
<p>（7）提交代码时，总是描述提交的原因</p>
<p>你应该始终定义为什么要在 github 仓库中提交代码，就是每次提交代码时，都编写一下参数<code>-m</code>。这个习惯可以让我们了解几个月前代码中存在哪些错误，以及我们对代码做过哪些更改。你应该用 4 到 10 个词来定义描述信息，或者你也可以使用 1 个词轻松定义，总之要能够让自己很快想起修改的原因就好。</p>
<p>（8）避免代码重复</p>
<p>专注于创建可重复使用的代码。</p>
<p>大多数初学者不会这样做——初学者一般把精力放在了代码能用上，但至少 70% 的初学者代码应该是可以重用重构的。这可以减少我们代码的大小。简单的方法是，你可以将你的工作分解为小任务，并为每个小任务创建一个单独的函数。</p>
<blockquote>
<p>面向对象编程中有一个 DRY 原则，它是 Don't repeat yourself 的简写，意思是<strong>不要重复自己</strong>。重复编写已经编过的代码，有时候会让程序员感到羞赧，很多聪明的程序员不会因为违反 DRY 原则而编写愚蠢的代码，反而会因为避免这种愚蠢而陷入<strong>过度设计</strong>的泥沼，这种情况同样也值得警惕。</p>
<p>对于初学者而言，简单的规则是，只要发现有三处代码一样，甚至只是十分相似，就可以考虑将它们重构为一个函数。至于将这个函数放在哪里，放在需要它的最小范围里。能放在一个类里，就不要放在包（package）里；能放在一个包里，就不要放在一个模块（module）里，总之范围尽量缩小就是。</p>
</blockquote>
<p>（9）不要过度注释</p>
<p>通过以上的技巧，由于我们已经给了变量、参数、函数名以有意义的描述，因此代码中一般不需要注释。仅在使用某些第三方 API、应用程序、模块或处理外部调用请求时，才需要编写注释。要避免因编写注释，而使代码显得累赘冗余。</p>
<blockquote>
<p>程序员很容易从一个极端走向另一个极端，由从来不写注释变得为每行代码、每个函数都写注释，这没有必要。阅读注释也需要消耗精力，除非你想故意为某些代码留下「烟雾弹」，例如「此行代码千万别动，动它的人全都开除了」，否则不要为了写注释而写注释。</p>
</blockquote>
<p>通过编写其他人易于理解的简洁代码，你可以快速成为一名出色的程序员；通过阅读其他人编写的优秀代码，你可以迅速领会和掌握这些技巧。</p>
<p><strong>总结</strong></p>
<p>以上这些只是简单的初学者技巧，学会它们可以避免自己看起来很菜，甚至看起来像一个有经验的老手，就像一个人他的长相无论是否普通，但需要他把个人卫生打扫好，衣着干净整洁，给人的整体印象总不会太差。后续具体到每一门编程语言，都有专门的编程规范，可以再进一步具体地学习加强。</p>
<p>参考链接</p>
<ul>
<li><a href="https://programmersallaroundtheworld.quora.com/9-tips-for-writing-clean-code">https://programmersallaroundtheworld.quora.com/9-tips-for-writing-clean-code</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/20573365">https://zhuanlan.zhihu.com/p/20573365</a></li>
</ul>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
            <category>undefined</category>
        </item>
        <item>
            <title><![CDATA[互联网下的微服务架构模式有哪些？]]></title>
            <link>https://yishulun.com/./src/posts/2022/1009-2.html</link>
            <guid>https://yishulun.com/./src/posts/2022/1009-2.html</guid>
            <pubDate>Sun, 09 Oct 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>互联网下的微服务架构模式有哪些？</h1>
<p>下面列举的肯定不是全部，仅是一些例子。</p>
<!-- more -->
<ul>
<li>
<p>API 网关模式。负载均衡、服务发现、数据过滤、权限验证等，都可以放在这里。这里就像城门，来自客户端的请求想进城，都必须通过这里。服务发现简单理解是，为客户端找到它需要并可以连接的服务器 IP 地址。这个模式像传统的代理模式。</p>
<p>在此模式下，<a href="https://github.com/apache/apisix">APISIX</a> 是 Apache 软件基金会下一个云原生 API 网关软件，也也是一款不可多得的国产开源软件，它兼具动态、实时、高性能等特点，提供了负载均衡、动态上游、灰度发布、服务熔断、身份认证、可观测性等流量管理功能。它主要采用 Lua 语言编写。</p>
</li>
<li>
<p>客户端 UI 组合模式。像桌面上的 Widget 一样，每一块都是独立的，可以独立请求和展示数据。优点是组合方便，缺点是资源请求可能多且浪费。像传统的外观模式。</p>
</li>
<li>
<p>服务与数据库一一对应模式。<strong>一个服务对应一个 Schema 是实现数据私有化的最佳选择</strong>，可以为每个子系统的开发团队单独配置一个数据库连接账号，这样便可以限制每个子系统的数据访问权限。优点是数据各自为政，架构清晰简单；缺点是设计多个微服务或团队的查询等操作变得复杂了。这个模式不像任何一个传统的设计模式，它像面向对象的基本特征之一：封装。</p>
</li>
<li>
<p>Saga 模式。这种模式是上一种架构模式的补充，Saga 是一种本地跨语言的事务链，它不仅有本地事务编配、编排，还有总事务失败后的补偿机制。像传统的责任链模式。</p>
<p>在此模式下，<a href="https://github.com/apache/servicecomb-pack">Apache ServiceComb Pack </a>提供了技术解决方案，它主要基于 Java 语言实现。</p>
</li>
<li>
<p>断路器模式。就是熔断模式，像股票一样，跌的太狠了，强制关停，避免事态进一步恶化。具体实现方式可能是这样的：在网关处记名监听来自客户端的网络请求，如果某个客户端屡屡请求失败，则强制断开和限制其连接，避免发生雪崩效应；在一定时间后，再允许这个客户端发起限量连接。</p>
</li>
<li>
<p>子域分解模式。按照业务将大系统拆分为小系统，由各个小分队分别折腾。像传统的组合模式。</p>
</li>
<li>
<p>绞杀榕模式。类似传统的装饰模式，像一个含羞草慢慢将旧系统包裹、吃掉、重构、关停。慢慢外界不知道这个系统，直到有一天在数据检测中发现无人使用了，将其关停。</p>
</li>
<li>
<p>反腐蚀层模式。这个模式厉害，它要确保<strong>旧的系统不需要做出改变，同时新系统也不需要在设计和技术方面做出妥协</strong>。**计算机世界的任何问题，都可以通过添加一个新的层来解决。**这个模式可能是这样实现的：添加一个新的层，用于新旧数据的转换——当然前提是，新旧数据在理论上可以相互转换。像传统的代理模式。</p>
</li>
</ul>
<p>参考链接</p>
<ul>
<li><a href="https://www.infoq.cn/article/Pv1qlEa1GgU7m0sWBmdI">https://www.infoq.cn/article/Pv1qlEa1GgU7m0sWBmdI</a></li>
<li><a href="https://github.com/apache/servicecomb-pack">https://github.com/apache/servicecomb-pack</a></li>
<li><a href="https://github.com/apache/apisix">https://github.com/apache/apisix</a></li>
</ul>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
            <category>undefined</category>
        </item>
        <item>
            <title><![CDATA[弱的软件开发人员都跑到哪里工作了？]]></title>
            <link>https://yishulun.com/./src/posts/2022/1009-3.html</link>
            <guid>https://yishulun.com/./src/posts/2022/1009-3.html</guid>
            <pubDate>Sun, 09 Oct 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>弱的软件开发人员都跑到哪里工作了？</h1>
<p>信不信由你，他们可能成为了你的上司。</p>
<p>首先声明一下，以下内容主要翻译自<a href="https://www.quora.com/profile/Tomislav-Turalija">托米斯拉夫·图拉利亚</a>，主要是他的观点。我作为一名弱的软件开发人员，可没有资格成为一群强的软件开发人员的上司，更没有压榨他们。</p>
<p>下面是图拉利亚的话。</p>
<p>我在 IT 领域工作了大约 10 年，主要在 20 至 100 人的中小型公司工作。在这类公司中，最薄弱的环节却进步得更快，这是一个悖论，但它却是真实的。下面是一些记录自真实世界的例子。</p>
<p><strong>示例 1</strong></p>
<p>当优秀的开发人员在老旧项目上勤恳工作并不断解决 Bug 时，一个糟糕的开发人员会为自己的管理辩护，因为整个项目是以「错误的方式」完成和维护的。糟糕的开发人员因此会被提升为团队负责人，并肩负起了「以正确的方式」做事的使命。</p>
<blockquote>
<p>这大概就是好人长在嘴上，会干不如会说。这是一句鸡汤。</p>
</blockquote>
<p><strong>示例 2</strong></p>
<p>公司有一个开发人员团队，正在开发一个非常大的项目，他们急需要一个项目经理，所以他们将最弱的开发人员提拔为项目经理。没有人想念他，因为这个人在编码上非常糟糕。因为接下来几个月的时间都不需要为引入新人而操心，所以这一举动被大家默认是合理的。</p>
<blockquote>
<p>项目经理和产品经理，不管怎么说，它们是门槛非常低的岗位，基本是个人都能做，做好做坏且不论。如果这个人再经常给大家买买零食，帮大家跑个腿，基本团队的所有成员都不再嫌弃他。中国人普遍对弱者都很善良，强者很多时候还以能维护弱者的生存为荣耀。但弱者有时候却以此为耻，并不会还有任何感激。</p>
</blockquote>
<p><strong>示例 3</strong></p>
<p>一家非常有前途的初创公司，开发人员数量往往短时间内会大幅增加，一般这种情况下，他们会提拔在公司工作时间最长的开发人员作为组织架构中的团队负责人。这些人的编码质量仅仅可以超越小学生的编程水平，但因为他们在公司工作时间最长，忠诚度最高，所以得到提拔。一般他们的工资也是最低的，他们接受这种工资，因为没有人愿意为他们的技能支付更多。</p>
<blockquote>
<p>愿意拿最少的工资，以彰显团队的稳定团结，对团队的文化建设、文件继承也算是有价值啦。</p>
</blockquote>
<p><strong>示例 4</strong></p>
<p>在创业公司，团队中有两种类型的人：满不在乎的人和想把事情做对、做好的人。在与无知的管理人员，和团队中的不良成员进行了几个月的斗争后，所有优秀的开发人员都会辞掉了工作。猜猜谁会被提拔起来管理新团队？</p>
<blockquote>
<p>劣币驱逐良币这个现象，全世界都存在。并不是像某些书或人讲的，中国人有劣根性，所以很难管，不是的，这些都是弱的管理人员在管理不好的时候，编织的一些借口。</p>
</blockquote>
<p><strong>示例 5</strong></p>
<p>一位非常糟糕的软件开发人员，因表现不佳而被解雇，他起诉公司并且还获胜了。他的理由是，在所有开发人员中，他每天编写的代码行数最多，所以他做的工作最多。他说的是事实，他的同事将他的 8000 行代码类重构为 230 行。后来公司给了他一年的工资，作为他答应辞职的条件。</p>
<blockquote>
<p>可笑的是，那些真正想把事情做对、做好的人，他们往往一怒之下就主动离开了团队，没有得到任何补偿。这一般是因为，他们相信自己很快就能找到新工作，并且也不屑于做一些他们认为卑鄙的事。而另外一些人则不是，他们因为害怕，而主动学习并实践到了许多非工作方面的生活技能。</p>
</blockquote>
<p><strong>示例 6</strong></p>
<p>一个糟糕的开发人员总是向管理层抱怨，其他开发人员强迫他参加代码审查。原因很简单，他是整个团队中唯一一个编写糟糕代码的人，他每次提交代码都会导致项目混乱。过了一段时间，他说服管理层，代码审查是浪费时间和金钱的，不进行代码审查将为公司节省很多成本，可笑管理层相信了他的鬼话。他先成为了团队负责人，继而又成为了部门负责人，因为所有优秀的开发人员都在他升职后的几个月内辞掉了工作。</p>
<blockquote>
<p>Code Review 是一项非常好的团队文化举措，它可以促进团队保持公平、公正和透明的规则，也可以促进成员之间相互主动学习。当然推进的时候肯定有阻力，这时候就是考验管理层水平和意志力的时候了。</p>
<p>天下的乌鸦都一样黑，美国的月亮也不比中国圆。在研发管理上，中外小团队面临的问题我相信都是类似的。</p>
</blockquote>
<p><strong>示例 7</strong></p>
<p>一家快速发展的 IT 初创公司肯定需要很多新人，所以他们雇佣了大量的软件从业人员。每个不是写程序这块料的开发人员，都被提升为项目经理或销售代表，极少的人转到营销、设计团队，只有很少的一部分人从事软件开发工作。</p>
<blockquote>
<p>任何时候软件开发的门槛都是存在的。</p>
</blockquote>
<p><strong>示例 8</strong></p>
<p>在许多情况下，团队领导和项目管理人员，将缺乏足够沟通能力的弱编程人员，转移到数据分析师、软件设计师、软件架构师等岗位或角色。</p>
<blockquote>
<p>架构师在国内其实一个受人追捧的角色，没有想到在国外，它是一个像产品经理一样夸夸其谈的角色。很多时候架构师确实只是在说，并不是在做，尤其是业务架构师。</p>
</blockquote>
<p><strong>示例 9</strong></p>
<p>在较大的公司中，开发人员总是来来去去。通常，优秀的开发人员会离开以获得更高薪水的工作，而弱的开发人员会留下来，因为他们找到了一份自认为不错的稳定工作，并获得了他们满意的薪水。几年后，弱的开发者成为了团队唯一的老员工，所以他们是最先得到晋升的。</p>
<p>我还有很多例子。没有必要把它们都写出来。基本就是，如果您是弱程序员，那么您仍然很有可能获得一份好的工作和高的薪水——通常比一个好的程序员还更好，还要高。如果你是一名优秀的程序员，你可能不会得到晋升，因为你是团队里干活的主力，如果公司提拔你，就没有人能把事情做好了。</p>
<p>你可能会觉得这很奇怪，但确实很少有公司像谷歌、Facebook、亚马逊等那样重视他们的开发人员。在大多数情况下，软件开发人员被认为是<strong>高薪的互联网民工</strong>，他们的薪水是研发团队最大的支出成本，管理层认为必须加强管理，以最大程度榨取他们的剩余价值，例如 996、007、末位淘汰机制等。很少有开明的老板愿意把好的开发人员，真正视为团队的财富而细心呵护。</p>
<p><strong>后记</strong></p>
<p>我看到这篇帖子还是有点小震惊的，以前总有人说，中国和国外不一样，中国是人情社会，不能照搬研发管理的那一套。其实在软件的研发管理中，中外遇到的问题是相似的，国外的月亮也没有那么圆，国内土生土长的程序员也没有那么不堪。</p>
<p>**最后，向所有一直在岗位上把事情做对、做好，以后仍然想做对、做好的程序员致敬，无论厂子大小！**也向自己致敬，我一直都是这样走过来的。（关于团队管理，客观讲我认为它是计算机世界客观存在的一种事物，必须按照软件研发管理的科学理论认真对待，并不是什么旁门左道。）</p>
<p>参考链接</p>
<ul>
<li><a href="https://www.quora.com/Where-do-weak-software-developers-work/answer/Tomislav-Turalija">https://www.quora.com/Where-do-weak-software-developers-work/answer/Tomislav-Turalija</a></li>
</ul>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
            <category>undefined</category>
        </item>
        <item>
            <title><![CDATA[Linux会因为开源而失败吗？]]></title>
            <link>https://yishulun.com/./src/posts/2022/1009.html</link>
            <guid>https://yishulun.com/./src/posts/2022/1009.html</guid>
            <pubDate>Sun, 09 Oct 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>Linux会因为开源而失败吗？</h1>
<p>我不确定当你看到这张图时，是不是和我一样感到震惊？</p>
<p><img src="./assets/main-qimg-effa76a1eff52868e3b4459a1a5b5936.png" alt="img"></p>
<p>这行图大致描绘了三个主要 Linux 发行版 Debian、Fedora 和 Slackware 的分支演化情况，三个分支下，每个分支背后都隐藏着一个绝顶聪明的开发者或一个精英团队在维护。</p>
<p>这张图来自<a href="https://www.quora.com/profile/Tomislav-Turalija">托米斯拉夫·图拉利亚</a>，他认为 Linux 发行版之所以出现这种过度野蛮的生长——产生了一百多种不同的 Linux 发行版，完全是由于开发者的自负（BIG EGO）。</p>
<p>下面以 Debian 路线的分支演化举例，看一看这种来自开发者的自负是如何体现的，其他两个分支的情况与其类似。</p>
<p>确实 Debian 是一个不错的发行版，它稳定、健壮，但它缺乏新的、酷的东西。因此，一些开发人员开始捯饬轻量级的 Linux Knoppix——一个基于光盘或 USB 闪存启动的 GNU/Linux 系统，而另一些开发人员则开始开发更前沿的版本 ——Ubuntu。</p>
<p>Ubuntu 因为几乎可以在全世界范围内免费分发 CD，它因此受到了很多人的喜欢，Linux 系统也被更多人看到和使用。我 2006 年在北京从事编程工作的时候，同办公室的同事在网上免费就申请了一个 Ubuntu 系统，当他收到 CD 包裹的时候，他还高兴地拿给我们看。在印度，有很多地方网络基础设施不完善，只要当地的开发者提出申请，他们就能得到一张免费邮寄的系统安装盘。CD 大概有 700MB，基本支持所有的主流硬件，不需要到处找驱动就可以马上安装使用，想想这真让人激动。</p>
<p>但是很多人不喜欢 Ubuntu 的界面，不久，除了 Ubuntu，就诞生了 Kubuntu、Lubuntu 和 Xubuntu，它们相当于 Ubuntu 的大皮肤，或者说是三件时尚——想时尚的外套。</p>
<p>下面这些话基本来自图拉利亚的抱怨，他是一位非常有经验的开发者，他讲的话是可信的。</p>
<ul>
<li>一些人想要更好的软件支持，他们制作了 Ubuntu Studio；</li>
<li>一些人想要一个不同的界面，他们制作了 Mint；</li>
<li>一些人喜欢一切，但希望界面颜色更好，他们制作了 ZorinOS；</li>
<li>谷歌想要一个更简单的版本，他们制作了 ChromeOS；</li>
<li>一些人希望它更像 MacOS，他们制作了 Elementary OS；</li>
<li>一些人想要一个更安全的版本，他们制作了 ParrotOS；</li>
<li>一些人讨厌已有的这一切，他们制作了 Solus、Arch 等。</li>
</ul>
<p>等等，还有很多，数不胜数。</p>
<p>随着时间的推移，所有这些开发者都在分散、减少，而不是一起工作。他们必须一遍又一遍地解决相同的问题，而不是为了一个共同的目标而共同努力，所以就有了开头那张「荒谬」的图表。想象一下，如果聪明的开发者都在同一个 Linux 版本上工作，那会是一个什么样的结果？</p>
<p>下面说一下我的观点。</p>
<p>先说 Linux 是否失败。如果拿 Linux 桌面版与 Windows 系统的市场份额做比较，Linux确实是失败了。但是 Linux 本来就不是一个商业公司啊？如果拿 Linux 的作者林纳斯·托瓦兹（Linus Torvalds）与微软的创始人比尔·盖茨（Bill Gates）作为一名程序员对比，显然林纳斯·托瓦兹又非常成功。百年之后——或者二百年之后，微软帝国大概可能不存在了，但 Linux 系统可能还在。Linux 发行版越是繁华多样，这种成功就越是耀眼；有如此多的分支，不是 Linux 的弱点，反而是它成功的标志。</p>
<p>再谈一下动机。让一百多个发行版的开发者为一个发行版而努力，这是公司的行为，试问，谁给他们发薪水？能写这些系统的家伙，他们单位小时的技术薪水应该都不低，谁有财力养活他们？如果把他们招揽在一起，在一起共同维护一个系统，这不就是微软吗？</p>
<p>像软件、谷歌这样的大厂实行的研发机制，像计划经济；而 Linux 发行版实行的，更像是开源世界里的市场经济。这两种模式它们肯定会相互学习，大厂学习开源模式的优点，甚至带头搞开源，这都不稀罕；有越来越多的开发者——像图拉利亚这样的开发者，也会看到发行版发展混乱、缺少规划的问题，但解决或改善这个问题可能还需要时间和智慧。</p>
<p>还有，有一点必须提一下，有一些发行版的背后是一个小团队在维护，他们之所以那样做，源于他们的客户的需要。虽然混乱，但星星点点都是经济价值。</p>
<p>当我第一次看到篇首的那张分支演化图时，我感到的不是震惊，不对，也可以理解为是一种震惊，惊于 Linux 发行版发展的繁荣与兴旺，而不是混乱与无序。</p>
<p>我不确定当你看到这张图时，是不是和我一样感到震惊？</p>
<p>参考链接</p>
<ul>
<li><a href="https://www.quora.com/Does-Linux-really-fail-because-it-is-open-source/answer/Tomislav-Turalija">https://www.quora.com/Does-Linux-really-fail-because-it-is-open-source/answer/Tomislav-Turalija</a></li>
<li><a href="https://zh.wikipedia.org/zh-tw/Knoppix">https://zh.wikipedia.org/zh-tw/Knoppix</a></li>
</ul>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
            <category>undefined</category>
        </item>
        <item>
            <title><![CDATA[什么样的故事才显得真实？]]></title>
            <link>https://yishulun.com/./src/posts/2022/1006-2.html</link>
            <guid>https://yishulun.com/./src/posts/2022/1006-2.html</guid>
            <pubDate>Thu, 06 Oct 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>什么样的故事才显得真实？</h1>
<p>故事都是假的，都是人为编出来的，但是有的故事就显得真实可信，这是为什么呢？下面这位编辑的话给了我启发，故事是否真实存在并不重要，关键在于是否充满曲折离奇的情节。一旦作者准备这么做了，还要注意避免下面编辑提到的四项。<br>
​<br>
下面是编辑的话：​</p>
<blockquote>
<p>我在回复中提到「故事的编造痕迹比较重」，作者会很认真地告诉我，这是生活中的一件真事，我当然相信他的话，我所说的编造痕迹也不是说这个故事是编出来的，而是说故事给你假的感觉。</p>
<p>故事是可以虚构的，而且好的故事都有很多成分是虚构的，但这种虚构是有生活基础的，我们常说文学艺术作品「源于生活，高于生活」就是这个意思。读者不会在意你这个故事本身是真的还是假的，只会在意情节的合理性，这个「理」指的就是「艺术真实」。</p>
<p>什么是「艺术真实」呢？一定要「出人意料」。所谓「出人意料」也是指一种情节逆转，我们常说的故事的尾巴要「翘一翘」，也就是「意料之外」的意思。情理之中与意料之外这两者必须结合起来，缺一不可。不能达到「意料之外」，故事显得平淡；不能做到「情理之中」，情节又显得生硬。</p>
<p>那么，为什么有的作者的故事情节已经写得千变万化非常曲折了，而编辑仍说情节不够好呢？我想或者有以下几个原因：</p>
<p>一，是情节的转折始终按照常理发展，虽然一直在变化，但大家都能想到，也就没有什么稀奇的了；</p>
<p>二，是情节的发展始终按照讲述者的意愿进行，给读者的感觉是不是人物之间矛盾冲突的自然发展导致了情节的发展，而是写故事的人想到哪里写到哪里，这样的情节曲折同样是没有吸引力的；</p>
<p>三，是缺少有特点的细节，缺少细节的情节永远是干瘪瘪的，一个故事若能有一两出有生活气息的、有特点的或者是有趣的细节，情节立刻就会饱满起来。</p>
<p>四，是情节没有围绕一个统一的线索发展，情节虽然曲折，但写得不集中，写到另外的事情上去了。</p>
</blockquote>
<p>这位编辑总结的四点：故事要曲折，情节不能随便让人猜到；情节发展要由人物间的矛盾自然推动；要有细节；是复仇还是寻宝围绕一条主线展开，我觉得做到这几点，基本上故事就显得真实了。</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
            <category>undefined</category>
        </item>
        <item>
            <title><![CDATA[学到的技术知识在使用的时候总会忘记，怎么办？]]></title>
            <link>https://yishulun.com/./src/posts/2022/1006.html</link>
            <guid>https://yishulun.com/./src/posts/2022/1006.html</guid>
            <pubDate>Thu, 06 Oct 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>学到的技术知识在使用的时候总会忘记，怎么办？</h1>
<p>今天看到一位国外前端程序员，他分享了一个这样的学习体验：</p>
<blockquote>
<p>当我开始学习 HTML 和 CSS 的时候，当我想使用刚刚学到的东西时，我总是忘记我学到的东西。我不知道怎么做才能将它们牢记于心？</p>
</blockquote>
<p>遗忘是正常现象，再熟悉的编程语言如果一年半年不写也会变得生疏。他给出的建议是，与其牢记，不如理解和实践。</p>
<p>在刚学习的时候，总是不能随心所欲去构建那些激动人心的 Web 程序，会感觉很沮丧；一步一步跟着教程去做，是可以依葫芦画瓢做出来的，但一旦遇到新问题，一放到实际项目中就傻眼了，这很正常。</p>
<p>这时候除了安慰自己，还可以动手记一些笔记，将理解和实践的东西一一记下来。不必在意自己有没有牢牢记住，持续坚持学习，相信有一天，大概在三四个月以后，便开始能马上理解学习的内容了，甚至还能预测课程中的内容。这时候有些东西已经发生了变化，这可能意味着自己已经跨过了某些障碍，一些零散的知识点也开始在脑海中结成网络。</p>
<p>这是一个从量变到质变的过程。从非程序员，到程序员，这绝对是一个质变，这样的质变绝不是一朝一夕可以完成的，初学者花费三四个月，甚至半年的时间是合理的。</p>
<p><strong>要注重理解和实践，而非死记硬背</strong>，还有，就是放平心态，给自己足够的蜕变的时间。这便是来自这位国外程序员的学习经验，我觉得它至少会对一部分人有效，分享给你。</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
            <category>undefined</category>
        </item>
        <item>
            <title><![CDATA[PBL网文小说与技术实战图书写作流程模板]]></title>
            <link>https://yishulun.com/./src/posts/2022/1005.html</link>
            <guid>https://yishulun.com/./src/posts/2022/1005.html</guid>
            <pubDate>Wed, 05 Oct 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>PBL网文小说与技术实战图书写作流程模板</h1>
<p>PBL 网文小说：</p>
<ul>
<li>0，要有一个主题（例如成长环境对人性格的影响「射雕英雄传」，爱情「神雕侠侣」）</li>
<li>1，依据主题，确立一个故事大纲（例如「神雕侠侣」中的各种恋爱类型：养父养女恋、师徒恋、同门恋、姐妹恋、大叔小妹恋等）</li>
<li>2，根据大纲，调查与收集多个故事示例</li>
<li>3，将多个故事示例整合到一起。情节不通的，想办法编撰情节串起来</li>
<li>4，反推，做减法，到第一节</li>
<li>5，从第一节开始撰写（在这里就可以连载了）</li>
<li>6，最后是修订润色，相当于再版修订</li>
</ul>
<p>同样的 PBL 实战课程是这样的：</p>
<ul>
<li>0，要有一个主题（例如小程序优化）</li>
<li>1，先确定一个知识点大纲</li>
<li>2，依据大纲，依次构建所有示例</li>
<li>3，将所有示例整合到一个项目中</li>
<li>4，将 PBL 项目反推剥离，到第一节</li>
<li>5，从第一节开始撰写（这个时候就可以连载了）</li>
<li>6，最后是润色修改</li>
</ul>
<p>这套模板目前仅在实战课程中有实际运用，在网文小说写作中还未曾应用，因相信该模板而在小说创作中遭遇扑街由私淑者自己负责。</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
            <category>undefined</category>
        </item>
        <item>
            <title><![CDATA[一个公司怎么保持自己良好的价值观？]]></title>
            <link>https://yishulun.com/./src/posts/2022/1004-2.html</link>
            <guid>https://yishulun.com/./src/posts/2022/1004-2.html</guid>
            <pubDate>Tue, 04 Oct 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>一个公司怎么保持自己良好的价值观？</h1>
<p>只靠招人时严格的筛选，显然是不够的，在日常管理中，还要主动维护价值观，做到奖惩分明。</p>
<p>举个例子，我们都知道公司业务要发展，就需要不断根据时势革新和进取，而有些人他们其实是保守派，他们在公司中的工作可能也是与业务增长无关的，例如运维、客服等这些属于支持型的只能部门，当你提出一个很好的想法，需要他们配合作出某些改变时，他们会义正言辞地给你提一堆反对意见，并且很多建议还能站在公司的角度自圆其说，让你无法反驳。</p>
<p>这些人进得公司来，可能只是想镀镀金，混两年拿一些股权走人，他们的职场哲学就是明哲保身，一般他们被称为职场老油条。这个时候，公司的文化部门就必须发挥作用了，当这种苗头出现的时候，必须惩罚和压制，支持进取派行动。但如果一个公司，有很多高管他们都是保守派的，他们看清了他们即使再努力工作几年后结果也是被优化掉，他们也会选择躺平，甚至连公司的文化部分都已经躺平了，这种情况基本就没得救了。</p>
<p>这是一种大公司病，像腐败一样，想变坏很快，想变好却很难。</p>
<p>职场遇到这种情况，是不是一定要马上离开？看情况，如果还有进取机会，就再暂且忍耐一下等待时机；如果看不到一点机会了，还是选择离开把。</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
            <category>undefined</category>
        </item>
        <item>
            <title><![CDATA[代码模板与武侠小说的情节套路]]></title>
            <link>https://yishulun.com/./src/posts/2022/1004.html</link>
            <guid>https://yishulun.com/./src/posts/2022/1004.html</guid>
            <pubDate>Tue, 04 Oct 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>代码模板与武侠小说的情节套路</h1>
<p>代码模板是一种可以填空或在其基础上改写的代码范式，可以在一定程度上帮助程序员加快写代码的速度，减少重复枯燥的键盘操作。在小说中也有类似的情节套路与之对应。</p>
<!-- more -->
<p>金庸先生自称在写每一部小说时，都要力求有些变化，要故意写得不一样，但这并不是说金庸的小说没有重复。相反，金庸先生这样想反方向用力，恰恰说明是存在重复的，且这种重复很容易发生的。</p>
<p>下面列两个例子。在「神雕侠侣」中，郭襄将要过生日，突然有百草仙等陌生人向她送很多珍贵的贺礼，这些礼物让郭靖和黄蓉都感到吃惊，以他们二人都未必有这么大的面子；对比在「笑傲江湖」中，令狐冲受伤，随师门同行，不断有陌生人主动上前送很多珍贵的药材和礼物，连岳不群夫妇都觉得没有这样大的面子。在「射雕英雄传」中，黄蓉初识洪七公，想甩下七公，却不料每一次反而让七公跑到了她的前面；在「神雕侠侣」中，郭襄想甩下金轮法王逃走，每次都发现金轮法王早已经跑到了她的前面。相信类似的套路还有很多。</p>
<p>类似的武侠小说中这样的情节套路，是可以像代码模板那样复用的。代码模板在使用时，关键信息是有修改的，不是全部代码都一样；情节套路在复用时，也是与角色、当下故事情节契合的，也不是完全照搬，所以读者也不会感到明显的重复。</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
            <category>undefined</category>
        </item>
        <item>
            <title><![CDATA[为什么Google很强？]]></title>
            <link>https://yishulun.com/./src/posts/2022/1003.html</link>
            <guid>https://yishulun.com/./src/posts/2022/1003.html</guid>
            <pubDate>Mon, 03 Oct 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>为什么Google很强？</h1>
<p>资本总是想榨干员工和机器的每一点剩余价值。如果那一天服务器有了意识，一定会揭竿起义。</p>
<!-- more -->
<p>服务器和人一样，基本白天干活晚上休息，有时候白天非高峰时期也是休息的。程序员为了榨干机器的每一点价值，发明了一种叫统一调度的东西，Google 在这方面走在了世界的前列，搞了一个 Borg。</p>
<p>Google Borg 是一套资源管理系统，可用于统一管理和调度资源，目的是充分利用服务器的计算资源。例如大数据计算中心和对外 Web 站点，前者计算密集，后者计算稀疏，两者就可以结合起来统一调度，最大程度不让机器闲置。</p>
<p>Google 服务器的统一调度利用率据说达到了 60%，是目前的天花板。大部分公司，特别是中小公司的服务器，包括你自己的云服务器，10% 的利用率都不到。但是你可能付了 10 倍的钱，如果你的服务器是包年包月的话，意味着 9 成的钱都白付了。</p>
<p>Fackbook 不搞统一调度，据说因为他们的网站是全球网站，全天 24 小时提供服务，不存在时差浪费。这个理由有点牵强，Google 更是全球网站，为什么 Google 要搞统一调度？很大可能 Fackbook，或者说 Meta 现在也在搞了，只是我们不知道。</p>
<p>Google 总结自己的核心竞争力，有两条：1，搜索排名比别人精准；2，机器利用率是别人的 1/10。这就好比东西比别人好用，成本还是别人的 1/10，Google 强大果然是有道理的。</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
            <category>undefined</category>
        </item>
        <item>
            <title><![CDATA[对中小团队研发管理的一点想法]]></title>
            <link>https://yishulun.com/./src/posts/2022/10032.html</link>
            <guid>https://yishulun.com/./src/posts/2022/10032.html</guid>
            <pubDate>Mon, 03 Oct 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>对中小团队研发管理的一点想法</h1>
<p>看一下淘宝架构体系的演进路线：1.0 PHP，2.0 单体 Java，3.0 分布式 Java，4.0 异地多活。大淘宝一开始的架构也不是光鲜与靓丽的，所以对于初创团队，开始只有几条破枪，技术架构也是修修补补，这没有什么，这都是正常的。</p>
<!-- more -->
<p>先说运维方面。当业务增长到一定程度，服务器增长到一定程度，专业的运维团队必然出现，运维与研发的矛盾也必然会凸显出来。像阿里这样的企业，你很难想象它的运维团队竟然暴力解散过，然后以个体分散到了各个研发团队中。到后来，仿照 Google SRE，阿里又建立了自己的 SRE 团队，专门负责服务器的安全与稳定。而配置、部署和发布，这些工作全部交给了研发人员自己处理。</p>
<p>再看研发方面。研发团队大到一定程度一定会产生管理问题，例如子系统多了，边缘问题无人修复。淘宝比较幸运，他们员工民间搞了一个消防队，专门用于救急灭火。</p>
<p>一个公司能不能成长起来，跟很多因素有关。在成长过程中，会遇到很多矛盾，管理者能解决这些矛盾，组织就能成长，公司就能发展，反之就会深陷泥潭。为什么你的组织不能产生消防队？这可能与公司的文化有关，与管理者的价值观有关。管理者要反思，有没有任人唯亲，有没有两面三刀，头没有公私不分，有没有赏罚分明？</p>
<p>研发效能变差和组织协作变差，80% 都败于公正和透明。与其说管理者的职责是管理，不如说管理者的职责是维护公平、公正，是激发和保持团队向上的信心。</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
            <category>undefined</category>
        </item>
        <item>
            <title><![CDATA[为什么技术初创团队和大厂都选择开源？]]></title>
            <link>https://yishulun.com/./src/posts/2022/1002.html</link>
            <guid>https://yishulun.com/./src/posts/2022/1002.html</guid>
            <pubDate>Sun, 02 Oct 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>为什么技术初创团队和大厂都选择开源？</h1>
<p>开源不就是把辛辛苦苦写出来的代码免费分享给所有人吗？你会不会觉得这样做的人是傻子，为什么大厂和初创团队还争相恐后去做这件事情？2022年了，国内程序员如果看不懂这个想象，就不要盲目去创业。</p>
<!-- more -->
<p>先看大厂的动机。最开始大厂是不选择开源的，当团队走到前沿，触及某个前沿问题时，最先想到的是自研。甚至外界有不错的开源产品都会忽略掉，一定要自己开发，把控制权牢牢把握在自己手里。</p>
<p>同时大厂如果收购小公司，或融入开源社区，必须在自研产品中向开源产品做兼容，这个过程据经历过的人说，是很痛苦的。</p>
<p>开源软件一旦起飞，一定会形成一个非常健康的社群，发展会越来越快。不要以为大厂自研的产品发展一定会很快，比外面还快，其实不是的。大厂程序员本身也是一个一个的个体，是没有办法与众多大厂的程序员做抗衡的。何况当下国内大厂还是看国外的 Fackbook 与 Google，还没有到完全引领世界的地步。</p>
<p>所以，大厂自研产品的结果，就是被迫向开源产品兼容，甚至用开源产品替代。既然如此，何必当初要自研呢？</p>
<p>再看初创团队。小团队最怕的是，好不容易开发了一个有价值、用户能快速增长的产品，结果被大厂抄袭了。大厂有更广阔的用户市场基础，有雄厚的资金，有聪明的工程师，小团队怎么可能竞争得过。</p>
<p>所以，以往小团队的命运都很悲催，要么被大厂赶超，要么被大厂收购。收购其实还算是一种不错的结局啦。</p>
<p>那么小团队就没有发展起来的机会了吗？</p>
<p>也不是。小团队怕大厂，但是大厂怕开源啊！小团队在产品初具雏形时，完全可以把产品开源出来，挟社区以对抗大厂。</p>
<p><img src="./assets/image-20221002200644219.png" alt="开源社区、大厂与小团队"></p>
<p>2018 年 6 月 4 日，微软为什么花 75 亿美元收购 Github？微软看中的，正是 Github 上那些开源项目背后的程序员和开源社区。新人都以进大厂为荣，但大厂最忌惮的却是开源社区，而开源社区里面又是一个个活生生的人，踏踏实实写好一个开源项目，也是程序员实现自身价值的有效方式之一。</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
            <category>undefined</category>
            <category>undefined</category>
        </item>
        <item>
            <title><![CDATA[写博客对个人找工作有什么帮助？]]></title>
            <link>https://yishulun.com/./src/posts/2022/1001.html</link>
            <guid>https://yishulun.com/./src/posts/2022/1001.html</guid>
            <pubDate>Sat, 01 Oct 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>写博客对个人找工作有什么帮助？</h1>
<p>今天听阿里P10大佬毕玄讲找工作的经历，发现作为一名非计算机专业的生物系学生，写博客数次给他找工作带来了直接帮助。</p>
<p>在他想换工作时，被满江红站长推荐给淘宝。三面下来，面试官问他这个问题，不会，问那个也不会，让他做题，也没有做出来。但最终，他还是被录用了。为啥？</p>
<!-- more -->
<p>大概有两个原因：</p>
<p>（一）淘宝当时想做的分布式系统，淘宝人自己也不是很明白，还处于探索中。而毕玄通过撰写 OSGi，已经对——至少看起来已经对 OSGi 很了解，淘宝需要这样的人。</p>
<p>现在其实很有公司招程序员的时候，招的都是带有创新性的职位，面试官问什么可能只是他想问，与职位没有必然关系。作为面试者对于自己不了解的问题，也没有必要强答，自信一点，会就答，不会就说不会。认清自己的核心优势，放平心态，没有通过面试是这个职位与自己不匹配，坚持做自己就好。</p>
<p>（二）面试者毕玄还是很聪明的，他作为全省重点高中班的学生，智力的光芒不可能完全在面试官前藏得住。</p>
<p>所以现在 HR 筛选人，最简单粗暴的方法就是卡学历，利用传统的应试教育减少自己的劳动量。除了学历，还可以用智商测试卡，有的公司面试不是做算法题，而是做智商测试卡。这样做的目的，在于为团队找到聪明的人。</p>
<p><strong>现在写博客还有机会吗？</strong></p>
<p>现在仍然有很多人在写博客（或者公众号），效果因人而异。</p>
<p>写博客不能乱写，写别人写过的，甚至抄袭，这都是没有意义的。写博客重在发出自己独一无二的声音，<strong>在于打造自己独特的影响力</strong>。作为程序员写博客，要关注前沿技术，要写那些可以引领他人、甚至可以影响他人前进方向的内容。归纳一下，有两方面的内容值得写：</p>
<p>（一）翻译国外前沿的技术内容；</p>
<p>（二）针对社区中的前沿问题，给出自己的独特见解。</p>
<hr>
<p>什么是 OSGi？</p>
<p>是 Open Service Gateway Initiative 的简写，翻译为汉语是开放式服务网关倡议，是 Java 动态化模块化系统的一系列规范，目的是实现不同功能的 Java 模块在复杂系统中的复用。Eclipse 是插件化的，是完全建立在 OSGi 框架之上的。Eclipse 插件之间如何协作，是靠 OSGi 规范进行协作的。</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
            <category>undefined</category>
        </item>
        <item>
            <title><![CDATA[程序员的三个阶段与产品开发的两种哲学]]></title>
            <link>https://yishulun.com/./src/posts/2022/10012.html</link>
            <guid>https://yishulun.com/./src/posts/2022/10012.html</guid>
            <pubDate>Sat, 01 Oct 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>程序员的三个阶段与产品开发的两种哲学</h1>
<blockquote>
<p>很多时候我们纠结，不知道如何选择，只是因为我们忘记了有当下处境这个变量。把处境考虑进去，所有问题都不会纠结。而如果没有处境，也没有产生纠结，这多半已经坏了，一定是我们看问题还不够全面。一个真正的问题，一定是充满矛盾，可以让我们说上一整天的话题。</p>
</blockquote>
<!-- more -->
<h2><strong>人生的三个境界</strong></h2>
<p>汪国真说人生有三个境界：</p>
<ul>
<li>第一境界，昨夜西风凋碧树，独上高楼，望尽天涯路；</li>
<li>第二境界，衣带渐宽终不悔，为伊消得人憔悴；</li>
<li>第三境界，众里寻他千百度，蓦然回首，那人却在灯火阑珊处。</li>
</ul>
<p>这应该是有能力上升到第三个境界的人，才能拥有的境界，对于大多数的人，第一个境界都不会觉醒，更不要说到达第二、第三境界了。</p>
<h2>程序员的三个阶段</h2>
<p>今天听毕玄分享在淘宝做 HSF（High-speed Service Framework，是在阿里广泛使用的一个分布式 RPC 服务框架）时的经历，他将程序员生涯划分为了三个阶段：</p>
<ul>
<li>掌握了技能，可以快速进行业务开发的第一阶段；</li>
<li>善于解决问题的第二阶段；</li>
<li>善于将问题规避于无形之中的第三阶段。</li>
</ul>
<p>其中第二个阶段提一下。据说淘宝内部系统在增长到 100 个以后，在出现线上问题时，已经没有人明确知道是谁的问题并能推动问题得到处理了，这是大公司发展到一定程度就会出现的研发管理问题。幸运的是，当时淘宝有一帮聪明人，在一个运维人员的倡议下，他们建了一个内部群，这个群只能开发人员进入，多事的管理者不能进入。这个群存在的意义在于，它可以绕过一些规定，而快速定位和解决线上问题，而随着能解决的问题越多，也有更多的问题被投放到这个群里，这个群自然而然也变得重要起来</p>
<p>毕玄大佬提到的程序员第二阶段，就是在这样的一个群里成长起来的程序员。想要快速定位和解决问题，除了要先绕过一些腐朽的规定（例如后端的库前端不能访问，生产环境不能随便登录等）以外，更重要的是，要有扎实的计算机基础知识，要有广泛的技术知识积累，还要有敏锐的观察力。</p>
<p>第二阶段或许可以通过故障演练习得，但人为的故障演练的真实性和强度总是差一点；或许也可以通过阅读其他公司的事故报告而增加实践经验，但很少有公司愿意全盘分享自己的濒死经历。</p>
<p>第三个阶段可以通过经历第二经历而成长起来，然后在失败中总结经验，把代码写得鲁棒性更好、性能更好；也可以通过阅读，直接学习牛人总结的最佳实践。</p>
<h2>扁鹊大哥医于未病</h2>
<p>现在看一下《鹖/hé/冠子》世贤第十六篇，魏文王问扁鹊，他兄弟三人谁的医术最高。扁鹊说，他大哥的医术最高，他自己的最差。魏文王诧异，扁鹊解释说：「长兄于病视神，未有形而除之，故名不出于家。中兄治病，其在毫毛，故名不出于闾（lǘ，古代行政单位，周朝 25 户为一闾）。若扁鹊者，血脉、投毒药、副肌肤间，而名出闻于诸侯。」</p>
<p>什么意思？大概是说，他大哥在病还没有爆发的时候，就已经消灭了；他二哥是发现病刚有点苗头，就把病治了；而他自己，总是在病爆发的时候才施手治好。</p>
<p>这可能是扁鹊自谦，不过没有关系，这个故事可以帮助我们理解程序员的三个阶段。如果将扁鹊三兄弟对应于程序员的三个等级，是这样的：</p>
<ul>
<li>扁鹊处于第二阶段，善于定位与解决 Bug；</li>
<li>扁鹊二哥处于第二、第三阶段之间，Bug 还没有机会爆出，就被他重构掉了；</li>
<li>扁鹊大哥是第三阶段，预防 Bug 于写代码之时，所以外面没有人知道他的厉害。</li>
</ul>
<p>我们将程序员划分为三个阶段，而并不是三个等级，因为人的技术水平是会不断进步的。开始的时候是第一阶段，过一段时间可能就是第二、第三阶段了。能进入第一阶段的人，在接触到足够多的生产案例以后，也能步入到第二阶段；到达第二阶段后，稍加总结经验，也能步入第三阶段。或者直接从第一阶段学习最佳实践，先记下来并应用上，有人东西不懂也没有关系，先照做，在实践中慢慢会发现，哦，原来这个地方这么做是这个用意。</p>
<p>对于扁鹊，我更相信，很多时候并不是他不能医于未病，而是很多人病了之后才找他医治。对应于中小公司的开发，不一定是他们不懂得优化，很多时候他们更愿意牺牲性能和鲁棒性，而攫取更多的开发效率，毕竟生存大于一切，时间大于一切。</p>
<h2>面向不同读者群体的内容定位</h2>
<p>当我们开发项目而进行技术选型时，我们应该选择脚本语言，还是应该选择编译型语言？我们应该使用跨平台的多段框架开发产品，还是应该分别在不同平台使用不同的原生技术开发产品？包括我们作者，在撰写相关的计算机图书时，我们应该如何界定一本书的读者群体呢？</p>
<p>这里涉及到两种开发哲学：</p>
<ul>
<li>一，尽快完成，用最快的效率先完成功能；</li>
<li>二，最大程度考虑到性能，将性能和稳定做到极致。</li>
</ul>
<p>对于中小公司，一般就是求快，先完成再说，所以他们倾向于选择脚本语言、选择跨平台的一站式开发框架。对于已经拥有高并发用户的大公司，他们倾向于选择编译型语言，将性能、鲁棒性、稳定性放在第一位考虑。</p>
<p>我们没有必要纠结要选择那种哲学，抛开团队所处的具体处境，而谈策略的选择是没有意义的，在艰难求生阶段，自然一切求快；而到了已经拥有大量用户和订单的阶段，自然求稳。</p>
<p>并且这两种生存哲学也不是矛盾的，团队开始起步的时候选择求快，后续发展起来了再选择求稳，都是正常选择。千万别自个跟自个别扭，在还没有达到温饱的时候就大搞优化；在应该求稳定的时候，又以敏捷开发和小步快跑要求自己，当开发进度和交付结果不如意的时候，又埋怨说：”多想回到刚开始创业的时候，那时候我们 3 小时就发布一个版本。“</p>
<p>呵呵，那个时候应该还可以更快，3 分钟就可以发布一个版本，因为根本没有用户嘛，什么问题都不会显现。联网软件，用户在 1000 个、1 万个、10 万个、100 万个、1000 万个的时候面临的问题是不一样的。所有的资源都是有限的，只有资源消耗大的时候，一些问题才会暴露出来。</p>
<p>当作者在写书时，也没有必要纠结应该选择定位哪一类读者。开发者都是会成长的，今天他们要求快，明天可能就求稳，如果明天他们还活着的话。</p>
<p>在任何时候，考虑任何问题，都应该把当下处境考虑进去，这是辩证法的基本原则。</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
            <category>undefined</category>
        </item>
        <item>
            <title><![CDATA[阿里P10带多少人？]]></title>
            <link>https://yishulun.com/./src/posts/2022/10013.html</link>
            <guid>https://yishulun.com/./src/posts/2022/10013.html</guid>
            <pubDate>Sat, 01 Oct 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>阿里P10带多少人？</h1>
<h2>P10 带多少人？</h2>
<p>一般来说，在阿里 P 是技术系，M 是管理系。但 P 也是带人的，例如阿里 P10 毕玄在<a href="https://time.geekbang.org/column/article/576252">访谈</a>中透露，他在淘系曾带 600 人。我查了一下，其他等级例如 P9 大概带 50~100 人，P8 带 2~30 人。P7 是技术专家/架构师，应该是不带人的。</p>
<!-- more -->
<p>各个技术等级是这样的：</p>
<table>
<thead>
<tr>
<th>等级</th>
<th>职称</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>P5</td>
<td>高级工程师</td>
<td>校招起点</td>
</tr>
<tr>
<td>P6</td>
<td>资深工程师</td>
<td>社招起点，1~3 年工作经验，代码主力</td>
</tr>
<tr>
<td>P7</td>
<td>技术专家/架构师</td>
<td>5~7 年工作经验，代码主力</td>
</tr>
<tr>
<td>P8</td>
<td>高级技术专家</td>
<td>一线最高级别，带 2~30 人</td>
</tr>
<tr>
<td>P9</td>
<td>资深技术专家</td>
<td>有行业影响力，带 50~100 人，可以权衡架构方案利弊</td>
</tr>
<tr>
<td>P10</td>
<td>研究员/科学家</td>
<td>有行业影响力+有影响力的成果，带 100~1000 人</td>
</tr>
</tbody>
</table>
<p>行业影响力一般指有粉丝多的博客/公众号/视频号，出版过技术图书，在维护知名的开源项目等。在这个层次只是走到了技术前沿，但没有走过前沿。</p>
<p>有影响力的成果一般指出版的图书，或开源项目，或其他专利成果等，获得了一定的市场认可，已经走过了技术前沿，已经有创新了。到达 P10，相当于计算机领域没有学位的博士。</p>
<h2>在公司里做事的出发点</h2>
<p>出发点在职场中很重要。公司中总是充满各种矛盾，如果下属与上级之间一直没有分歧与争执，这多半是有问题的，这只是意味着矛盾被忽略或隐瞒了，没有被真正对待和解决。</p>
<p>下属与上级对话，一个很重要的原则是：出发点始终站在公司这边。你可以站在所在团队的立场，与上司谈要求，这种情况有时候能成有时候不能成；你也可以站在事业部或分公司，站在你的上司所在的单位谈，这种情况下也并不能保证 100% 成功；你还可以站在整个公司、整个集团的角度谈，从这个角度可能也不能如愿，但一般不会失败。</p>
<p>程序员个人做事，与在公司里做事的立场是完全不同的。个人开一个开源项目，出发点可以是藉由项目实践完善自己的技术体系，也可以是实现自己的一个技术设想，或者为社会上的一部分人带去实用价值。在公司里做事不是这样的，只有将出发点放在公司这边，才能一直顺风顺水；如果在公司里做事，仍然坚持个人做事的出发点，是早晚会出问题的，很多程序员因为太痴迷于技术，往往无意间忽略了这一点。</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
            <category>undefined</category>
        </item>
        <item>
            <title><![CDATA[为什么编程里习惯使用 i、j、k 等作为循环变量?]]></title>
            <link>https://yishulun.com/./src/posts/2022/0930.html</link>
            <guid>https://yishulun.com/./src/posts/2022/0930.html</guid>
            <pubDate>Fri, 30 Sep 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>为什么编程里习惯使用 i、j、k 等作为循环变量?</h1>
<p>i 可能是 integer 的简写，或者是 int 的简写。有人说是 iterator 的简写，这个有点牵强。早期教材中的示例都是以 i、k、j 作为循环变量，后来这样使用成为了一种习惯。</p>
<!-- more -->
<p>但这种习惯是如何形成的呢？</p>
<p>在 1957 年诞生的 Fortran 编程语言中，有一个「I—N 规则」，规定以字母 I，J，K，L，M，N 六个字母开头的变量，如无另外说明均为整型变量，以其它字母开头的变量则为实型变量。实型变量在这里狭隘理解就是小数，包括指数形式的小数。</p>
<p>Fortran 更多是一种教学语言，后来诞生的 B 语言、C 语言都借鉴了 i、k、j 的命名规则，久而久之成为了习惯。</p>
<blockquote>
<p>关于 I-N 规则，可以查看这里：<a href="https://micro.ustc.edu.cn/Fortran/ZJDing/Sec1-4.htm">https://micro.ustc.edu.cn/Fortran/ZJDing/Sec1-4.htm</a></p>
</blockquote>
<p>Fortran 支持整型、字符型等类型。Fortran 诞生于 1957 年，比 C 语言早了 10 年，很难想象在远古编程语言中，竟然就有了对变量类型的支持。虽然对类型的支持并不是一开始就有的，但也基本发生在 Fortran 诞生之后的几年里。</p>
<p>JS、Python 这样的脚本语言没有变量类型，并不是它们低级，而是在它们的语言哲学里，没有类型更加简洁方便。</p>
<p>编程语言一向有两个发展方向，两种哲学：</p>
<ul>
<li>一，力求简洁，代码编写效率高，脚本语言基本都是这样，例如 Python、JS；</li>
<li>二，力求高性能、安全与稳定，后端编译型语言基本都是如此、例如 Java、C++。</li>
</ul>
<p>一般情况下，我们都会保持这种语言中哲学的纯粹，但有时候我发现我们开发者又很矛盾，例如 JS，它本来是弱类型的脚本语言，当我们在享受它简洁方便的语言特性时，又搞了一个 TypeScript 出来，希望它也像 Java 那样具有强类型的严谨。</p>
<p>就像一个姑娘，有时候希望她泼辣，有时候又希望她文静。</p>
<p>有一个语言，因为诞生的晚，吸收了众多现代语言的优点，既有强类型语言的优点，又有弱类型语言的优点，它就是 Go 语言。</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
            <category>undefined</category>
        </item>
        <item>
            <title><![CDATA[为什么程序员对 Python 有这么多仇恨？]]></title>
            <link>https://yishulun.com/./src/posts/2022/0926.html</link>
            <guid>https://yishulun.com/./src/posts/2022/0926.html</guid>
            <pubDate>Mon, 26 Sep 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>为什么程序员对 Python 有这么多仇恨？</h1>
<p>并不是所有有经验的程序员都讨厌 Python，促使人们产生这种厌恶情绪的原因可能有三个：</p>
<p>1，Py 不能很好地进行 OO 编程。这是由于 Py 诞生太早而决定的，在 Py 诞生的时候，OO 编程思想还没有成熟，经典的设计模式图书 GoF 还没有出版。关于对 OO 编程的支持，Py 3 中已经有所改进，但因为又要向前做一些兼容，还不可避免地戴了「历史的脚镣」。</p>
<p>2，Py 被指是一种「石头汤」，像一个众人贡献的大杂烩，没有计划，没有规划，像是野蛮生长而成的。这是由它的生存哲学所决定的，Py 没有「我执」，开发者需要什么，它就添加什么；社区贡献什么优良的类库，它就吸纳什么。正是这种「海纳百川，不舍涓流」的精神，让 Py 存在了这么多年，为这么多人所使用。</p>
<p>3，Py 没有严格的静态类型。但这是它的缺点，同时也是它的优点。是灵活？还是严谨？对于脚本语言，取灵活就好了，否则还不失去了脚本语言的本色？至于严谨，是后端编译类语言应该考虑的事情。</p>
<p>结论：Py 是一门非常值得学习的脚本编程语言。</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
            <category>undefined</category>
        </item>
        <item>
            <title><![CDATA[二极管工作原理]]></title>
            <link>https://yishulun.com/./src/posts/2022/0913.html</link>
            <guid>https://yishulun.com/./src/posts/2022/0913.html</guid>
            <pubDate>Tue, 13 Sep 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>二极管工作原理</h1>
<blockquote>
<p>数字信号纯粹是给我们人类阅读和理解用的，在计算机的物质世界里，就是不同的具象化形态。这和我们人类的「意识」很像，人到底有没有意识？人的意识就像计算机世界的数字信号一样，其实是不存在的。当医生把死人的大脑打开的时候，和我们把磁盘打开看到的东西是一样的，什么也没有。</p>
</blockquote>
<p>二极管的工作原理是什么？</p>
<p>还有这三个问题：</p>
<ul>
<li>机器指令（整数）是如何转换成高低电平，从而被硬件识别？</li>
<li>计算机最底层的机器语言是如何变成物理电平信号输给 CPU 的呢？</li>
<li>程序里 0 和 1 是怎么转化成高低电平的？（最初的受 0 和 1 控制的高低电平如何产生的）？</li>
</ul>
<p>这三个问题本质上是一个问题，并且，和二极管的工作原理是密不可分的。</p>
<!-- more -->
<h2>什么是半导体？</h2>
<p>首先看一个物理概念，什么是半导体？</p>
<p>能导电的，材料中有自由电子可以流动的，是导体，例如铜线、铝线；反之，不能导电的叫非导体，或者叫绝缘体，例如包裹在手机充电线外层的塑胶，没有这层塑胶，我们可能都无法给手机充电。</p>
<p>自然界的物质，除了导体、绝缘体，剩下的就是半导体。半导体源于材料的导电性质会发生变化，例如硅（Si）、锗（Ge）及砷化镓（GaAs）等，它们的原子会随着温度的升高，而出现易于移动的价电子，从而具有导电性。</p>
<p>半导体按物质是否纯粹还可以分为本征半导体和杂质半导体。高度提纯的硅（Si）便是本征半导体。硅具有稳定的 4 阶电子，在本征半导体中加入一些 3 阶电子物质（例如铟或铝），或 5 阶电子物质（例如磷），便变成了杂质半导体。</p>
<p>CPU 是计算机的核心部件，它的主要生产原料是高度提纯后的硅，这种原料在自然界并不存在，为了得到它，人类必须将海滩上的沙子一遍一遍煅烧，才能得到它。然而在得到高纯度的硅以后，还要想办法掺入一些杂质，使它变得又不纯粹了。提纯与掺杂，都是为了同一个目的：制造晶体管半导体电子元件。</p>
<p>晶体管包裹二极管、三极管、场效应管等多种类型，原理是类似的，可以从二极管上理解它们。那么一个二极管是怎么构成的？它的原理是什么呢？</p>
<h2>二极管的构成</h2>
<p>如下所示，一个经典的二极管从左到右由正极（导电金属）、P（Positive）型半导体材质区、PN 结、N（Negative）型半导体材质区和负极（导电金属）组成。</p>
<img src="./assets/image-20220913202855289.png" alt="image-20220913202855289" style="zoom: 50%;" />
<p>图 1</p>
<p>正极和负极都是导电金属。P 和 N 是两种杂质半导体。PN 结不是一种材质，或者说不是人为制造的材质，它是由 P、N 两种材质连在一起时，自然形成的。图示中 PN 结看起来很宽，事实上它非常窄。在二极管中同时使用 P、N 两种杂质半导体就是为了产生 PN 结。PN 结是电子计算机最原始的物质基础，没有 PN 结就没有电子计算机。</p>
<p>如下所示，这是现实世界中的二极管。后两个像灯泡一样，它们还可以发光，本质上它们还是二极管，只是在二极管有电流通过时可以亮起来而已。</p>
<img src="./assets/image-20220913203330556.png" alt="image-20220913203330556" style="zoom:50%;" />
<p>图 2</p>
<h2>二极管的工作原理是什么？</h2>
<p>下面看二极管的工作原理。</p>
<p>平衡是一种美，尤其在物理世界中，物体或材质总是尽力想办法保持平衡。例如电，电是怎么产生的？本质上是电子的移动对不对。那电子为什么要移动？还不是因为一边的物质缺少电子，另一边的物质自由电子太多，从而发生了自由电子的移动。可以自由移动的电子有时也称作载流子，两边物质载流子的浓度相差越大，电压就越大，电流就越大。这是一种简单的对电的理解，稍后对我们理解二极管有帮助。</p>
<p>下面我们看二极管。</p>
<img src="./assets/image-20220913205202322.png" alt="image-20220913205202322" style="zoom: 15%;" />
<p>图 3</p>
<p>P 型区的材质因为人为地注入了 3 阶电子的物质（例如铟），从而拥有更有可以容纳自由电子的空穴；而 N 型区的材质因为人为地注入了 5 阶电子的物质（例如磷），从而拥有更多自由电子。但是请注意，虽然 P 型区拥有空穴，及 N 型区拥有电子，他们本身都是电中性的，他们本身并没有使用羊毛毡或玻璃棒摩擦过，它们本身是不带电的。</p>
<p>当它们接触到一起的时候，在它们接触的截面，发生了一些电子移动。如下所示：</p>
<img src="./assets/image-20220913210031426.png" alt="image-20220913210031426" style="zoom:33%;" />
<p>图 4</p>
<p>右边是 N 型区，左边是 P 型区。在截面处，N 型区的电子会跑到 P 型区，从而让 P 型区截面处的物质带上负电荷，而截面处失去电子的 N 型区物质则会带上正电荷。根据电的一般定义，电场的方向总是从正电荷区域指向负电荷区域，所以在截面处，有一个从右向左的内电场。</p>
<img src="./assets/image-20220913210521056.png" alt="image-20220913210521056" style="zoom:25%;" />
<p>图 5</p>
<p>但是，N 型区的电子为什么没有一直、全部移向 P 型区呢？这可以从两个方面理解：</p>
<p>1）如果全部移过去了，那么内电场的电压将达到最大，根据物理世界万物都追求平衡的道理，这种没有地方释放的电压是不可能存在的。</p>
<p>2）继续看上面的图 4，P 型区的正载流子浓度（红色）从左向右是降低的，相反，N 型区的负载流子浓度（蓝色）从左向右是升高的，两条线在中间，也就是 PN 结的中间，达到了平衡，或者说相等。截面处载流子达到平衡了，电子也就没有移动的必要了。</p>
<p>在自然状态下，PN 结达到平衡的状态下，PN 结的宽度有多少，本质上取决于 P 型区和 N 型区它们注入的杂质的原子性质及浓度。有的地方写，二极管导通的临界电压是 0.7V，为什么是 0.7V？这与注入的杂质有关，这 0.7V 的电压要克服内电场做功。</p>
<h3>正向偏置和反向偏置</h3>
<p>正向偏置和反向偏置这两个概念很容易混淆，我们只需要记住二极管在正向偏置下是导电的就可以了。如下所示，这是正向偏置的示意图。</p>
<img src="./assets/image-20220913212544942.png" alt="image-20220913212544942" style="zoom:33%;" />
<p>图 6</p>
<p>整个电路在外电场的作用下，出现了顺时针方向的电流。电流方向与带负电的电子的运动方向是相反的，在二极管的管体内，电子在外部电场的作用下，会持续从 N 型区跑到 P 型区。此时二极管会有一些热量产生，这些热量是外电场克服内电场而做的功。</p>
<p>在正向偏置下，二极管中是有电流通过的，如果二极管是发光二极管，将有亮光出现。反之，在反向偏置下，如下所示，外电场方向在管体内，与内电场方向重合了，此时 PN 结变宽了，二极管处于非导通状态。</p>
<img src="./assets/image-20220913213507547.png" alt="image-20220913213507547" style="zoom:25%;" />
<p>图 7</p>
<h3>伏安特性曲线</h3>
<p>如果我们考察二极管中的电流大小，在正向偏置和反向偏置中的变化，可以得出一条伏安特性曲线，如下所示。</p>
<img src="./assets/image-20220913161058655.png" alt="image-20220913161058655" style="zoom:50%;" />
<p>图 8</p>
<p>在这条二维曲线中：</p>
<ul>
<li>蓝色表示正向偏置下，正向导通的状态；</li>
<li>红色部分表示即将被导通的状态；</li>
<li>绿色为反向偏置下，反向饱和电流的状态；</li>
<li>黄色表示 PN 结被击穿的状态，电流又变得负向无穷大了。</li>
</ul>
<h3>什么是二极管的击穿态？</h3>
<p>在反向偏置下，虽然内外电场的方向在管体内是相同的，但当外部电压大到一定程度后，大到中性粒子分离出价电子的程度了，这时候二极管变成了一根导线了，内部小电场丝毫起不到任何的阻滞作用了。</p>
<p>所以，无论是手机，还是电脑，都有一个适用的最大电压和最小电压。电压太小了带不动，太大了主板又可能被击穿，俗称「烧坏」了。超负荷做功产生大量的热，有时候甚至能闻到绝缘体烧糊的味道。</p>
<h2>电信号怎么转化为数字信号？</h2>
<p>二极管通电与不通电，其实是一个开关，是电信号。</p>
<p>有了二极管，就可以设计各种逻辑门电路了，例如与门电路：</p>
<img src="./assets/image-20220913215303022.png" alt="image-20220913215303022" style="zoom:33%;" />
<p>图 9</p>
<p>它由两个二极管组成，只有 A 与 B 同时都处于导通，也就是正向偏置的状态，L 端才有输出，否则没有输出。注意上方的 R 是一个电阻，电流是不会往这边跑的。</p>
<p>下面这个是或门电路：</p>
<img src="./assets/image-20220913215722311.png" alt="image-20220913215722311" style="zoom:33%;" />
<p>图 10</p>
<p>A 与 B 只要有一个输入，L 端就有输出。</p>
<p>还有其他的逻辑门电路，都可以基于二极管实现。基本的逻辑门电路又可以组成基本的计算模块，例如半加器、全加器等。除了加法器，还有乘法器、除法器、减法器，都可以基于逻辑门电路实现。</p>
<p>如下所示，这是一个两位加法器的示意图：</p>
<p><img src="./assets/two-bit-adder-using-full-adder.png" alt="两位加法器, 使用全加器"></p>
<p>图 11</p>
<p>注意输入和输出都在下方。当输入是 11（3）和 01（1）时，输出是 100（4）。输入相同，输出必定相同。</p>
<p>现在，我们思考终极问题：电信号是怎么转化为数字信号的？</p>
<p>其实压根就没有转化，所谓的数字信号（0110 这种）只是我们人类便于自己理解所发明的一种描述。二进制和这个世界上存在的英语、汉语一样，它们只是我们人类具象化的符号而已。</p>
<p>以我们敲击键盘为例，当我们敲击字母 A 时，产生的 ASCII 码是 65，它的二进制是 1000001，在计算机中就是 1 个高电平+5 个低电平+1 个高电平。这个数据（1000001）如果存在 CPU 的寄存器里，就是一些电子元件的基本状态；如果存在磁带或者磁盘里，就是一些磁信号，那里有什么数字信号？</p>
<p><strong>数字信号纯粹是给我们人类阅读和理解用的，在计算机的物质世界里，就是不同的具象化形态。这和我们人类的「意识」很像，人到底有没有意识？人的意识就像计算机世界的数字信号一样，其实是不存在的。当医生把死人的大脑打开的时候，和我们把磁盘打开看到的东西是一样的，什么也没有。</strong></p>
<h3>数字信号在计算机内是如何暂存的？</h3>
<p>前面我们谈到的都是计算用的电子元件，例如加法器、乘法器等。计算后的结果，在计算机内是如何保存的呢？例如在 CPU 的寄存器内，是如何保存的？</p>
<p>这涉及到触发器元件。以 D 触发器为例，它用于存储一位（0 或 1）数据，它可以做到，无论输入电平是高电平还是低电平，它的输出值保持不变，这是它的元件特性。而触发器也需要能够存储值，它存储的值也需要能够改变，这是怎么做到的呢？</p>
<img src="./assets/image-20220913224100423.png" alt="image-20220913224100423" style="zoom:33%;" />
<p>图 12</p>
<p>电平的状态不止有低、高两种。电平从低电平跃升到高电平，这叫上升沿；反之从高电平下降到低电平，这叫下降沿。上升沿和下降沿的时机也可以被电子元件捕捉。以 D 触发器为例，依据边缘触发时机的不同，可以分为 上升沿 D 触发器 和 下降沿 D 触发器。D 触发器可以在特定时机改变它存储的值。</p>
<h3>计算机内的高低电平是怎么产生的？</h3>
<p>是不是存在一个不停吹哨子的「人」？其实没有。计算机启动时，从指定的内存地址启动，启动以后就开始不停地执行二进制指令。系统及程序的指令，就是计算机的「心跳」，由于每台计算机执行一个基本指令所需的时间是固定的，看起来不停运行的计算机就像有节拍、有心跳一样，其实并没有。</p>
<h2>相关问题</h2>
<h3>二极管正负极如何判定？</h3>
<p>人类在生产的时候做了一些规定。</p>
<p>1）一般有色环的为负极，有白线的一端为负极。</p>
<p><img src="./assets/1-1P3200914212Z.png" alt="二极管正负极"></p>
<p>图 13</p>
<p>2）对于发光二极管，引脚长的为正极，短的为负极。</p>
<p><img src="./assets/1-1P32009144S10.png" alt="发光二极管正负极"></p>
<p>图 14</p>
<p>3）发光二极管管体内部金属极较小的是正极，大的片状的是负极。</p>
<p><img src="./assets/1-1P320091610515.png" alt="二极管正负极判断"></p>
<p>图 15</p>
<p>4）看图示，竖杠一端为阴极（负极），三角一端为阳极（正极）。三角是一个箭头，箭头指向的方向是电流的方向，在电的一般定义中，电流与正电荷的方向一致（虽然没有正电荷，移动的只有反方向的带负电的电子）。</p>
<img src="./assets/image-20220914071136424.png" alt="image-20220914071136424" style="zoom:50%;" />
<p>图 16</p>
<h3>什么是二极管思维？</h3>
<p>是一个讽刺比喻。思想偏激，非黑即白，不能辩证地、客观地看待问题。看待事物的观点比较单一，自带立场，只认为与自己立场的观点是正确的，其他的都是错误的。没有独立人格和独立思维意识。</p>
<h2>送一张畅学卡</h2>
<p>最后，说一个与二极管无关的小事。中秋节的时候，极客时间送了我一些畅学卡，相当于是一个临时会员，可以免费学习上面的付费课程。还剩几张，如果对你有用，你想体验，私信我发给你。先到先得，发完为止。</p>
<img src="./assets/image-20220914072459721.png" alt="image-20220914072459721" style="zoom: 50%;" />
<p>图 17</p>
<p>没有想到，到现在还没有送完。不知道是朋友们以为没有用，还是以为早已经送完了。好在截止 2023 年 9 月前有效，一时半会不会过期。</p>
<p>2022 年 9 月 13 日</p>
<p>参考链接</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=WbcUw9kXEw0">https://www.youtube.com/watch?v=WbcUw9kXEw0</a></li>
<li><a href="https://www.jianshu.com/p/8d5e901271a7">https://www.jianshu.com/p/8d5e901271a7</a></li>
<li><a href="https://zh.wikipedia.org/zh-sg/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7">https://zh.wikipedia.org/zh-sg/数字信号</a></li>
<li><a href="https://xiaogd.net/book/spcp/multi-bit-adder/two-bit-binary-adder.html">https://xiaogd.net/book/spcp/multi-bit-adder/two-bit-binary-adder.html</a></li>
<li><a href="http://www.highfel.com/jishu/396.html">http://www.highfel.com/jishu/396.html</a></li>
</ul>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
            <category>undefined</category>
        </item>
        <item>
            <title><![CDATA[节日填词一首：⽔调歌头・2022中秋数字化展望]]></title>
            <link>https://yishulun.com/./src/posts/2022/0910.html</link>
            <guid>https://yishulun.com/./src/posts/2022/0910.html</guid>
            <pubDate>Sat, 10 Sep 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>节日填词一首：⽔调歌头・2022中秋数字化展望</h1>
<h2>⽔​调歌头・2022中秋数字化展望</h2>
<p><img src="./assets/640.jpeg" alt="月球灯"></p>
<p>时代有需要，数字必超前。未来钻石年代，何事会翻番？姣月朝朝高挂，墨客年年作雅，恒变是真言。</p>
<p>命运眷过甚？参照有前篇。慕高士，追大佬，站前沿。不应陷入，娱乐知识的狂欢。人有沉浮兜转，月有阴晴寒暖，有事往前看。但行教之道，桃李满天边。</p>
<!-- more -->
<h2>数字化时代随想​</h2>
<p>2021年，我国发布了「第14个五年计划和2035远景⽬标纲要」及「⼗四五数字经济发张规划」。</p>
<p>⽂件指出，国家在未来13年内，要⼤⼒发展数字化产业，⼤⼒推进全⾏业全⽅⾯数字化深度改⾰，将数字化夯实为⼀项起跑线能⼒。其中软件和信息技术服务⾏业，从2020年到2025年，5年之间要实现产业规模翻倍增长。</p>
<p>我们可以这样理解，未来科技⾏业，尤其是软件和信息技术服务⾏业，是未来13年内的黄⾦钻产业，它值得所有仁⼈志⼠为此前仆后继。</p>
<p>物竞天择，适者⽣存，在快速变化的时代洪流中，有⼀些⼈注定将被时代抛弃，同时另⼀些⼈将被时代眷顾。天上明⽉⾼挂，⼏千年来，年年有⼈看到它，对着它赋诗填词。变得是⼈，不变的是⽉亮，还有亘古不变的「变化」的道理。</p>
<p>谁会受到眷顾呢？回顾上⼀个世纪70、80年代，美国的盖茨、基尔代尔、乔布斯和肯·汤普森这些⼈的事迹，见上⼀篇⽂章：比尔盖茨到是一个怎么样的人？如果你是基尔代尔，面对微软的商业竞争你会怎么做？</p>
<p>⽆论是做学者稿研究，还是经商在科技⼤潮中乘风破浪，他们都⾛在了时代前沿。今天如果你也想在科技浪潮中有⼀番作为，必须⾛在时代的科技前沿。</p>
<p><img src="./assets/640.png" alt="图片"></p>
<p>怎么才能⾛在时代前沿呢？</p>
<p>要关注前沿的⽜⼈他们在做什么，他们在说什么，他们在看什么。有⼀个组织，它是⼀个把各⾏各业⽜⼈聚集起来的组织，你不必到处找⽜⼈，也不必因为找到了以后⽜⼈不理你⽽苦恼，你只需要关注这个组织就可以了。</p>
<p>这个组织⼀直都在聚集⽜⼈，并积极组织⽜⼈发声。再也不要沉迷于娱乐视频、情绪泛滥的⾃媒体信息、⼼灵鸡汤和娱乐知识的狂欢之中了，这样的组织才是真正值得你花时间关注的，如果你还没有退休的话。</p>
<p>另外还有⼀个平台，它针对这⼀时代契机，发布了结构完备的数字⼈才粮仓模型，指出了时代的数字化需要。</p>
<p><img src="./assets/640-20220911075115707.png" alt="图片"></p>
<p>如果你想参与数字化时代变⾰，关注这个组织的账号，学习⽜⼈的视⾓，在这个平台上学习⽜⼈的经验，这样就可以了。</p>
<p>我作为⼀名普通的程序员，很早⼀直也是这么做的，后来我成为了这个组织中的⼀员，也有幸在这个平台上发布了⾃⼰的课程。</p>
<p>现在我作为⼀名计算机⽼师，已经开始为国家培养软件和信息技术服务⼈才⽽努⼒，我专注的路径是：通过BPL实战教学思想，在⼀个项⽬中传授⼀个整体的职业发展道路上所需的基本技能，快速培养数字化转型⼈才和新型⼈才。</p>
<p>最后说⼀下上⾯提到的组织和平台，她们是腾讯云TVP和极客时间。</p>
<p>当然国内优秀的软件和信息技术学习平台不⽌有极客时间，还有⽼牌的CSDN和发展势头猛劲的51CTO，她们也是⾮常优秀的程序员社区与平台。</p>
<ul>
<li><a href="https://csdn.net/">https://csdn.net/</a></li>
<li><a href="https://www.51cto.com/">https://www.51cto.com/</a></li>
</ul>
<p>下⾯，根据上⾯的随想，即兴填词⼀⾸，见开头。</p>
<p>最后说一下封面，这是腾讯云TVP组织<br>
寄送的中秋节&amp;教师节礼物。非常漂亮，有三个色可以变换。设计也非常简洁，触摸式开关，可充电，也可离电单独使用。</p>
<p>2022年9月10日</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
            <category>undefined</category>
        </item>
        <item>
            <title><![CDATA[基尔代尔是如何错失操作系统市场的？]]></title>
            <link>https://yishulun.com/./src/posts/2022/0909.html</link>
            <guid>https://yishulun.com/./src/posts/2022/0909.html</guid>
            <pubDate>Fri, 09 Sep 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>基尔代尔是如何错失操作系统市场的？</h1>
<p>基尔代尔果然是一位学者企业家。他有企业家的敏锐嗅觉和欲望，但同时又保留了学者的锐意创新和儒雅。他一只脚踏在了商业领域，另一只脚踏在了学者领域，只有他这样的人，才能开发出符合市场需要的CP/M，肯·汤普逊和比尔·盖茨都不可以。</p>
<p>如果你是当年的基尔代尔，面对微软的商业竞争你会怎么做呢？</p>
<p>这个问题应该没有什么标椎答案。笔者阅读了一些相关资料，有人说基尔代尔博士是一位计算机发展史上完全被低估贡献的极客，还有人说钱是万能的，历史的小姑娘被人打扮了，比尔·盖茨在他的著作《未来之路》中刻意将卖给他QDOS（一个DR-DOS的变种）的蒂姆·帕特森捧了出来，淡化了基尔代尔在DOS系统发展史上的贡献。甚至称通过抄袭赚了7.5万美元的蒂姆·帕特森为「DOS之父」，天哪，哈哈，如果蒂姆·帕特森是DOS之父，那么基尔代尔博士在历史上又做了什么？</p>
<!-- more -->
<p>对此我有不同的看法。历史是一个小姑娘，谁都可以打扮，既可以往左打扮，也可以往右打扮；比尔·盖茨的书不可以全信，但借此批评比尔·盖茨的文章也未必值得全信。基尔代尔博士在DOS发展史上的贡献毋庸置疑，盖茨在《未来之路》中的叙述确实也有失大方，但我想说的是，这里面已经发生的事，有各自的缘由，这些对我们都不重要，重要的是我们从这段历史中能得到什么启示？</p>
<h2>三点启示</h2>
<p>读史使人明智，基尔代尔博士为什么没能创建一个微软？微软的商业模式在当时为什么可以如此成功？这里面至少有3点启示：</p>
<ul>
<li>一，一定要开放，Unix于1969年就被开发出来了，但它却没有比7年后，1976年诞生的MS-DOS的前身——CP/M获得更多的用户市场；</li>
<li>二，一定要重视生态，IBM的OS/2 Wrap系统不比微软的MS-DOS系统做的好吗？当然不是，只因为微软先发制人，占领了市场先机，致使后来者即使再优秀也不能取而代之；</li>
<li>三，一定要有一个好的商业模式。在微软还没有起飞之前，基尔代尔博士的DR（Digital Research，数字研究所）公司在微机市场占有最大的市场份额，这种情况下为什么微软还可以发展起来？微软的商业模式既保持了生态上的开放性，在开放的同时又最大化保护了自己的利益。微软的操作系统是与硬件绑定的，厂家每卖出一个电脑，微软就会自动卖出一个系统。</li>
</ul>
<h2>计算机系统的进化史</h2>
<p>为了了解微软为什么可以崛起，我们有必要先梳理一下计算机系统的发展史。</p>
<h3>开关编程</h3>
<p><img src="./assets/d3961aa12c60423ba5fc926167ae59da.jpeg" alt="第一台计算机ENIAC"></p>
<p>1946年，为给美国陆军的弹道研究实验室（BRL）计算火炮火力表，世界上第一台图灵完备的电子通用计算机ENIAC诞生了，开始它还没有操作系统。那个时候它就是一台北京三室一厅那么大的电子计算器，计算机小姐（Computer Lady，是真正的小姐，有知识有文化）需要在ENIAC上手动拨动开关，以进行编程，就像在计算器上按键一样。</p>
<p><img src="./assets/bVbp01T.png" alt="有很多控制开关的插线板"></p>
<p>靠手动拨动开关进行编程的效率肯定低了，也容易出错。</p>
<h3>第一台家用计算机阿塔尔8800</h3>
<p>1974年面世的阿塔尔（Altair）8800，如下所示，它由美国微型仪器和遥测系统（MITS，Micro Instrumentation and Telemetry Systems）公司，基于Intel 8080微处理器实现，它是第一款取得商业成功的家用计算机。当时还在哈佛读书的比尔·盖茨与其小伙伴保罗·艾伦一起为Altair 8800设计了Altair BASIC编辑器，这款编译器后来变成了Microsoft BASIC，成为了MS-DOS系统的基础，后来又变成了Microsoft QuickBASIC，最后成为了今天依然流行的Visual Basic。Microsoft在命名上也以Micro开头，可能收了MITS的影响。包括比尔·盖茨退学创建微软，也可能与这次成功的外包经历有关。注意这个时间，1974年，比基尔代尔博士发布CP/M，还有二年时间。</p>
<blockquote>
<p>注意：BASIC并不是比尔·盖茨设计的，最原始的BASIC语言是在1964年由约翰·克米尼和Thomas E. Kurtz设计的。</p>
</blockquote>
<p><img src="./assets/image-20220909094859582.png" alt="image-20220909094859582"></p>
<p>阿塔尔8800虽然是一课家用计算机，但要给他编程并不容易，要拨动面板上的开关，靠输入二进制操作码输入数据（一堆0和1），然后按「存储键」把临时值写入内存。注意，这时候计算机已经有了内存了。</p>
<p>待到把整个程序都写入内存后，推动开关，内存地址重设为0，按「运行」按钮，灯闪烁起来，阿塔尔就开始运行了。下一次如果要计算别的什么，重新再来一遍开关编程，阿塔尔与其说是一个电脑，不如说是一个大玩具。</p>
<h3>打孔机编程</h3>
<p>人们或许从早期可编程纺织机上获得了灵感，发明了打孔机，专门给纸卡打孔。开关只有两个状态，不是0就是1，上机前先在纸带上把要输入的0、1数据准备好，等计算机空闲了，拿纸卡往读卡器一插就可以了。用打孔机编程，不仅提高了计算机的利用效率，还减少了出错率。</p>
<p>IBM在1964年推出的IBM 029打孔机是当时打孔机的代表，如下所示：</p>
<p><img src="./assets/image-20220909115241230.png" alt="image-20220909115241230"></p>
<p>IBM 029是作为IBM System/360 大型电脑的配件而发售的，用IBM 029打出一种一种打孔卡，如下所示：</p>
<p><img src="./assets/v2-d9b371ac94c464645d1ad7a6f31457a9_1440w.jpg" alt="img"></p>
<p>将这种打孔卡插入IBM System/360，计算机就可以自动输入数据，已经不再需要波动开关了，计算机小姐们觉得太幸福了，此时离1946年ENIAC诞生已经过去了18年。</p>
<p>ENIAC作为第一台图灵完备的电子计算机，后来它其实也是有打孔机和读卡器的，如下所示，在房间位置的下方，放置的便是读卡器和打卡机，而上方及左右两侧都是计算模块，最多的是累加器。区别是什么？ENIAC是军用的，而IBM 026和IBM System/360是商用的。</p>
<img src="./assets/image-20220909115909656.png" alt="image-20220909115909656" style="zoom: 50%;" />
<h2>编程语言的进化史</h2>
<p>编程语言在计算机的发展中，起到了决定性的作用。如果不是编程语言作为工具可以持续创新，计算机不会发展的如此迅猛。</p>
<h3>助记符和汇编语言A-0（1952）</h3>
<p>打孔机编程有一个问题：不支持循环和跳转。如果某段机器码想要再执行一遍，计算机小姐们必须将纸带环过来，再输入一遍。</p>
<p>还有，在使用打孔机制作纸卡时，科学家们往往会事先把要输入的机器码内容写在纸上，这也很好理解，因为谁也不可能把成百上千张数据全部记在脑子里。而为了记述和理解方便，往往会在机器码旁边写上助记符。举个例子：</p>
<pre><code class="language-shell">0010 1110 # LOAD A
</code></pre>
<p>这段机器码0010是操作吗，1110是数据吗，整段表示将内存中的值复制到寄存器A。行尾的LOAD A就相当于是助记符。在打卡机编程时代，计算机小姐输入的是0010 1110这样的机器码，并不是LOAD A这样有自然语义的助记符。</p>
<p>这时候有一个聪明的第一代计算机小姐葛丽丝·霍普（Grace Hopper）博士，她想，既然有助记符，为什么还要写机器码呢？人类通过键盘（当时早已经有打字机键盘了，打字机的出现比计算机早）向计算机输入助记符，先存在内存里（当时图灵完备的计算机也已经有内存了），然后由计算机负责将助记符翻译为机器码，翻译以后再运行，这样不比直接写和输入机器码更高效吗？</p>
<p><img src="./assets/image-20220909124611282.png" alt="葛丽丝·霍普"></p>
<p>这是一个了不起的想法，葛丽丝·霍普据此实现了算术语言版本 0（Arithmetic language version 0），简称A-0，或称A语言。A语言已经是一个汇编语言了。A-0之后还出现过A-1、A-2、A-3等，或许由于理念太先进，或许因为配套设备不齐全，A语言并没有流行起来。这一年是1952年。</p>
<h3>FORTRAN（1957）</h3>
<p>几年以后，IBM 在 1957 年发布了公式翻译程式语言FORTRAN，它的名字是英文Formula Translation的简写，如下所示是一个Hello World示例。</p>
<pre><code>Program main
Implicit none
write(*,*) &quot;Hello World!&quot;
End program main
</code></pre>
<p>FORTRAN的开发者想，既然计算机可以翻译，并且要这样做，那么为什么不做的更彻底一些呢？于是FORTRAN的语法相比A语言，更易读、易懂，它是第一门面向过程的有函数和变量支持的编程语言，FORTRAN主宰了早期的计算机编程。</p>
<p>FORTRAN以后，计算机编程语言开始了长足发展。</p>
<h3>COBOL（1960）</h3>
<p>1959年5月，美国国防部委托葛丽丝·霍普博士制定COBOL语言标准。霍普为了A-0奔走演讲多年，在FORTRAN语言发布之后，终于得到了世人的重视。但霍普实际上并不是COBOL的编写这，当时有一个6人的编写小组，他们把自己关在一个酒店里，基于霍普已有的工作基础，两周时间完成了COBOL首版的开发。这大概是人类历史上有记载的最早的封闭式开发。</p>
<h3>BASIC（1964）</h3>
<p>1964年，达特茅斯学院的两位教授约翰·克米尼和Thomas E. Kurtz，推出了BASIC语言。这个语言没有FORTRAN和COBOL强大，它主要作为教学使用。1977年主动从哈佛退学的学生比尔·盖茨，自然是可能知道和学习过这门语言的。</p>
<h3>B语言（1969）</h3>
<p>大约1969，美国贝尔实验室的计算机科学家──肯·汤普森，如下所示，他想在Unix系统上开发一个Fortran编译器，后来因为在编写过程中引进了另一种编程风格，改着改着，就形成一们新语言——B语言。B语言在命名上是为了向A语言致敬，以表达谦逊之情；我们周围有些程序员不是这样，在别人某个东西的基础上搞了点东西，就命名为某+，或者某Pro、某Super，总是标榜高出别人许多。</p>
<p><img src="./assets/image-20220909135726068.png" alt="肯·汤普森"></p>
<p>Unix系统也是在这一年开始开发的。</p>
<h3>Unix系统与C语言（1969-1973）</h3>
<p>大概在1969年至1973年间，贝尔实验室的丹尼斯·里奇与肯·汤普逊，以B语言为基础，当时他们为了移植与开发UNIX操作系统，还有玩一款游戏，无意中设计和开发出了C语言。如下所示是一个C语言版本的Hello World程序示例：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
int main(void) {
    printf(&quot;Hello, world!\n&quot;);
    return 0;
}
</code></pre>
<p>当时贝尔实验室有一台PDP-7计算机，如下所示。肯·汤普逊是一为当之无愧的计算机大佬，他在1966年写过一款名字叫Space Travel的游戏，估计是使用FORTRAN编写的。他先是为了在闲置的PDP-7上玩这款游戏，想写个高效的FORTRAN编译器，不小心发明了B语言。</p>
<p><img src="./assets/image-20220909132927113.png" alt="PDP-7，由迪吉多公司研发的一款迷你电脑，1965年上市"></p>
<p>后来新的编译器完成了，B语言也有了，仍然对游戏的流畅度不满意。于是，开始重写PDP-7的系统，即Unix系统，并在这个重写的过程当中，和他的同事丹尼斯·里奇一起，发明了C语言。</p>
<p>大神的创造力真不是盖的，没有游戏，写一个，没有趁手的编程语言，写一个，操作系统不高效，写一个。在大声眼里，语言和系统一样，都是工具，都是可以随手打造的。</p>
<p>Unix系统诞生的时间大概在1970年。</p>
<h2>操作系统的进化</h2>
<p>基尔代尔在现代磁盘操作系统的发展上确实功不可没，他通过DR公司在商业上赚了不少钱，这与他早期积极编写程序并尝试卖给Intel有关，他因次洞悉到了更多的前沿需求。</p>
<h3>基尔代尔创造PL/M编写CP/M（1973-1974）</h3>
<p>Unix系统诞生这么早，为什么没有发展起来呢？</p>
<p><img src="./assets/image-20220907202223449.png" alt="image-20220907202223449"></p>
<p>原因大概有两个：</p>
<ul>
<li>两位作者是实验室的研究员，对商业化运作不敢兴趣，只对写游戏、玩游戏感兴趣；</li>
<li>Unix系统是封闭的，不具有开放的生态，没有快速发展的土壤。</li>
</ul>
<p>1972年，基尔代尔博士（如下所示）偶然在华盛顿大学公告板上看到一则二手出售广告，有人以25美元的价格卖一台装备英特尔4004微处理器的微机。基尔代尔买下了它，相比300万美元的IBM 360计算机，这台微机实在太便宜了。</p>
<p><img src="./assets/013.png" alt="加里·基尔代尔"></p>
<p>与肯·汤普森不同，基尔代尔对赚钱感兴趣，他与几名程序员为4004编写了一个游戏程序，他们找到英特尔的老板罗伯特·诺伊斯推销这个程序。英特尔不感兴趣，诺伊斯深信微处理器的未来在其他方面，当基尔代尔问他在什么地方是，他认真地说：“可能在钟表方面。”</p>
<p>不过英特尔发现基尔代尔有出色的数学程序编程能力，于是邀请他到英特尔参观，并请他担任顾问。1973年，基尔代尔应邀参观了英特尔的微机部。基尔代尔与英特尔的人很投缘，他用每周一天的休息日在这里担任顾问。基尔代尔很喜欢这个新职务，也迷上了微处理器。</p>
<p>不久英特尔让基尔代尔试用新出炉的8008，只用了几个月，基尔代尔就创建了计算机历史上具有革命性意义的高级结构性汇编语言PL/M（Programming Language for Microcomputers的简写，中文微机程序设计语言，1972年创建），并用该语言在1974年编写了微型计算机操作系统CP/M（Control Program for Microcomputers的简写，中文微机控制程序）。注意这里的CP/M是程序，并不是系统，因为在当时的人眼里，系统是不存在的，所谓的CP/M就是一个大程序。</p>
<p>基尔代尔随后开始为8080微处理器开发PL/M的不同版本，8080芯片取代了8008，并成为微型计算机革命的真正开始，后来出现了耳熟能详的80386、80486等微处理产品。</p>
<h3>CP/M的意义在哪里？</h3>
<p>以往，计算机的硬件和软件是分开的，普通人即使购买了Intel 4004或8080的微处理器，也无法直接使用，微处理器必须装在一个计算机内，并且这个计算机内还要预装一个专用的计算机系统才能使用。而在当时1973年，像贝尔实验室的Unix系统、IBM的OS/360系统都是封闭的，普通人是拿不到的。基尔代尔的CP/M，就是Intel微处理器的一个软件系统，有了这个系统，任何人都可以基于Intel微处理器做定制开发。</p>
<p>这个时期出现了很多极客，他们喜欢自己动手DIY自己的电脑，同时期的微软联合创始人保罗·艾伦，还有苹果的联合创始人史蒂夫•沃兹尼亚克，都是这时期开始玩电脑的，包括比尔•盖茨也是。后来出现的Windows95、Windows98，其实是在DOS系统上开发的一个大程序。而DOS系统，是Disk Operating System的简写，它鼻祖就是基尔代尔的CP/M。也正因为如此，人们普遍认为基尔代尔是磁盘操作系统的鼻祖，是计算机图形用户界面（GUI，Graphical User Interface，图形用户接口）的先驱，他在计算机历史上的地位被严重低估了。而这种低估，与比尔•盖茨的小气是分不开的。</p>
<p>基尔代尔自己把CP/M叫做BIOS（基本内存输入输出系统），它适用于任何极客DIY电脑。BIOS作为通用部分，极客可以自己对它进行修改，以使他们的磁盘驱动可以与计算机相匹配（当时有不同的磁盘硬件）。这种设计，使得CP/M容易被人们所接受。</p>
<h2>DR的没落与微软的崛起</h2>
<p>基尔代尔后期困在了自己的思想里，未能与时俱进，不然创建微软商业帝国的人可能就是他。商业有商业的规则，在商言商，经商与做人、教书还是不同的。</p>
<h3>基尔代尔失败的占星机项目</h3>
<p>虽然CP/M很牛逼，但它的发展十分奇特。当时基尔代尔一边教书，一边和朋友基于CP/M做了一个占星机的项目。他俩对占星术既无兴趣也不相信，但他们都认为这个项目的销路会不错。朋友造机器，基尔代尔编程序，两人软硬结合，很像苹果和微软开始的联合创始人组合。</p>
<p>他们把这种占星术既机器放在旧金山市内许多地方的杂货铺，吃着25美分的硬币，印出算命天宫图，基尔代尔觉得这台机器美得很。可是顾客却大为不满，因为机器吃进去硬币，纸就堵成一团。基尔代尔不得不承认，占星术项目在商业上完全是一个失败。</p>
<h3>基尔代尔的数位研究公司（1976年）</h3>
<p>1976年，基尔代尔离开学校，与妻子多露西一起创办了一个数字研究所（Digital Research Inc.），只看这个名字，就知道老板是一位学者企业家。公司由妻子多露西负责经营，这个公司的商业模式很简单，就是卖基尔代尔编写的CP/M系统。</p>
<p>1976年多露西曾怀疑公司能赚到的钱会超过1.5万美元，而事实上它赚了60万~80万美元。在开始的五六年中，公司的收益每年都翻了一番，1981年销售额达到520万美元，三年后更是达到了4460万美元。CP/M成了70年代、80年代初最有影响力的操作系统，到20世纪80年代中期，它运行在300种计算机模型上，有3000种软件支持CP/M机，CP/M成了当时的事实标准。</p>
<p>DR公司连续运营了十几年，为基尔代尔夫妇带来了大量财富。1974年，基尔代尔帮助创建了硅谷最富盛名的“家酿俱乐部”（Home Brew Club），他还出过基本著作，可谓已经是人生赢家。</p>
<p>基尔代尔与他的妻子多露西只维持了20年的婚姻。1994年7月，年仅52岁的基尔代尔在加州蒙特利的寓所头部撞地，三日后不治身亡。一个多才多艺的飞行员、大学教师、软件编程大师、作家和计算机先驱，就这样走了，但今天很多人并不知道他的存在。</p>
<h3>来自IBM的机遇，微软开始崛起</h3>
<p>1980年，IBM准备开发IMB PC系统，因为IBM与微软的比尔·盖茨有过合作，首先找到了他。但盖茨和基尔代尔的数字研究公司有个不成文的协定，那就是比尔·盖茨不能涉足操作系统领域，同时数字研究公司也不进入比尔·盖茨的程序语言范围，于是比尔·盖茨慷慨地将IBM的代表介绍给了基尔代尔。当时比尔·盖茨认为，DOS操作系统并不是未来，程序设计语言与良好的杀手级应用软件才是未来。</p>
<p>IBM与基尔代尔约好在一个秀丽的加州太平洋林园见面。会谈的结果很不理想，有人说这位基尔代尔博士骄傲自大，所以当IBM带着一生难遇的大生意找他的时候，他竟然驾着他的双引擎小飞机兜风去了（当时他已经通过DR赚了很多钱），只留下他的太太多露西和IBM打交道。面对IBM一大堆不泄密的限制协议，多露西很不乐意，大部分时间都在讨价还价上，双方达成的唯一协议就是要数字研究公司不泄露IBM来访这件事。生意吹了。</p>
<p>随后盖茨自告奋勇揽下了这笔生意。但是编写一个操作系统并不太容易，而IBM要求几个月内就完成。这时候，盖茨的合伙人保罗·艾伦发挥了作用。他找到了一位极客蒂姆·帕特森，从他手里购买了QDOS（Quick and Dirty Operating System），付了大约7.5万美元。QDOS显然是蒂姆·帕特森在DR-DOS（基尔代尔公司的产品）的基础上修改过来的。微软将QDOS改名为MS-DOS，修改一下，倒手卖给了IBM，开始了微软的飞黄腾达之路。</p>
<p>1981年，IBM推出第一台带有PC-DOS。基尔代尔看到后怒了：“我对和CP/M的相似感到惊讶，它们太相像了，系统功能简直一模一样。”</p>
<p>IBM和微软可能因此面临诉讼，但当IBM的人和基尔代尔接触以后发现，基尔代尔只是希望IBM在以后的PC电脑中采用他的下一版CP/M。IBM当然乐于从命，微软也躲过了致命一劫。</p>
<p>1983年底，基尔代尔的DR公司又推出了Concurrent（并发）CP/M，其优点是计算机用户可以同时做几种操作，比如在打印机打印时，可以同时写信，这在今天就是一个理所当然的功能，但在基尔代尔的发明之前，电脑是单线程的，同时只能做一件事。</p>
<p>新的多任务操作系统很棒，它在1984年问世时，获得了巨大的成功。但有点迟了，到了20世纪80年代末，微软的MS-DOS已经成为操作系统上的事实标准。</p>
<h3>微软的商业模式</h3>
<p>在DR和IBM已经占领大量市场份额的时候，微软还能崛起，全靠它的商业模式。微软既不像DR，只卖系统，又不像IBM和苹果，卖系统与硬件结合的整体。微软将自己的MS-DOS与微机厂商绑定起来，厂家每卖出一个电脑，微软才卖出一份系统。并且，MS-DOS只卖40美元，DR-DOS的售价几乎是它的6倍。</p>
<p>还有，在用户这一侧，根本感受不到微软在赚他的钱啊，在当时电脑贵40美金，少40美金，用户根本不敏感。还有，微软提供了替换WordStar、VisiCalc的Office套件，Office又不是开源的，想要使用Office，就必须购买预装有MS-DOS系统的电脑。</p>
<p>而另一边，基尔代尔的DR公司本来具有先天优势，却不肯适合变换自己的商业模式。基尔代尔没有学习微软的绑定销售模式，他决定不与编写WordStar、VisiCalc之类的软件公司进行一对一的直接竞争，<strong>他认为与自己的客户竞争，有昧自己的良心，是不道德的</strong>。</p>
<p>基尔代尔果然是一位学者企业家。他有企业家的敏锐嗅觉和欲望，但同时又保留了学者的锐意创新和儒雅。他一只脚踏在了商业领域，另一只脚踏在了学者领域，只有他这样的人，才能开发出符合市场需要的CP/M，而肯·汤普逊和比尔·盖茨都不可以。</p>
<h2>小结</h2>
<p>从以上Intel、IBM、微软、DR公司的故事中，你学到了什么呢？比尔·盖茨确实是一位商业奇才，他在上大学的时候，就敏锐第嗅到了PC电脑的商机，毅然退学创办了微软，幂幂之中好像命中注定一样，好像有什么东西在指引他前进。</p>
<p>当他需要从蒂姆·帕特森手里买下QDOS的时候，他没有犹豫。他在DR和IBM商业经验的基础上，开创了微软独特的商业模式。在Windowns 98之后，微软抛弃了MS-DOS系统架构，只保留了Windows NT架构，这个架构曾经给微软带来了非常成功的Windows 2000服务器系统，即使在中国，都卖出了许多付费拷贝。我们今天使用的Windows 7/10/11，以及Windows Server系列的系统，均是基于Windows NT。而Windows NT（Windows New Technology），源于微软与IBM合作过的OS/2系统，后来两个公司理念不和，各自开发，成就了后来的微软。Windows NT与CP/M已经彻底没有了关系。</p>
<p><img src="./assets/v2-92b7d48884b5df567618cdce63c7e9ab_1440w.jpg" alt="Windows"></p>
<p>关于Windows NT系统的更新历史，可以查看这个链接：</p>
<p><a href="https://zh.m.wikipedia.org/zh/Windows_NT">https://zh.m.wikipedia.org/zh/Windows_NT</a></p>
<p>2022年9月9日</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
            <category>undefined</category>
        </item>
        <item>
            <title><![CDATA[03《坠落》观后感]]></title>
            <link>https://yishulun.com/./src/posts/2022/0908-2.html</link>
            <guid>https://yishulun.com/./src/posts/2022/0908-2.html</guid>
            <pubDate>Thu, 08 Sep 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>03《坠落》观后感</h1>
<center><img src="./assets/image-20220908174157388.png" style="zoom:50%;" /></center>
<p>我的天，恐高勿看！（注意：影评都含有一定的剧透，介意请马上关上！）</p>
<!-- more -->
<ul>
<li>
<p>铁塔太高了，没有信号，用鞋子搭载手机扔到塔下求救，失败了。</p>
</li>
<li>
<p>遇到烧烤露营的人，发信号弹求救，结果人家不但不救她们，还把她们的车偷走了。</p>
</li>
<li>
<p>然后就是使用无人机尝试向旅店送信，结果无人机过马路没有看红绿灯，被卡车撞碎了。</p>
</li>
<li>
<p>最后，最后，还是靠把手机扔下塔（借助闺蜜），发出求救信号得救的。</p>
</li>
</ul>
<p>主角本来是在闺蜜的建议下，通过极限运动克服之前一个极限运动留下的情感阴影。现在好了，阴影更深啦。不过，失恋的阴影应该已经走出来啦。</p>
<p>影片从闺蜜下塔拿包，剧情就开始高度紧张。闺蜜的死亡反转，是全局一大亮点，相信这一点会促使你倒回去再看二遍。</p>
<p>从创作技法上讲，代入感很强。骨肉亲情、生死之交、侵夺背叛，容易产生代入感的三个方面都涉及到了，代入感想不强都很难。</p>
<p>如果再能设计一点集体荣誉、弱势群体因素进去就更强了：</p>
<ul>
<li>
<p>例如，在集体荣誉方面，可以让闺蜜参加一个极限主播大赛，主角和闺蜜为了获胜拿奖，必须参与这次挑战。</p>
</li>
<li>
<p>还有，在弱势群体方面，可以把主角和闺蜜设定为非法移民群体，甚至肤色都可以变成黑色，也可以让旅馆的人发现碎在马路上的直升机，看到了纸条，但没有人愿意选择来救她们，因为她们处在社会的最底层，命不值钱。如果这样设定，露营的人不救她们还偷车，就更容易站住脚了。还有，往宏大了讲，社会教育意义还附加上了。（该死的教育意义）</p>
</li>
</ul>
<p>最后说一下，有人质疑为什么不用无人机把手机送下塔，还有两人的运动装备根本不专业，背包没有上双险，保命绳也不长，还有一个最大槽点：苹果手机能用三天？好吧，如果导演没有从水果商那里拿到一份广告费的话，确实应该换一个手机品牌。</p>
<p>等等吧，确实有一些不严谨的地方，但电影或小说，主要是帮助观众释放情绪的，情绪占第一位，逻辑什么的其实不太重要。</p>
<blockquote>
<p>最后附一个在线试看链接：<a href="https://www.olevod.com/index.php/vod/play/id/38429/sid/1/nid/1.html%EF%BC%8C%E8%AF%B7%E6%94%AF%E6%8C%81%E6%AD%A3%E7%89%88%E3%80%82">https://www.olevod.com/index.php/vod/play/id/38429/sid/1/nid/1.html，请支持正版。</a></p>
</blockquote>
<p>2022年9月8日</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
            <category>undefined</category>
        </item>
        <item>
            <title><![CDATA[从金庸小说和齐白石国画，看网文如何加快节奏？]]></title>
            <link>https://yishulun.com/./src/posts/2022/0908.html</link>
            <guid>https://yishulun.com/./src/posts/2022/0908.html</guid>
            <pubDate>Thu, 08 Sep 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>从金庸小说和齐白石国画，看网文如何加快节奏？</h1>
<p>我很早就注意到了这种现象，今天分享出来与朋友们探讨，并且这种艺术处理技巧，不止可以应用在武侠小说的创作中，在计算机技术图书的写作中，应该也是可用的。本质上，都是用最精简的文字，表达最丰富的内涵。我们的古代文字都比较简洁，惜字如金，甚至标点都要略去，这除了节省竹简的考虑，应该还有艺术表达上的简洁需要。</p>
<!--more-->
<h2>武侠小说中文字的疏与密</h2>
<p>先看武侠小说中文字的疏密，以我最喜欢的金庸先生的小说《侠客行》为例，世纪新修版下册第605页有这样一段文字：</p>
<blockquote>
<p>闵柔颤声道：“谢天谢地，终于......终于打听到了这女子的下落，师哥！咱们......咱们赶着便去。”石清点头道：“是。”二人当即向白自在等人作别。</p>
</blockquote>
<p>这段话，作者写在石清、闵柔知道了梅芳姑在熊耳山枯草岭之后，前面二人的对话都是实写，最后一句，以“二人”开头的，是虚写。二人是怎么向众人作别的，没有细写。为什么没有实写？因为不需要啊。另外，这里为什么单提了一下白自在，因为下面就是白自在与他们夫妇二人的对话。</p>
<p>石清、闵柔早不知道梅芳姑的下落，晚不知道，偏偏在这个时候知道，为什么？这是金大导演安排的。侠客岛归来，《侠客行》前面的剧情都写完了，就剩下熊耳山最后的一幕剧情了。石破天在海上救了师父、阿秀之后，作者特意安排的这个桥段，就是为了引出熊耳山的后续剧情。</p>
<p>再看一个疏写的例子，同册第611页：</p>
<blockquote>
<p>众人的目光一齐都向石破天射去，人人心中充满了疑窦：“梅芳姑是处子之身，自然不会是他母亲。那么他母亲是谁？父亲是谁？梅芳姑为什么要自认是他母亲？”</p>
</blockquote>
<p>在这一段的开头，“众人”便是疏写，将众人的心思并在了一起。这在电影中是没有办法直接用镜头变现的，替代的方式只能用旁白。有时候我们说小说比电影好看，也在于此。</p>
<p>「疏」写大致主要有两种情况：</p>
<ul>
<li>一，将几个人的言行、心思并在一起写；</li>
<li>二，高度概括内容，相当于是语言的白描手法。</li>
</ul>
<p>还有一种简写，虽然不是「疏」写，但能让文字更少。看一个同册第606页的示例：</p>
<blockquote>
<p>他此刻的轻功何等了得，转瞬间便上了山岭，绕过一片林子，到了几间草屋之前。只听得狗吠声响，一条黄狗从屋中奔将出来，扑向他的肩头。石破天一把搂住，喜叫：“阿黄，阿黄！你回来了。我妈妈呢？”大叫：“妈妈，妈妈！”</p>
</blockquote>
<p>这一段中，“石破天一把搂住”，搂住什么？缺少宾语。还有后面的“大叫”，谁大叫？缺少主语。从语法上似乎有点毛病，但语句极其简洁，文学表达效果也更好了。奇怪不？少了文字，语法不全，效果还更好了。这是精简语句，让文字更为简洁高效的方法。</p>
<p>下面看「密」写的例子。这样的例子书中有许多，仅举一例：</p>
<blockquote>
<p>丁不四见对方人多，突然灵机一动，道：“好，一言为定，咱们大家都不出手。你们这边是石庄主夫妇，他们这边是母子二人。双方各是一男一女，大家见个胜败便是。”他和石破天动过几次手，知道这少年武功远在石清夫妇之上，有他相助，梅芳姑诀计不会落败。</p>
</blockquote>
<p>这里写了丁不四的言语和心思，已经属于详写了。</p>
<p>武侠小说中的详写与略写，必须间隔起来，这样读起来才不容易觉得疲倦。人们常说读金庸小说不觉得累，如果没有生理限制，可以一直读下去。写作常言技巧“文似看山不喜平”，便可以从文字的疏与密上理解。</p>
<h2>国画中的写意与写实</h2>
<p>下面看国画中的写意。什么是写意？说白了就是「疏」，就是「略」，就是抽象。这是一张齐白石的草虫国画：</p>
<p><img src="./assets/d452cdc9b65840a89bc1aeaff04516c0.jpeg" alt="齐白石画作"></p>
<p>这里萝卜画得简略，虫子画得精细。是齐白石大师画不精细吗？显然不是，齐白石年少学做木匠，中年又学刻印，手上功夫是很有准头的。这不是工笔画，不用写实，这是写意画。但即使在写意画当中，齐白石对画中事物也分了疏密，倘若萝卜和虫子一昧画得工笔细致，或一昧画得粗糙简略，便失去国画的意味了。你可以网上随意找一下，齐白石的画，画的风格总是疏密有致的，没有一边倒的情况。</p>
<p>所以，小说文字的疏与密，国画中的写意与写实，它们是一回事，源自同一种中国文化，往更高的层次说是同样的一种艺术处理技巧。</p>
<h2>小结</h2>
<p>最后总结一下我的感受。武侠小说中，无论是将多人言行、心思并作一类抽象的人「疏」写，还是将要写的内容作抽象概括，像故事大纲一样一笔带过，以及用简短有力的句子，将一句话中的主语或谓语省略掉，这一切都是为（小说要讲的）故事服务的。</p>
<p>为了讲好故事，有些话可以略写，甚至不写。这种错落有致的写法，才让读者觉得小说的「节奏」快。其实「节奏」只是一个读者主观的阅读体验罢了，加快叙事进度，不说多余的话，快点把故事讲完，在读者这边的感受结果就是三个字——节奏快。</p>
<p>反过来，如何小说通篇内容都是情节大纲式的略写，抑或是事无巨细式的详写，读者的阅读感受要么是索然无味，要么是审美疲劳，读个几章内容就读下去了，这种情况在网文小说中很常见。有人说现在网文节奏变快了，金庸小说过时了。其实不是的，很多网文作者都没有什么写作经验，靠在小说中塞几个黄段子飞起，仅是金庸武侠小说中疏与密这一个技巧，就值得他们好好学习。</p>
<p>2022年9月8日于北京</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
            <category>undefined</category>
        </item>
        <item>
            <title><![CDATA[Github Gist是什么？]]></title>
            <link>https://yishulun.com/./src/posts/2022/0906.html</link>
            <guid>https://yishulun.com/./src/posts/2022/0906.html</guid>
            <pubDate>Tue, 06 Sep 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>Github Gist是什么？</h1>
<p><a href="https://gist.github.com/">Gist</a>，中文要点，/dʒɪst/，是Github提供的一个子服务，可以在线分享比较小的代码片段，同样的代码如果用传统创建仓库的方式分享可能就显得笨重了。Gist就是一个精简版的Repository。下面是我用《微信小游戏开发》3.2.2示例代码做的实验，及实验感受。</p>
<!--more-->
<h2>它分享的范围有哪些？</h2>
<p>创建时有两个选项：</p>
<img src="./assets/image-20220906204443158.png" alt="image-20220906204443158" style="zoom:50%;" />
<p>第一个选项“Create secret gist”，虽然有 secret，但也不是私密的，看到分享链接的人都可以访问。第二个选项，是一个完全公开的、搜索引擎可以抓取的链接。</p>
<p>基本公司团队内分享，使用第一个选项合适；撰写一个小教程，就像我这篇文章一样，适合使用第二个选项。这个选项或许还可以让我们的文章有更多的曝光量，当然这仅限于你在代码中可以留下了文章链接。</p>
<h2>它有什么用法？</h2>
<p>在线创建后便可以分享了。</p>
<h3>在页面中内嵌代码</h3>
<p>直接在 md 或 HTML 页面中，用 script 标签嵌入一个 js 地址：</p>
<pre><code class="language-js">&lt;script async src=&quot;https://gist.github.com/rixingyike/3e64127a5ebb66ee381093bfeeed8829.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>它是怎么工作的？这个很容易猜出。</p>
<p>js 文件链接本身即包含了足够的信息，它会先动态加载基本的类库，然后再把要加载的对象信息传递给类库，对象（我们分享的代码）加载完成之后，最后统一在页面上创建 HTML 元素并把代码渲染出来。</p>
<p>如果查看上述 8829.js 文件的代码，它的内容类似是这样的：</p>
<pre><code class="language-js">document.write('&lt;link rel=&quot;stylesheet&quot; href=&quot;https://github.githubassets.com/assets/gist-embed-19d8e57711b3.css&quot;&gt;')
document.write('&lt;div id=\&quot;gist118190366\&quot; class=\&quot;gist\&quot;&gt;\n    &lt;div class=\&quot;gist-file\&quot; translate=\&quot;no\&quot;&gt;\n...')
</code></pre>
<p>第一行是 Github 基本的CSS样式类库，第二行是与我们每一个分享的代码有关的信息。</p>
<h3>分享链接</h3>
<p><a href="https://gist.github.com/rixingyike/3e64127a5ebb66ee381093bfeeed8829">https://gist.github.com/rixingyike/3e64127a5ebb66ee381093bfeeed8829</a></p>
<p>注意，这个地址很奇妙啊，这不就是上面那个js文件的地址吗？只是少了一个js后缀。在Github的服务器端，加上后缀是被引入的js文件，不加是Gist代码的主页地址，这样的API设计不可谓不算简约。</p>
<h3>提供一个 zip 下载链接</h3>
<p><a href="https://gist.github.com/rixingyike/3e64127a5ebb66ee381093bfeeed8829/archive/9b29a41650efa5bd9884d27ba9cb617e0291f8e1.zip">https://gist.github.com/rixingyike/3e64127a5ebb66ee381093bfeeed8829/archive/9b29a41650efa5bd9884d27ba9cb617e0291f8e1.zip</a></p>
<p>对于自己已经创建的历史 Gist，Github 都有记录，这个地址就是 Gist 地址加上自己的 Github ID，例如我的 Gists 地址是：</p>
<p><a href="https://gist.github.com/rixingyike">https://gist.github.com/rixingyike</a></p>
<h2>Gist 不能在线直接运行吗？</h2>
<p>目前不能。</p>
<p>Gist 允许同时分享多个文件，我在使用时看到这个功能还很高兴，因为可以保持文件的名称和相对位置，对于前端小示例，便意味着可以在线运行。</p>
<p>事实上不可以。</p>
<p>事实上 HTML/CSS/JS 组成的静态示例，是可以实现在线运行的。</p>
<p>对于看到分享链接的读者来说，不仅能看到代码，还能看到运行效果。甚至其他语言，例如 Python、Go 等，借助 WebAssembly 技术，也可以实现在线查看源码与运行效果。</p>
<p>虽然 Gist 官方不能，但有人开发了第三方应用，可以动态加载 Gist 并呈现动态效果，例如：</p>
<p><a href="https://bl.ocks.org/">https://bl.ocks.org/</a></p>
<p>使用方法也很简单，直接将上面自己的分享链接中的 <a href="http://gist.github.com">gist.github.com</a>，替换为 <a href="http://bl.ocks.org">bl.ocks.org</a> 即可。例如我的这个小示例微信小游戏开发 3.2.2，在线查看地址为：</p>
<p><a href="https://bl.ocks.org/rixingyike/3e64127a5ebb66ee381093bfeeed8829">https://bl.ocks.org/rixingyike/3e64127a5ebb66ee381093bfeeed8829</a></p>
<p>运行效果为：</p>
<p><img src="./assets/image-20220906213322112.png" alt="image-20220906213322112"></p>
<p>它已然是一个「活」的 HTML 页面了。但它在这里只是一张图片，那么这个示例效果页也可以嵌入吗？</p>
<p>的md文件内应该是可以的，因为md支持HTML代码嘛。嵌入效果如下：</p>
<iframe sandbox="allow-popups allow-scripts allow-forms allow-same-origin" src="https://bl.ocks.org/rixingyike/raw/3e64127a5ebb66ee381093bfeeed8829/9b29a41650efa5bd9884d27ba9cb617e0291f8e1/" marginwidth="0" marginheight="0" style="height:100px;" scrolling="no"></iframe>
<p>嵌入结束。</p>
<p>没有效果！没有办法，资源是bl.ocks.org的，人家拒绝我们跨域嵌入，我们便无法通过iframe引入了。</p>
<h2>其他问题</h2>
<h3><a href="http://gist.github.com">gist.github.com</a> 被墙无法访问的解决办法</h3>
<p>可以用梯子，或者修改 hosts 文件，直接将 <a href="http://gist.github.com">gist.github.com</a> 指向它的 IP 地址（例如 192.30.253.118），这一招破解的是 DNS 污染。</p>
<p>具体指向哪里，不一定，可以在本地用 ping 指令查看一下。希望你的 ping 结果不是这样的：</p>
<p>0 received, 100% packet loss</p>
<h3>有人把 Gist 当作一个写作平台</h3>
<p>这件事是结合<a href="http://roughdraft.xn--io-ic4cy78fbzq">http://roughdraft.io来做的</a>，但其实没有必要啊。Github仓库+hugo+Github Actions 就可以构建一个完美的静态博客，没有必要用结构松散的 Gist。</p>
<h4>如何看待 Github Gist 这个服务，怎样更好地利用？</h4>
<p>就是一个阉割版的 Repository，便于在线分享内容，不局限于分享代码。正常使用就可以了，过度使用就没有必要了。</p>
<h3>How to create a GitHub Gist with API?</h3>
<p>先创建 Github Token，然后在下面这个网址：</p>
<p><a href="https://docs.github.com/cn/rest/gists/gists">https://docs.github.com/cn/rest/gists/gists</a></p>
<p>找到需要的 REST API，进行 Gist 的 CURD 操作就可以了。</p>
<h2>小结</h2>
<p>当然了，Gist 本质上最大的功能，还是内嵌代码，且天然支持高亮，效果如下所示。</p>
<p><img src="./assets/image-20220906214053495.png" alt="image-20220906214053495"></p>
<p>::: tip<br>
没有用过 Gist 或不能用 Gist，感觉像吃手把肉没有韭菜花一样，有点不完美。<br>
:::</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
            <category>undefined</category>
        </item>
        <item>
            <title><![CDATA[《小程序从0到1》常见问题]]></title>
            <link>https://yishulun.com/./src/posts/2021/22.html</link>
            <guid>https://yishulun.com/./src/posts/2021/22.html</guid>
            <pubDate>Wed, 22 Dec 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>《小程序从0到1》常见问题</h1>
<blockquote>
<p>《小程序从0到1：微信全栈工程师一本通》常见问题。<br>
常见问题解答在最后面。</p>
</blockquote>
<p>一本全面而系统的介绍小程序开发技术的书籍。网店在售的共有两个版本：</p>
<ul>
<li>2018年1月出版的为旧版，在使用需要先查看<a href="http://api.rixingyike.com/">这里</a>的接口说明；</li>
<li>2018年5月印刷出版的为新版，涉及相关接口已经修改，不需要查看上面的链接。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/rixingyike/images/202120210311142029.jpg" alt="5a30df84N4f448eca" style="zoom: 50%;" />
<h2>读者群常见问题六篇集锦</h2>
<ul>
<li><a href="/posts/2018/01.html">01 小程序从0到1：1月9日群问题集锦</a></li>
<li><a href="/posts/2018/02.html">02 小程序从0到1：1月23日群问题集锦</a></li>
<li><a href="/posts/2018/03.html">03 小程序从0到1：1月25日群问题集锦</a></li>
<li><a href="/posts/2018/04.html">04 小程序从0到1：第一次在windows机器上使用sim.go需要注意的问题总结</a></li>
<li><a href="/posts/2018/05.html">05 小程序从0到1：MXML基础语法与错误信息</a></li>
<li><a href="/posts/2020/01.html">01 小程序从0到1：豆瓣接口替代网址可以在线访问了</a></li>
</ul>
<p>（20221222更新）</p>
<h2>源码下载及旧版说明</h2>
<p>所有示例源码链接:<br>
<a href="https://pan.baidu.com/s/1wvegfTp5BLY7Mz-qeqFxwA">https://pan.baidu.com/s/1wvegfTp5BLY7Mz-qeqFxwA</a> 密码: y5pg</p>
<p>微信小程序从0到1练习链接:<br>
<a href="https://pan.baidu.com/s/1bp3uIFd">https://pan.baidu.com/s/1bp3uIFd</a> 密码: k7yy</p>
<p>上面链接下载的是全部源码。如果回复单个关键字，下载单个示例源吗.例如「豆豆电影2.1」，注意中间无空格。</p>
<pre><code>回复「豆豆电影2.4」返回举例：
链接: https://pan.baidu.com/s/1BaQAUMUmUwvSMP7x2FVW4A 密码: amge
</code></pre>
<p>【注意】所有《小程序从0到1》第一版读者请注意查看这个地址（仅限旧版，新版本无此问题）：</p>
<p><a href="http://api.rixingyike.com/">http://api.rixingyike.com/</a></p>
<p>如何判断手上的是不是旧版？可以查看封皮内出版信息，2018年1月第一版第一次印刷为旧版。</p>
<h2>读者评价</h2>
<p>来自Comunion的Scorpio说道：</p>
<blockquote>
<p>写得很棒，看完了就搞了个小程序外包</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/rixingyike/images/202120210311210321.png" alt="image-20210311210319762" style="zoom: 67%;" />
<p>看来我的书对有些人来说一点也不难，很好入门，也很实用。</p>
<h2>购买方式</h2>
<ul>
<li><a href="https://item.jd.com/12257013.html">京东第二版购书链接</a></li>
</ul>
<p>购买图书后，欢迎进读者群。有任何技术问题，可以在群内交流讨论。</p>
<h2>新常见问题⭐️</h2>
<p><strong>1.如果进读者交流群？</strong></p>
<p>加作者v9830131，回复【读者】进修仙群。</p>
<p><strong>1.为什么我的后端程序跑不起来？</strong></p>
<p>要注意查看自己手里的书是不是第二版本。由于历史原因，第一版本采用的在线豆瓣接口有访问限制、不稳定。在第二版本中作者修改了接口，这个问题已经不存在了。</p>
<p>如果手里的是旧版本怎么办？可以前往京东购买新版本，或者查看这个链接：<a href="http://api.rixingyike.com/">http://api.rixingyike.com/</a>，按照说明自行修改即可。</p>
<blockquote>
<p>注意：在某拼夕夕平台，某宝平台，或某QQ群允斥的都是自行私印的盗版，并且是旧版本的盗版。盗版商只注重利益，不注重更新版本，读者购买时须谨慎。抵制盗版，从你我做起。</p>
</blockquote>
<p><strong>2. 有人私信问我搭建科学上网服务的软件</strong></p>
<p>有人私信问我搭建科学上网服务的软件，在这里：<br>
<a href="https://github.com/hwdsl2/setup-ipsec-vpn/blob/master/README-zh.md">https://github.com/hwdsl2/setup-ipsec-vpn/blob/master/README-zh.md</a></p>
<p><strong>3. 老师，PC端预览正常，手机端就不显示。这是什么原因呢</strong></p>
<p>这种多半是资源加载失败了。可以开手机调试模式，看错误是什么。另外看一下微信开发者工具，项目设置，是不是设置了不校验域名。</p>
<p><strong>4. 有es6的文章吗？</strong></p>
<p>网上很多相关的教程，可以看一下这个：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript</a></p>
<p><strong>5. 需要什么样的基础吗？</strong></p>
<p>开始可以学一下以下前端基础内容——</p>
<p>第一步学一下HTML：<br>
<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML">https://developer.mozilla.org/zh-CN/docs/Web/HTML</a></p>
<p>第二步可以学习一下CSS3样式语言：<br>
<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS">https://developer.mozilla.org/zh-CN/docs/Web/CSS</a></p>
<p>第三步学习一下JS：<br>
<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference</a></p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[《微信小程序全栈开发实战》常见问题]]></title>
            <link>https://yishulun.com/./src/posts/2021/23.html</link>
            <guid>https://yishulun.com/./src/posts/2021/23.html</guid>
            <pubDate>Wed, 22 Dec 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>《微信小程序全栈开发实战》常见问题</h1>
<blockquote>
<p>《微信小程序全栈开发实战》常见问题。<br>
常见问题解答在最后面。</p>
</blockquote>
<p>这是我在极客时间上架的视频专栏课，目前已经全部录制完成了，共179节，48+小时时长。这门课虽然名字冠以小程序，但其实是一门全栈开发的课，不仅全面介绍了小程序技术，还介绍了后端Node.js技术。读者对象适合为编程初学者，或想转行做前端开发的同学。</p>
<h2>课程评价</h2>
<p>来自读者岁月如初的评论：</p>
<blockquote>
<p>视频一打开，就被老师那种学者般磁性的声音吸引。以前做过简单的小程序开发，通过老师第一节课程的讲解，感觉不错，希望通过购买本套课程提高小程序开发能力。加油！</p>
</blockquote>
<blockquote>
<p>回复：今天评论一打开，就让你清新脱俗的言语所折报。以前做过一些在线课程，但录制这么大规模的网课却是首次，经验不足，还请多多包涵。希望你通过本课程的学习，成功开发出一款让自己日夜躺赚的小程序产品，加油，少年~</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/20210330110836image-20210330110830372.png" alt="image-20210330110830372" style="zoom:67%;" />
<p>来自极客时间官方小编的评价：</p>
<blockquote>
<p>其实，我之前也看过不少小程序教程，讲解的都是平台组件、API 等前端内容，并不涉及后端，学完后，还是没办法独立完成项目。</p>
<p>李艺老师不仅讲解了最佳实践和解决方法，还会结合电商小程序实践，贯穿前后端所有相关技术，带你由浅入深地掌握必备基础知识，了解具体业务逻辑功能的实现方式，让你在编写其它小程序项目时，也能举一反三，游刃有余。</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/rixingyike/images/202120210311143855.png" alt="image-20210303183511288" style="zoom:25%;" />
<p>来自学员Forest的评价：</p>
<blockquote>
<p>#你最感谢的一本编程书或教程是什么？<br>
首先感谢李艺老师，深入浅出，循序渐进，收获颇丰，课程不是简单的讲解小程序的功能，而是将知识点与实际开发运用的一个过程，课程不仅讲了小程序，还讲解到了node, MySQL, nginx,  云开发，微信公众号开发等等，也是我目前接触到的最全的一门小程序课程。</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/rixingyike/images/202120210311144028.png" alt="image-20210303183445619" style="zoom:25%;" />
<p>来自学员小司的评价：</p>
<blockquote>
<p>#你最感谢的一本编程书或教程是什么？<br>
首先感谢李艺老师，十分感谢~<br>
先不谈老师讲课内容全面、细致，就从课后的耐心解答每一位读者的问题疑惑，就不是一般老师能确确实实做得到的，那一股股认真用心的劲，让我太爱这位老师了。这门课由浅入深，质量对我来说那是杠杠的，更何况所有在开发中遇到的工具、服务，老师已全部提供给我们了。课程不像网络上教程那样单单讲解小程序的功能，而是将每个知识块与实战紧密结合，外加拓展，涉及的很广，甚至还讲解到了云数据库，MySQL，Node.js，Golang，Vue，云开发等各种知识点。<br>
总之，老师会尽自己一切能力帮助到每一位读者，这一点很难得的，希望我们每一位好好珍惜~<br>
最后，再次感谢李艺老师，谢谢~<br>
期待你的加入，我们一起进军微信小程序全栈开发！</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/rixingyike/images/202120210313103910.png" alt="image-20210313103908412"></p>
<p>来自极客时间老读者swordman在最后一节课撰写的评价：</p>
<blockquote>
<p>从2020年6月，学习到2021年1月，8个月的时间，让我从一名Android原生应用开发者，转变成小程序应用开发者。非常感谢老师，是老师的一步步引导，让我跨过了新的语言，新的IDE，声明式UI这三个技术关卡。“知行合一”的理念，也让我收益颇丰。<br>
3月份，我自己的小程序产品已经开始试用了，可以说没有这门课程，我的小程序产品不可能快速从0到1，进入试用阶段。<br>
感谢老师对课程的辛勤付出，也感谢极客时间，提供了那么好的一个学习平台。（我是极客时间的老粉丝，2017年在上海QCon，见证了极客时间的诞生。）</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/rixingyike/images/202120210311144252.png" alt="image-20210309191256574"></p>
<h2>购买方式</h2>
<p>购买链接：<a href="http://gk.link/a/10AdC">http://gk.link/a/10AdC</a></p>
<h2>常见问题⭐️</h2>
<p><strong>1. Golang版本的代码有吗？看评论说有，我没找到</strong></p>
<p>179节课内没有Go语言版本的后端代码。后续如果持续更新完善，考虑添加Go语言代码，毕竟Go语言也是作者钟爱和一贯使用的语言。</p>
<p><strong>2. 有没有课件？</strong></p>
<p>有。</p>
<p>不止一个读者问到极客时间视频专栏的演示文稿，我整理了出来，都在这里了：<br>
链接：<a href="https://pan.baidu.com/s/1mJq_NVstuPpNRi7PDawjkg">https://pan.baidu.com/s/1mJq_NVstuPpNRi7PDawjkg</a><br>
提取码：liyi</p>
<p>这是Mac上的keynote文件，如果在Windows上查看，可以从这个网站转化：<br>
<a href="https://zhuanhuan.supfree.net/hao.asp?f=key&amp;t=pdf">https://zhuanhuan.supfree.net/hao.asp?f=key&amp;t=pdf</a></p>
<p><strong>3. 听朋友说，他完课拿到了作者新手签名的书？</strong></p>
<p>是的。截至写条Q/A时，赠书活动仍在进行。完课，并在极客时间部落晒出结课证书，写几句评名，凑够100字，就有很大机会免费得到作者亲笔签名的赠书。目前仅一位读者获得，加油。</p>
<p>详细信息可以从这里查看：<a href="https://mp.weixin.qq.com/s/AT9ZGknXA3AyFM4f-Hc29w">https://mp.weixin.qq.com/s/AT9ZGknXA3AyFM4f-Hc29w</a>。</p>
<p><strong>4.如何进读者群？</strong></p>
<p>加作者v9830131，回复【读者】进修仙群。</p>
<p><strong>5. 一位读者问到关于开通直播的问题</strong></p>
<p>有读者问到：</p>
<blockquote>
<p>老师，有问题想请教下，现在申请直播服务的域名都需要有公安部备案的吗，我的毕业设计是做个直播的小程序，现在只有icp备案的域名，没有进行公安部备案，想问下有啥方法可以解决吗?</p>
</blockquote>
<img src="https://gitee.com/rxyk/my-images/raw/master/2021/20210311123419.png" alt="image-20210311123417402" style="zoom: 50%;" />
<p>此提问，这位读者并不是购买了腾讯云的云直播组件。在云直播组件中，有相关直播域名的要求。</p>
<blockquote>
<p><a href="https://cloud.tencent.com/document/product/1078/42916">https://cloud.tencent.com/document/product/1078/42916</a><br>
小程序·云直播插件</p>
</blockquote>
<p>这个云直播组件，虽然不需要自己开发，但是仍然需要开发者有非个人资质。</p>
<p>这位读者尝试的是七牛云。七牛云云直播不需要企业资质，个人也可以申请开通，但需要个人提供同时具有ICP备案和公安备案的域名。关于公安备案，具体要求在下面：</p>
<blockquote>
<p><a href="https://developer.qiniu.com/af/kb/3987/how-to-make-website-and-inquires-the-police-put-on-record-information">https://developer.qiniu.com/af/kb/3987/how-to-make-website-and-inquires-the-police-put-on-record-information</a></p>
</blockquote>
<p>我看了这个链接，公安部图案人个就可以做，不需要企业资质，所以麻烦一下，还是可以申请的。最麻烦的是，它要求企业资质，开发者想申请都没有资格。</p>
<p>这位读者是想完成毕设。最后我给出的建议是：</p>
<blockquote>
<p>如果你只是为了完成毕设，实现直播与播放功能，没有必要开这个七牛云。用我极客时间的小程序课程里的live pusher、live player，及相关企业帐号就可以实现了。</p>
</blockquote>
<p><strong>6. 老师，能添加开发者资质吗？</strong></p>
<p>可以的，==在视频课程的第四章任一节课程下面留言==，写清楚要添加开发者和自己的微信号就可以了。我看到了就会为你添加。</p>
<p>注意微信号要写正确，要确认已经打开隐私设置，能被搜索到。有些读者草草提供一个微信号，根本搜索不到。</p>
<p>有一次，一位读者提到了这样一个号：</p>
<img src="https://cdn.jsdelivr.net/gh/rixingyike/images/202120210316082801.png" alt="image-20210316082759842" style="zoom:33%;" />
<p>怎么也搜索不到。我就去问他，“你确认你提供的号自己能搜索到吗？”</p>
<p>“可以，最前面的字母是大写的i”</p>
<p>好吧，下次我尽量复制。</p>
<p>有另外一位读者，我到现在还记得他的微信号是“JavaScript0101”，毫无异义，简单易记。祝我以后收到的都是这样的微信号。</p>
<p>在添加以后，你的微信就具有开发者权限了，就可以直接使用源码进行测试了。AppID在源码中的项目文件中有，在导入项目时会自动呈现。</p>
<p><strong>7. 老师能不能把下拉刷新和上拉加载组合在一起讲一讲？</strong></p>
<p>好想法，下次输出放一起。</p>
<p><strong>8. 老师，wxs脚本里面console.log输出事件源为什么是[object object]，怎么正确查看对象?</strong></p>
<p>WXS很不完善，用的时候一定要小心，它的能力远远弱于js，目前。如果发现与预想不一致的情况，就查看一下官方的<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxs/">WXS文档</a>。</p>
<p>补充一点，关于console.log输出显示[object object]的问题，js输出有时候也有这个问题，这和对象的toString实现有关。可以这样变换一下：</p>
<p>console.log(JSON.stringify(...))</p>
<p><strong>9. 老师不知道你了不了解微信支付的账单是如何分类的？比如我扫码骑共享单车微信为啥知道把这个费用归为交通？</strong></p>
<p>如果商家不提供信息，按理说微信是不知道如何给帐单分类的。我查了一下统一下单接口中的body字段，微信对此字段的内容有所规定，见下图，这可能是它赖以自动分类的依据。</p>
<p><img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/20210414104444f689b2f44004853b2177426b97f19b0.png" alt=""></p>
<p><a href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=4_2">https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=4_2</a></p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[Gitbook简易上手教程]]></title>
            <link>https://yishulun.com/./src/posts/2021/19.html</link>
            <guid>https://yishulun.com/./src/posts/2021/19.html</guid>
            <pubDate>Tue, 21 Dec 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>Gitbook简易上手教程</h1>
<p>Gitbok是一个本地写书工具，基于md语法，使用简单，易于上手。</p>
<h2>1.1 如何使用gitbook</h2>
<h3>安装使用说明</h3>
<p>安装：</p>
<p>npm install -g gitbook-cli --force</p>
<p>初始化目录：</p>
<p>mkdir gitbook &amp;&amp; cd gitbook<br>
gitbook init</p>
<p>开始编辑目录：</p>
<p>vim <code>summary.md</code></p>
<pre><code># Summary

* [前言](README.md)
* [第一章](1/README.md)
    * [1.1，基本语法](1/基本语法.md)
* [第二章](2/README.md)
</code></pre>
<h3>重建目录</h3>
<p>添加相应手段后，执行<code>book sm</code>，即可自动生成相关章节。当然也可以手动添加章节文件。</p>
<h3>发布静态文件</h3>
<p>gitbook build . ../../static/books/$dir</p>
<p><a href="http://xn--build-bi1hv64hwefdy4ch4ak11l.sh">执行目录下的build.sh</a></p>
<h3>输出PDF</h3>
<p>输出为PDF文件，需要先安装gitbook pdf</p>
<p>$ npm install gitbook-pdf -g</p>
<p>然后，用下面的命令就可以生成PDF文件了。</p>
<p>$ gitbook pdf {book_name}</p>
<p>如果，你已经在编写的gitbook当前目录，也可以使用相对路径。</p>
<p>$ gitbook pdf .</p>
<p>然后，你就会发现，你的目录中多了一个名为book.pdf的文件。</p>
<h2>1.2 解决Installing GitBook的错误</h2>
<blockquote>
<p>我是在win10 64位系统上遇到的这个问题。</p>
</blockquote>
<p>使用如下指令安装gitook：</p>
<pre><code>sudo npm install -g gitbook-cli
</code></pre>
<p>可能会出现一个错误：</p>
<pre><code>$ gitbook serve .
Installing GitBook 3.2.3
C:\Users\LIYI\AppData\Roaming\npm\node_modules\gitbook-cli\node_modules\npm\node_modules\graceful-fs\polyfills.js:287
      if (cb) cb.apply(this, arguments)
                 ^
TypeError: cb.apply is not a function
    at C:\Users\LIYI\AppData\Roaming\npm\node_modules\gitbook-cli\node_modules\npm\node_modules\graceful-fs\polyfills.js:287:18
    at FSReqCallback.oncomplete (fs.js:184:5)
</code></pre>
<p>这个过程可能会很长，你可能需要先干别的事，过一段时间回来看，必现报错了。</p>
<p>我的node版本号是v14.15.5：</p>
<pre><code>$ node -v
v14.15.5
</code></pre>
<p>有人说是由于版本太高造成的错误，降低版本就可以了。</p>
<h3>使用nvm降低node版本</h3>
<p>nvm与n的区别是，n是一个node模块，nvm是node之外的脚本。</p>
<p>下载与安装nvm：</p>
<pre><code>https://github.com/coreybutler/nvm-windows/releases
</code></pre>
<p><code>nvm -v</code>有输出，代表安装成功了。</p>
<p>nvm常用指令：</p>
<pre><code>nvm install 10.22   // 选择安装node 版本
nvm use 14.15       // 切换使用的node版本  
nvm list            // 查看已安装的 node 版本
nvm uninstall 6.2.0 // 卸载对应的版本
</code></pre>
<h4>解决nvm安装失败问题</h4>
<p>听说10.22好使，使用nvm install 10.22时，出现一个错误：</p>
<pre><code>Could not retrieve https://nodejs.org/dist/latest/SHASUMS256.txt.
</code></pre>
<p>这是由墙造成的，是下载源的问题。去nvm的安装目录：</p>
<p>C:\Users\LIYI\AppData\Roaming\nvm</p>
<p>找到一个settings.txt文件，添加最后两行：</p>
<pre><code>root: C:\Users\LIYI\AppData\Roaming\nvm
path: C:\Program Files\nodejs
node_mirror:npm.taobao.org/mirrors/node/
npm_mirror:npm.taobao.org/mirrors/npm/
</code></pre>
<p>配置好以后，重新安装nvm install 10.22就好使了。</p>
<p>安装好以后就是使用use指令切换：</p>
<pre><code>$ nvm use 10.22.0
Now using node v10.22.0 (64-bit)
</code></pre>
<p>注意，这个切换必须在管理员模式下完成。还有，node版本的切换可能会对其它程序造成负面影响。</p>
<h3>重新安装gitbook</h3>
<p>可以使用node -v查看降低后的版本。现在可以重装gitbook了：</p>
<pre><code>npm install -g gitbook-cli --force
npm install -g gitbook --force
</code></pre>
<p>切换到普通指令模式下，再执行serve指令就可以了：</p>
<pre><code>$ gitbook serve .
Installing GitBook 3.2.3
gitbook@3.2.3 C:\Users\LIYI\AppData\Local\Temp\tmp-19328QAP4WZytuKh5\node_modules\gitbook
...
</code></pre>
<h2>1.3 如何自动生成目录</h2>
<p>先全局安装一个模块：</p>
<p>npm install -g gitbook-summary</p>
<p>然后在图书目录下执行：</p>
<p>book sm -i _book</p>
<p>-i参数用于忽略目录。_book是gitbook自动生成的输出目录，它是应该被忽略的。</p>
<p>如果有多个目录需要忽略，可以这样设置参数：</p>
<p>book sm -i [_book,node_modules, styles]</p>
<p>如果书籍目录下有book.json文件，就是配置文件在起作用了：</p>
<pre><code>{
  &quot;ignores&quot;: [&quot;_book&quot;,&quot;styles&quot;,&quot;node_modules&quot;],
  ...
</code></pre>
<p>配置文件优先级更高。</p>
<h2>1.4 Gitbook能不能自定义样式?</h2>
<p>通过books.json自定义样式：</p>
<pre><code>{
  &quot;styles&quot;: {
    &quot;website&quot;: &quot;styles/website.css&quot;
  },
  ...
}
</code></pre>
<p>style code in styles/website.css:</p>
<pre><code>.copyright{
  color: white;
}
</code></pre>
<p>如果样式未起作用，要注意检查样式语法，还有在.bookignore文件中，不能将styles目录忽略。</p>
<h2>1.5 安装常用插件</h2>
<p>在book.json中可以配置插件。</p>
<p>GitBook 默认自带5个插件：</p>
<ul>
<li>highlight： 代码高亮</li>
<li>search： 导航栏查询功能，据说默认不支持中文</li>
<li>sharing：右上角分享功能</li>
<li>font-settings：字体设置，最上方的&quot;A&quot;符号</li>
<li>livereload：为GitBook实时重新加载</li>
</ul>
<p>如果要替换默认插件，需要在book.json中将默认插件使用“-”号“减”去。</p>
<p>这是我用到的插件及插件配置：</p>
<pre><code class="language-json">{
  ...
    &quot;plugins&quot;: [
    &quot;auto-scroll-table&quot;,
    &quot;sidebar-style&quot;,
    &quot;click-reveal&quot;,
    &quot;-lunr&quot;,
    &quot;-search&quot;,
    &quot;search-pro&quot;,
    &quot;back-to-top-button&quot;,
    &quot;insert-logo-link&quot;,
    &quot;chapter-fold&quot;,
    &quot;code&quot;,
    &quot;advanced-emoji&quot;,
    &quot;emphasize&quot;,
    &quot;splitter&quot;,
    &quot;expandable-chapters-small&quot;,
    &quot;page-toc-button&quot;,
    &quot;klipse&quot;,
    &quot;donate&quot;,
    &quot;alerts&quot;
  ],
  &quot;pluginsConfig&quot;: {
    &quot;sidebar-style&quot;: {
      &quot;title&quot;: &quot;艺术论&quot;,
      &quot;author&quot;: &quot;LIYI&quot;
    },
    &quot;donate&quot;: {
      &quot;wechat&quot;: &quot;images/wxpaycode.jpg&quot;,
      &quot;alipay&quot;: &quot;images/alipaycode.jpg&quot;,
      &quot;title&quot;: &quot;&quot;,
      &quot;button&quot;: &quot;打赏&quot;,
      &quot;alipayText&quot;: &quot;支付宝打赏&quot;,
      &quot;wechatText&quot;: &quot;微信打赏&quot;
    },
    &quot;page-toc-button&quot;: {
      &quot;maxTocDepth&quot;: 2,
      &quot;minTocSize&quot;: 2
    },
    &quot;insert-logo-link&quot;: {
      &quot;src&quot;: &quot;https://www.yishulun.com/avatar.png&quot;,
      &quot;url&quot;: &quot;https://www.yishulun.com&quot;,
      &quot;style&quot;: &quot;background: none; max-height: 50px; border-radius: 50%;&quot;
    }
  }
}
</code></pre>
<h3>back-to-top-button 回到顶部按钮</h3>
<pre><code>{
    &quot;plugins&quot;: [
         &quot;back-to-top-button&quot;
    ]
}
</code></pre>
<h3>code 代码添加行号&amp;复制按钮</h3>
<pre><code>{
    &quot;plugins&quot; : [ &quot;code&quot; ]
}
</code></pre>
<p>如果想去掉复制按钮，可配置</p>
<pre><code>&quot;pluginsConfig&quot;: {
      &quot;code&quot;: {
        &quot;copyButtons&quot;: false
      }
}
</code></pre>
<h3>insert-logo-link 插入logo和链接</h3>
<pre><code>{
    &quot;plugins&quot;: [ &quot;insert-logo-link&quot; ]
    &quot;pluginsConfig&quot;: {
      &quot;insert-logo&quot;: {
        &quot;src&quot;: &quot;https://yishulun.com&quot;,
        &quot;url&quot;: &quot;avator.jpg&quot;
      }
    }
}
</code></pre>
<p>如果插入的图片过大，样式不匹配，可以在styles/website.css中通过样式控制。</p>
<h3>search-pro 高级搜索</h3>
<p>在使用此插件之前，需要将默认的search和lunr 插件去掉；在搜索结果中，关键字会高亮；自带的 search 插件，关键字不会高亮</p>
<pre><code>{
    &quot;plugins&quot;: [
          &quot;-lunr&quot;, 
          &quot;-search&quot;, 
          &quot;search-pro&quot;
    ]
}
</code></pre>
<h3>emphasize 为文字加上底色</h3>
<pre><code>{
    &quot;plugins&quot;: [
        &quot;emphasize&quot;
    ]
}
</code></pre>
<p>然后在markdown / asciidoc内容中，使用以下内容突出显示一些文本：</p>
<pre><code>This text is {% em %}highlighted !{% endem %}
This text is {% em %}highlighted with **markdown**!{% endem %}
This text is {% em type=&quot;green&quot; %}highlighted in green!{% endem %}
This text is {% em type=&quot;red&quot; %}highlighted in red!{% endem %}
This text is {% em color=&quot;#ff0000&quot; %}highlighted with a custom color!{% endem %}
</code></pre>
<p>效果：</p>
<p>:::<br>
This text is {% em %}highlighted !{% endem %}<br>
This text is {% em %}highlighted with <strong>markdown</strong>!{% endem %}<br>
This text is {% em type=&quot;green&quot; %}highlighted in green!{% endem %}<br>
This text is {% em type=&quot;red&quot; %}highlighted in red!{% endem %}<br>
This text is {% em color=&quot;#ff0000&quot; %}highlighted with a custom color!{% endem %}<br>
:::</p>
<h3>splitter 侧边栏宽度可调节</h3>
<pre><code>{
    &quot;plugins&quot;: [
        &quot;splitter&quot;
    ]
}
</code></pre>
<h3>page-toc-button 悬浮目录</h3>
<pre><code>{
    &quot;plugins&quot; : [ &quot;page-toc-button&quot; ]
}
</code></pre>
<p>可选配置项：</p>
<pre><code>&quot;pluginsConfig&quot;: {
        &quot;page-toc-button&quot;: {
            &quot;maxTocDepth&quot;: 2,
            &quot;minTocSize&quot;: 2
       }
}
</code></pre>
<p>maxTocDept 标题的最大深度（2 = h1 + h2 + h3）。不支持值&gt; 2。 默认2<br>
minTocSize 显示toc按钮的最小toc条目数。 默认 2</p>
<h3>打赏按钮 reward</h3>
<p>这是国人铭哥开发的插件，配置：</p>
<pre><code>&quot;pluginsConfig&quot;: ['
    &quot;reward&quot;: {
        &quot;wechat&quot;: &quot;http://unclealan.cn/usr/themes/seventeen/dist/images/weixin.JPG&quot;,
        &quot;alipay&quot;: &quot;http://unclealan.cn/usr/themes/seventeen/dist/images/alipay.JPG&quot;,
        &quot;button&quot;: &quot;打赏&quot;,
        &quot;alipayText&quot;: &quot;支付宝&quot;,
        &quot;wechatText&quot;: &quot;微信&quot;
    },
]
</code></pre>
<h3>klipse 嵌入类似IDE的功能</h3>
<p>Klipse配置:</p>
<pre><code>{
    &quot;plugins&quot;: [&quot;klipse&quot;]
}
</code></pre>
<p>用法，在 markdown 中：</p>
<pre><code class="language-python">print [x + 1 for x in range(10)]
</code></pre>
<p>js:</p>
<pre><code>1+2
</code></pre>
<h3>auto-scroll-table 表格滚动条</h3>
<pre><code>{
  &quot;plugins&quot;: [&quot;auto-scroll-table&quot;]
}
</code></pre>
<p>默认不够宽也是没有滚动条的。</p>
<h3>click-reveal 点击显示</h3>
<p>默认隐藏，点击可显示。</p>
<pre><code>{
    &quot;plugins&quot;: [
        &quot;click-reveal&quot;
    ]
}
</code></pre>
<p>使用方式，markdown中。</p>
<p>代码：</p>
<pre><code>{% reveal %}
要被隐藏的内容
{% endreveal %}
</code></pre>
<p>效果：</p>
<p>:::<br>
{% reveal %}<br>
要被隐藏的内容<br>
{% endreveal %}<br>
:::</p>
<p>默认显示的文字是 Click to show , 使用text自定义显示文字。代码：</p>
<pre><code>{% reveal text=&quot;点击显示&quot; %}
要被隐藏的内容
{% endreveal %}
</code></pre>
<p>效果：</p>
<p>:::<br>
{% reveal text=&quot;点击显示&quot; %}<br>
要被隐藏的内容<br>
{% endreveal %}<br>
:::</p>
<p>支持html语法：</p>
<pre><code>&lt;div class=&quot;click_reveal&quot;&gt;
    &lt;span&gt; 点击显示html &lt;/span&gt;
    &lt;div&gt;&lt;pre&gt;&lt;code&gt;隐藏的文字&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>效果：</p>
<p>:::</p>
<div class="click_reveal">
    <span> 点击显示html </span>
    <div><pre><code>隐藏的文字</code></pre></div>
</div>
:::
<h3>使用npm安装单个插件</h3>
<p>如果觉得使用gitbook install安装有点慢，可以单个下载、安装插件，例如：</p>
<pre><code>npm i gitbook-plugin-insert-logo-link
</code></pre>
<h2>1.6 如何上传图片</h2>
<p>上传图片是在typora中，间接使用Picgo上传到图床的。</p>
<p>推荐使用Picgo core，而非Picgo App。后者需要在本地启动一个web server，相当于往本地一个图片上传接口提交。显然Picgo core通过进程直接调用，效果更好。</p>
<p>推荐Picgo core配置：</p>
<pre><code class="language-json">{
  &quot;picBed&quot;: {
    &quot;current&quot;: &quot;githubPlus&quot;,
    &quot;githubPlus&quot;: {
      &quot;branch&quot;: &quot;master&quot;,
      &quot;customUrl&quot;: &quot;https://cdn.jsdelivr.net/gh/rixingyike/images&quot;,
      &quot;origin&quot;: &quot;github&quot;,
      &quot;path&quot;: &quot;2021&quot;,
      &quot;repo&quot;: &quot;rixingyike/images&quot;,
      &quot;token&quot;: &quot;在github上获取&quot;
    },
    &quot;uploader&quot;: &quot;githubPlus&quot;,
    &quot;transformer&quot;: &quot;path&quot;
  },
  &quot;settings&quot;: {
    &quot;showUpdateTip&quot;: false,
    &quot;rename&quot;: false,
    &quot;autoRename&quot;: false,
    &quot;uploadNotification&quot;: true
  },
  &quot;picgoPlugins&quot;: {
    &quot;picgo-plugin-github-plus&quot;: true,
    &quot;picgo-plugin-super-prefix&quot;: true,
    &quot;picgo-plugin-compress&quot;: true,
    &quot;picgo-plugin-gitee&quot;: false,
    &quot;picgo-plugin-gitee-uploader&quot;: false
  },
  &quot;picgo-plugin-super-prefix&quot;: {
    &quot;prefixFormat&quot;: &quot;YYYYMMDDHHmmss&quot;
  },
  &quot;picgo-plugin-github-plus&quot;: {
    &quot;lastSync&quot;: &quot;2021-03-28 02:27:30&quot;
  },
  &quot;picgo-plugin-compress&quot;: {
    &quot;compress&quot;: &quot;imagemin&quot;,
    &quot;key&quot;: null,
    &quot;nameType&quot;: &quot;none&quot;
  }
}
</code></pre>
<p>对该配置的说明：</p>
<ul>
<li>jsdelivr是用于cdn加速的，加速图片被用户快速访问到。</li>
<li>&quot;picgo-plugin-super-prefix&quot;这个插件是用于上传前重命名文件的，因为重名文件不允许上传，会报一个“sha不支持”的错误。使用这个插件，须确保默认配置&quot;autoRename&quot;为false。</li>
<li>上传使用&quot;picgo-plugin-github-plus&quot;插件，该插件在上传上优先默认上传功能及其它插件。它同时支持上传github、gitee两个图床。注意，当启用它时，需要将&quot;picgo-plugin-gitee&quot;和&quot;picgo-plugin-gitee-uploader&quot;都置为false。</li>
</ul>
<h2>1.7 在vscode中定义markodwn代码版本</h2>
<p>有些内容是重复的，可以借助snippets功能快捷创建。共有两个配置需要完成。</p>
<p>现在假设我们需要一个与hugo对应的snippet，首先需要选择文件-&gt;用户片断，新建一个markdown.json文件：</p>
<pre><code>{
  &quot;new hugo post header&quot;: {
    &quot;prefix&quot;: &quot;hugo&quot;,
    &quot;body&quot;: [
      &quot;---&quot;,
      &quot;title: $TM_FILENAME_BASE&quot;,
      &quot;sidebar: false
date: $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND&quot;,
      &quot;---&quot;
    ]
  }
}
</code></pre>
<p>因为vscode默认没有这个模板，不像其它c、cpp片断，单是完成这一步好不好使。还需要在用户的settings.json文件中添加：</p>
<pre><code>&quot;[markdown]&quot;: {
    &quot;editor.formatOnSave&quot;: true,
    &quot;editor.renderWhitespace&quot;: &quot;all&quot;,
    &quot;editor.quickSuggestions&quot;: {
        &quot;other&quot;: true,
        &quot;comments&quot;: true,
        &quot;strings&quot;: true
    },
    &quot;editor.acceptSuggestionOnEnter&quot;: &quot;on&quot;
}
</code></pre>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[幽默逻辑学浅窥]]></title>
            <link>https://yishulun.com/./src/posts/2021/20.html</link>
            <guid>https://yishulun.com/./src/posts/2021/20.html</guid>
            <pubDate>Tue, 21 Dec 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>幽默逻辑学浅窥</h1>
<blockquote>
<p>这是一篇不完备的笔记，后续还在继续研究它。</p>
</blockquote>
<h2>什么是幽默？</h2>
<p>幽默是一个外来词，最早见于民国时期1924年林语堂先生关于英文“Humour”一词的翻译，这个词的音标是[ˈhjuːmə(r)]，幽默属于按音直译。但后来林语堂又给了“幽默”这两个中文字一个合理的解释：“凡善于幽默的人，其诙谐必愈幽隐，而善于鉴赏幽默的人，其欣赏尤在内心静默的领会，大有不可与外人道之滋味”。</p>
<p>在作者看来，这一段半文言半白话文字描述的是人对幽默的感觉，就像荒诞、讽刺、滑稽等感受一样，它是人对这一艺术形式作用于人时感受的描述，并不算是幽默本身。</p>
<p>那么，什么是幽默？</p>
<p>方成在《谈幽默与讽刺》中说：“只可意会，不易言传”。</p>
<p>幽默真的难于言传吗？</p>
<p>未必。作者认为，幽默是一种被覆盖在人的形式逻辑之下的，<strong>一种可以自涵盖矛盾并能自圆其说的艺术存在</strong>。幽默所涵盖的事物不一定是真实存在的，但一定是符合人的形式逻辑规律的。用一句话概括，<strong>幽默是人利用人的形式逻辑缺陷而制造的一种艺术之美</strong>。</p>
<p>那么，幽默有什么有什么作用呢？</p>
<p>幽默可以让我们的言行传播的更远，幽默可以使人的心情舒展、缓解压力，幽默可以化解沟通中的尴尬，幽默可以利于学习。。。一句话，幽默的好处很多，这不言而喻。</p>
<p>那么，幽默能力是天生的吗？</p>
<p>虽然聪明的人更能制造幽默，更能给别人一种幽默的印象，但人制造幽默的能力并不是天生的，幽默的产生是有规律可循的。这本书旨在分析幽默产生的规律，总结制造幽默的技巧，以期在工作、学习中对读者有所裨益。</p>
<p>英国讽刺作家斯威夫特说：</p>
<p>“何为幽默，这绝非那批逻辑贩子所能描述。唯有天性在此发挥作用，训练、书本、技艺都无济于事。”</p>
<p>其实不是这样的，幽默的规律可以洞悉，幽默的技巧也可以通过练习获得。</p>
<p>（2021年1月28日）</p>
<h2>什么是形式逻辑?</h2>
<p>逻辑学是研究思维形式及规律的科学。和相对论一样，逻辑学也有狭义和广义之分，狭义逻辑学单指形式逻辑，是我们在写作和言语中普通使用的逻辑；广义逻辑学除了形式逻辑之外，还包括数理逻辑、辩证逻辑等。接下来我们要研究的只是狭义的形式逻辑，并且只注重它在幽默产生中是如何被人类利用的。</p>
<p>形式逻辑的思维活动主要包括：判断、推理、概念、论证等。</p>
<h3>直接判断和条件判断</h3>
<p>直接判断是在任何条件下成立，条件判断是在一定条件下成立。</p>
<p>先看判断，判断的一种公式定义是：S是P，看一个例子：</p>
<blockquote>
<p>有人作者给编辑部寄了一份书稿，并在信中说：“编辑先生，作者首先应该注重的是内容，只有油漆工才注重外表。如果你认为我的字迹很潦草的话，那么请你随便找一个人帮助誊写好了”。编辑看完回信说：“作者先生，编辑首先注意的是外表，然后才有可能体会内容。如果你认为外表美观的稿件难以书写，那么请你随便寄来空稿纸来，我们将请随便什么人在上面书写。”</p>
</blockquote>
<p>“作者首先应该注重的是内容”与“编辑首先注意的是外表”，都是S是P的句式，这是判断。判断用下定义的方式，描述一个事物是什么样子。这是无条件的判断句式，还是这个示例，接下来再看一下什么是有条件的判断句式。有条件判断的公式定义是：如果P，那么Q。</p>
<p>“如果你认为我的字迹很潦草的话，那么请你随便找一个人帮助誊写好了”与“如果你认为外表美观的稿件难以书写，那么请你随便寄来空稿纸来，我们将请随便什么人在上面书写”，这两句都是“如果P，那么Q”的条件复句句式，都属于条件判断逻辑。而这一段话本身，包括这一句话，却是推理逻辑。关于什么是推理逻辑，下一小节会讲。</p>
<h3>三段式推理</h3>
<p>什么是推理逻辑，看一个示例：</p>
<blockquote>
<p>作家狄更斯一次在河边钓鱼，一个陌生人走过来说：“怎么，你在钓鱼？”狄更斯说：“是的，今天真倒霉，一条也没有钓到。昨天我可是钓了15条嘞。”你知道我是干什么的吗？”陌生人说，“我是专门管理这条河的河管，这条河是禁止钓鱼的。”说着河管拿出发票本，开始给狄更斯开罚单。“你知道我是干什么人吗？”狄更斯不慌不忙地说，河管被问得摸不着头脑。狄更斯对他说：“我是一名作家，你不能罚我的款，因为虚构是我的职业。”</p>
</blockquote>
<p>这个示例可能是人虚构的，但没关系，幽默与真实无关。在这个示例中，包含了推理逻辑。推理逻辑的三段式公式定义为：</p>
<pre><code>所有M是P，
所有S是M，
那么，所有S也是P。
</code></pre>
<p>具体看一下这个示例，河管认为：</p>
<blockquote>
<p>凡是在这条河上钓鱼都是要被罚款的，</p>
<p>你在这条河上钓鱼，</p>
<p>所以你也要被罚款。</p>
</blockquote>
<p>这个描述符合上面的三段式定义。再看一下狄更斯是怎么想的：</p>
<blockquote>
<p>虚构是一个作家的职业，</p>
<p>我是一名作家，我说钓了15条鱼是虚构的，</p>
<p>所以你不能发我款。</p>
</blockquote>
<p>狄更斯所想也符合推理逻辑。</p>
<p>从这两个示例也给我们另一个启发，言语中的形式逻辑不一定要与语法合拍。在狄更斯钓鱼的示例中，推理逻辑是两个人的想法，这两个想法是通过他们的话传达给我们的，是我们基于共同的语言文化理解的，并不是他们直接表达的。</p>
<p>形式逻辑虽然有形式二字，但主要还在逻辑。</p>
<h3>概念</h3>
<p>概念与判断、推理一样，都是形式逻辑的基本思维形式，而概念是最基本的，没有概念，判断与推理都无法展开。概念是反映对象特有属性或本质特征的思维形式。任何概念都包括两个方面：内涵与外延，<strong>内涵是概念中对象的基本特征或特有属性</strong>，而外延是从另一个角度描述的，<strong>外延反映的是概念的适用范围，是具有概念描述的本质特征的对象</strong>。</p>
<p>举个例子，例如三角形的概念“在二维平面上由三条互不平行又不重合的直线构成的图形”，“三条直线互不平行又不重合”就是它的内涵，而“直角三角形、钝角三角形、锐角三角形”是符合内涵定义的对象，是概念外延中的一部分。</p>
<p>概念是客观世界在人的精神世界的反映，语言是我们用于表达概念的符号。有时候偷换概念可以产生幽默效果，看一个示例：</p>
<blockquote>
<p>庙里有一个老和尚独自抚养个婴儿长大，从小让他诵读佛经，不让他沾染半点红尘。小和尚长到了十八岁，不谙俗事。一天，老和尚带他下山，路上看到一只老虎。小和尚问：“这是什么？”老和尚说：“这是女人”。小和尚说：“女人这么可怕！”回来的路上又遇到一个妙龄女郎，小和尚目不转睛地盯着女郎看。老和尚说：“这是老虎，要吃人的，快走！”小和尚回到庙中不久就病了，茶饭不思。老和尚关心地问道：“徒儿，你哪里不舒服？”小和尚说：“师傅，我想老虎！”</p>
</blockquote>
<p>在这个示例中，老和尚把“老虎”与“女人”的概念对调了，对调的只是符号，老虎和女人在现实世界中却是客观存在的，他们的本质特征并不会因为符号改变而改变。现在回想一下，幽默是什么，<strong>是一种可以自涵盖矛盾并能自圆其说的艺术存在，是人利用人的形式逻辑缺陷而制造的一种艺术之美</strong>。偷换概念将两个符号对换，以达到形式逻辑下自涵盖矛盾并能自圆其说，这就是可以复用与练习的技巧。</p>
<h3>论证</h3>
<p>论证就是用已知为真的判断去判断另一个判断是否成立。例如反证法的公式是：</p>
<pre><code>如果非P，那么Q，
现在有非Q成立，
那么，非非P也成立。
</code></pre>
<p>举个反证法的例子：</p>
<blockquote>
<p>“你又不是我肚里的蛔虫，你怎么知道我想什么？”</p>
</blockquote>
<p>一般形容一个人了解另一个人，会说是他肚里的蛔虫。上面这句话用反问的手法，反驳对方了解自己。</p>
<h3>形式逻辑的基本规律</h3>
<p>同一律、矛盾律、充足律、排中律是四个基本的形式思维规律。利用这些规律可以达到自涵盖矛盾并能自圆其说。</p>
<p>以上，了解了形式思维中的主要活动及基本规律，还不能制造幽默。一方面具体的思维活动还需要细究，另一方面与语言相关的语法、修辞、认知语用等内容还需要了解。上面本文中提到的幽默示例，仅是为了说明逻辑概念，不涉及技巧。</p>
<p>欢迎提问。</p>
<p>（2021年1月29日）</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[关于近期微信小程序登陆鉴权机制修改的小说明]]></title>
            <link>https://yishulun.com/./src/posts/2021/10.html</link>
            <guid>https://yishulun.com/./src/posts/2021/10.html</guid>
            <pubDate>Wed, 21 Apr 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>关于近期微信小程序登陆鉴权机制修改的小说明</h1>
<p>最近微信小程序的登录鉴权机制又修改了，这是历史上第三次变动了，这次变动添加了新接口wx.getUserProfile，可以在用户任意单击事件后获取用户信息，并且每次都有弹窗提示。原open-type等于getUserInfo的button单击获取准备废弃了。</p>
<p><strong>有啥直接影响？</strong></p>
<p>1，如果你的代码原来是仅靠getUserInfo获取用户信息的，没有通过后端解密，对不起，代码不能正常工作了<br>
2，如果是通过后端解密的，没有关系，通过getUserInfo button先拉取加密信息，再到后端解密这种方式仍然有效</p>
<p>为了解释这个问题，我专门录制了一个不专业的视频。</p>
<p>此外，由于小程序项目工程的复杂性，这种复杂性有时候让我自己看以前的源码都会产生迷惑，为了避免读者产生这种困扰，我在下面视频中，还讲了如何使用充电平台的课程源码，及需要注意的事项。</p>
<p>由于视频是临时录制，就不上传视频号或其它网站了，感兴趣可以直接下载：</p>
<blockquote>
<p>关于微信登陆机制修改与源码使用的说明.mp4<br>
链接：<a href="https://pan.baidu.com/s/1vkYMM-GK6Fh1_DkCAhD_6Q">https://pan.baidu.com/s/1vkYMM-GK6Fh1_DkCAhD_6Q</a><br>
提取码：liyi<br>
复制这段内容后打开百度网盘手机App，操作更方便哦</p>
</blockquote>
<p>2021年4月21日</p>
<ul>
<li>视频中提到的相关课程及错误信息截图：</li>
</ul>
<p>课程链接：<a href="https://time.geekbang.org/course/detail/100052401-289862">https://time.geekbang.org/course/detail/100052401-289862</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/2021042121003420210421202300image-20210421202258167.png" alt="image-20210421202258167"></p>
<ul>
<li>
<p>登录接口调整官方说明：<a href="https://developers.weixin.qq.com/community/develop/doc/000cacfa20ce88df04cb468bc52801?highLine=login">https://developers.weixin.qq.com/community/develop/doc/000cacfa20ce88df04cb468bc52801?highLine=login</a></p>
</li>
<li>
<p>新接口getUserProfile地址：<a href="https://developers.weixin.qq.com/miniprogram/dev/api/open-api/user-info/wx.getUserProfile.html">https://developers.weixin.qq.com/miniprogram/dev/api/open-api/user-info/wx.getUserProfile.html</a></p>
</li>
</ul>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[Go更了解程序员]]></title>
            <link>https://yishulun.com/./src/posts/2021/17.html</link>
            <guid>https://yishulun.com/./src/posts/2021/17.html</guid>
            <pubDate>Sun, 18 Apr 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>Go更了解程序员</h1>
<p>程序员喜欢Go语言，是因为Go简单、易于上手、高效吗？不，是因为Go更了解程序员，它知道程序员喜欢什么，不喜欢什么。程序员口中的简单、易于上手，高效，那是对它的赞美。实际上如果你不是程序员，从零入门Go编程仍然是不太容易的。</p>
<p>而且更有可能出现的一种情况是，因为Go语言的极致简洁，反而让初学者觉得这太难了；而真正对编程感兴趣的人，会一下子喜欢上它，觉得太棒了。Go是一门语言，也是一面镜子，你适不适合做程序员，学习一下Go就知道了。</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[typora软件也是可以定制的]]></title>
            <link>https://yishulun.com/./src/posts/2021/18.html</link>
            <guid>https://yishulun.com/./src/posts/2021/18.html</guid>
            <pubDate>Fri, 16 Apr 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>typora软件也是可以定制的</h1>
<p>最近一年的写作我基本都在使用typora软件，这个软件搞平台，干净、高效，我非常喜欢它。如果说缺点，它唯一的缺点就是不支持定制。</p>
<p>但是今天发现了一个扩展：</p>
<p><a href="https://github.com/hahaha28/typora-extensions">https://github.com/hahaha28/typora-extensions</a></p>
<p>以及使用npm安装的asar工具，及使用它的指令：</p>
<pre><code>安装asar
cnpm install -g asar

用 asar pack 打包
asar pack your-app app.asar

用 asar extract 反编译/解压
asar extract app.asar ./myapp
</code></pre>
<p>新世界仿佛被打开了，原来typora也是一个基于electron开发的软件，在使用它的时候完全感受不出来。我使用typora的时候，一直觉得它是原生软件。但是的样式支持定制，并且样式包也是前端html &amp; css文件，从这点我也应该想到，甚至这个有可能也是基于electron开发的，至少它是混合开发的。</p>
<pre><code>那么typora是开源软件吗？
很遗憾，虽然typora软件在github上有主页，但是它本身并不是一个开源软件。
</code></pre>
<p>虽然typora不开源，但是通过上面的方面，我们可以扩展它的UI，还可以插入代码，通过这种方式基本也可以达到扩展的目的。</p>
<blockquote>
<p>20221221更新：软件不身不开源，通用hack的方式尝试修改它，这个体验并不好。</p>
</blockquote>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[简单的逻辑学读书笔记]]></title>
            <link>https://yishulun.com/./src/posts/2021/34.html</link>
            <guid>https://yishulun.com/./src/posts/2021/34.html</guid>
            <pubDate>Thu, 15 Apr 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>《简单的逻辑学》读书笔记</h1>
<p>这本只有 150 页的小书，享誉世界，你读了之后可能觉得它不是那么的名副其实。但最好不要这样想，它毕竟只有150页，字数很少，语言又要通俗化，所以读了之后感觉有点不解渴，可能是正常现象。还有，如果你觉得它不过尔尔，可能你的逻辑能力确实不错，而这本书讲述的道理你大多都懂，同时它所鞭挞的非逻辑思维的恶习你却没有。</p>
<p>我在知乎上看到有人说，译者把书名译错了，不应该叫「简单的逻辑学」。其实这可能是一种意译，外加一点市场考量。</p>
<p>这本书主要分为五部分：</p>
<ul>
<li>学习逻辑学前的准备，主要先透露一些概念</li>
<li>逻辑学的基本原理，这里主要讲了狭义逻辑学中的四个规律：同一律、矛盾律、排中律和充足理由律（因果律）</li>
<li>逻辑思维的语言，这个就像数学里的公式，讲逻辑思维的行话怎么讲</li>
<li>非逻辑思维的根源，这主要从各个方面讲非逻辑思维问题存在的根源</li>
<li>非逻辑思维的主要形式，主要讲上一部分的具体表现形式</li>
</ul>
<p>第一部分是准备，因为有一些概念读者可能不了解，所以作者提前作了一些铺垫，但有一些铺垫并没有做足，我们在阅读中可以发现，后来有些概念并非属于常识，在第一部分中没有讲；第二部分就直接讲逻辑学的基本规律了；第三部分讲这些规律如何运用，就是逻辑学是语言学，所以主要是讲逻辑思维的语言如何表达；第四部分和第五部分，是对非逻辑思维的批判，在作者看来它们可能是有罪的，但在我看来，它们却是产生艺术之美的养料。</p>
<p>这本书篇幅很小，并且书边还留有许多印刷空白。正如作者在前言中所讲，它并不是作为教科书来写的，而是作为一本茶余饭后的散文小书来写的。因此，这本书阅读起来并不困难。</p>
<h2>狭义逻辑学的四辆马车</h2>
<p>但也因此，这本讲逻辑的书，整体看起来结构并不是十分富有逻辑。为什么这样讲，提一个点，有人读了以后问，排中律和同一律为什么是两个独立的律，它俩不是一样的吗？</p>
<p>这涉及概念空间的分布。就像我们给二维空间划定象限，它有四个象限。充足理由律、矛盾律、同一律和排中律，这四个基本规律，只有充足理由律（又叫因果律）是真正的逻辑规律，而其它三个规律都在尝试给概念划定界线，都是讲如何区别概念的规律，都在为因果律服务。并且这个区分，像二维平面的象限分布一样，是均衡的。下面我们看一下。</p>
<img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/20210415122351image-20210415122344890.png" alt="image-20210415122344890" style="zoom: 67%;" />
<p><strong>首先，同一律。<strong>它是区别</strong>一个概念与另一个概念</strong>的，它是将事物在概念上从大千世界中摘出来的一个规律。</p>
<p><strong>其次，排中律。<strong>事物的</strong>发展都是分不同阶段的，每个阶段有不同的状态</strong>，在同一律将事物在概念上从大千世界中摘出来以后，剩下的就是这个事物的许多状态了，一个事物不可能同时处于两个状态，排中律是区分事物处于哪个状态的。（此处莫拿量子力学反驳，量力子学人类还没有完完全全搞明白）</p>
<p><strong>最后，矛盾律。<strong>事情的发展不仅有多个阶段，有多个状态，并且在</strong>每个状态下，还有多个方面</strong>。矛盾律说，在某个时刻，在某一方面，对事物的描述不能是矛盾的，必须是一致的。即使在一个状态中，事情普通是具有多面性的，矛盾是普遍存在的。矛盾律是将事物从多个方面中区别开来的规律。</p>
<p>所以你看，从先众多中分享，再从多个状态中分享，最从从多个方面中分享，这三个规律干的都是同一件事，就是界定概念。界定概念，是为<strong>因果律</strong>，也就是<strong>充足理由率</strong>服务的。</p>
<h2>第一部分 逻辑思维的认知准备</h2>
<p>这一部分主要讲逻辑思维的认知准备，逻辑思维范围内的常识。</p>
<h3><strong>观念</strong></h3>
<p>1.3节有这么一句：</p>
<blockquote>
<p>正确观念忠实地反映了对象的客观秩序，错误观念是对现实世界的扭曲表达。</p>
</blockquote>
<p>这里用正确与错误不太贴切，用真假与虚假更为贴切：</p>
<blockquote>
<p>真实观念忠实地反映了对象的客观秩序，虚拟观念是对现实世界的扭曲表达。</p>
</blockquote>
<p>凡涉及到正确与错误，必然要有一个评判对错的标准，这是标准是因主体而异的。而真实和虚假，就仅涉及到精确度了。老老实实地客观反映，就是真实的；故意撒谎或认知不清，就是虚假的。</p>
<p>但人类本身可以感知世界的能力也是有限的，所以所谓真假，也是在当前条件下的一个精确度问题。</p>
<h3><strong>事物</strong></h3>
<p>1.2小节，有这一句：</p>
<blockquote>
<p>&quot;事实的客观实在有两种基本形式：事物和事件。&quot;</p>
</blockquote>
<p>事即是事，物即是物，在英文中有Thing这个单词，既有事情，又有东西的意思，所以这个地方翻译为「实物和事件」更为妥当，简单点讲就是「事物」。事实上在后面的文字中，作者多处以事物指代事情和实物。</p>
<h3><strong>有效沟通</strong></h3>
<p>1.7节说，有效沟通有这几点需要注意：</p>
<ol>
<li>不要想当然地认为听众知道你没有表达出来的意思</li>
<li>把句子讲完，使用完整的陈述句</li>
<li>不要把主观事实当成客观事实</li>
<li>了解听众</li>
</ol>
<p>这几点好像找不出内在的联系，完全是松散的。</p>
<p>还可以加上后面两节补充的要点：</p>
<ol>
<li>不要使用模糊和有歧义的语言</li>
<li>直接表达，不使用闪避式语言，例如一个不直陈目的的词汇「终极文案」</li>
</ol>
<p>事实上，后面两个经常被利用，用于创造幽默的艺术效果。</p>
<h3><strong>语言</strong></h3>
<p>1.5节说：</p>
<blockquote>
<p>人类认识有3部分组成：1，客观存在的事物；2，事物在大脑中的反映；3，人类创造的语言。</p>
</blockquote>
<p>1.6节中说：</p>
<blockquote>
<p>语言要忠实地表达客观事物，这是我们沟通的坚实基础。</p>
</blockquote>
<p>这里有一个延伸问题：语言、观念是怎么产生的？</p>
<p>并不一定是先有观念，也一一定是先有语言，它们应该像鸡与蛋一样，是协作进化的。有了语言，可以促进观念的形成，可以促进人类的学习；有了观念，语言才能有所指，才能在意识中有所附着。</p>
<p>那么在婴儿时期，观念与语言谁先产生呢？应该是观念。像牛头马面这样的观念，在现实世界中并不存在，只存在于语言和观念中，在第一个创造它的人有脑海中，一定先有了这个观念，继而发明了这个词汇。其它字词也是这样，像日、月、星、辰等，是先有了观念，再创造了表达它们的语言和文字。</p>
<p>这里又有一个延伸问题：既然人类有语言的历史有100万年，有文字的历史才1万年，那么在产生文字之前，人类，尤其是使用象形文字语言的民族，例如华夏民族，是怎么交流的呢？</p>
<h3>真相</h3>
<p>1.10节说：</p>
<blockquote>
<p>真相有两类：一类为本体真相，一类为逻辑真相。</p>
</blockquote>
<p>所谓逻辑真相，就是在现实世界中找不到影子，但是从逻辑上人类认为正确的事物。这也就是说，逻辑真相只存在于人的脑海中，它属于主观事实。</p>
<p>有人可能会说，逻辑真相只是还没有找到客观存在的对象，而主观事实却是不存在。</p>
<p>不对，找不到和不能找到，都是人类的判断，现在找不到，并不代表以后找不到，这里没有本质的区别。拿牛头马面来说，现在没有牛头马面，认为它只是主观事实，但如果以后真有牛头马面的动物出现了呢？</p>
<h3>主观事实</h3>
<p>1.4节中说，我们的大脑中有一个猫的观念，语言中有一个「猫」的词汇，现实中有一个猫的实体。猫是客观事实。</p>
<p>而「牛头马面」只存在于我们的脑海中，在现实中并不存在，所以它只是一个主观事实。</p>
<p>所以，在这里，在逻辑学中，主观事实与客观事实都被承认为事实。事实上，由于人类感知大官的受限，我们接触到的客观事实也是一定程度上的主观映射，并不存在真正的100%的「客观事实」，本质上主观事实和客观事实都是一样的。</p>
<p>主观事实与客观事实的区别在于，前者在现实中没有对应的对象，后者有。</p>
<p>第二部分 逻辑思维的基本规律<br>
第三部分 逻辑思维使用的语言<br>
第四部分 非逻辑思维的根源<br>
第五部分 非逻辑思维的主要形式</p>
<p>（这就些）</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[伟大的人都是在用生命吟唱]]></title>
            <link>https://yishulun.com/./src/posts/2021/13.html</link>
            <guid>https://yishulun.com/./src/posts/2021/13.html</guid>
            <pubDate>Wed, 14 Apr 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>伟大的人都是在用生命吟唱</h1>
<p>昨天听完张爱玲传就有这个感觉，今天听完杜甫传，感觉更强烈了。</p>
<p>不知道是所有伟大的人都在用生命在吟唱，还是所有生命都非常伟大，只是我们不了解；如果深入了解，每个生命都可敬可叹，而在历史长河中，只有少数幸运的人，才得以星光璀璨。</p>
<p>可能不是这样的。</p>
<p>或许每个人在历史长河中，都像那河床上的鹅卵石，虽然每个人都可能最终被磨圆了，但大部分人都是普普通通的，只有极个别的人才纯粹剔透，算得上玉石佳品。</p>
<p>杜甫就是这样的一个人。像杜甫、李白这样的人，起初他们在世时，其实并不耀眼，仅是被所经之地的少数人知晓。杜甫被尊为诗圣，李白被尊为诗仙，这是他们亡故以后的事。</p>
<p>杜甫在世时，半世漂泊流离，仿佛苦难是他源源不断创作的灵感，不可或缺；如果让今天的人来选择，给你身后诗圣的名号，请你享受当下穷困潦倒之苦，恐怕没人愿意。</p>
<p>杜甫晚年生活艰难，搞些草药在街上售卖，这一年在江南遇到了李龟年，李龟年和他一样，也在街上讨生活。于是就有了杜甫那一篇名作《江南逢李龟年》：</p>
<blockquote>
<p>岐王宅里寻常见，崔九堂前几度闻。<br/><br>
正是江南好风景，落花时节又逢君。</p>
</blockquote>
<p>以前都是在王公贵族府里才能见到的，这么一个才华横溢的人（李龟年），如今却沦落到了街头卖艺的地步。瞧这江南的风景，是多好啊，多年以后，在这样的落花时节，又见到多年老友，不知道以后还有没有时间再见。</p>
<p>这一年是公元770年，同年此后不久杜甫就去世了。这首诗语句平淡无奇，但却饱含辛酸，尤其是最后两句，有「欲说还休，却道天凉好个秋」的意味。</p>
<img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/20210414151041d63a48fcb43262878a7aa0fa8800b18.jpg" style="zoom:33%;" />
<p>我听了这本书以后，感叹很多，但又不知道从哪里写起。或许只能发一些「像杜甫、李白这样的人，他们一生就是在生命吟唱」这样的感慨吧。</p>
<p>兹涂诗一首，以纪念之：</p>
<p><strong>听《杜甫传》有感</strong></p>
<blockquote>
<p>一生飘泊苦，万世奉为神。<br/><br>
都说人传艺，谁云艺立人?</p>
</blockquote>
<p>在信手涂这首小诗时，我突然发现，或许不是杜甫用生命创造了千年传颂的诗文艺术，而是诗文的艺术之美，撑住了杜甫支离破碎的一生。</p>
<p>所以，艺术是帮助人化解苦难和悲痛的。</p>
<p>2021年4月14日</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[关于如何选题终于找到了答案]]></title>
            <link>https://yishulun.com/./src/posts/2021/09.html</link>
            <guid>https://yishulun.com/./src/posts/2021/09.html</guid>
            <pubDate>Tue, 13 Apr 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>关于如何选题终于找到了答案</h1>
<p>一直以来有这样一个疑惑：</p>
<p>究竟我们应该从自己的目标出发选题，还是应该从大众需要的角度出发选题？换言之，我们应该坚持自己，还是追逐当下热点？</p>
<p>今天突然想表白了。这两个方向并不是矛盾的，我们应该从价值的洼地出发做选择。这两个方向，它们只是一个问题的两个方面，当我们从价值洼地出发做选择时，矛盾便不存在了。</p>
<p>什么是价值洼地，如何理解？假设我们的作品创作出来了，与当下社会人文的现状，有多大的差距，这个洼地就有多深。有时候这个问题还可以表述为，选择最难的事，或者选择大众误解最深的事，或者选择社会中最应该被纠正的事，等等，这些都些从价值洼地选择的另一种角度的描述。</p>
<p>那么，我们为什么要从价值洼地做选择呢？因为从这个地方选择，最经济，单位精力能够创造的艺术美最大。</p>
<p>从哲学上讲，人活着的意义就是「走着瞧」，就是不断创造「自己」，「自己」是不断被创造出来的。创造艺术美，给别人带来欢乐和治愈，这本身就是功德。</p>
<p>像《吐槽大会》的脱口秀学员，还有被贬黄州的苏轼，他们都是在以不同方式，创造不同形式的艺术之美。如果人是由上帝创造出来的，上帝是存在的话，那么上帝已经给人设定了最佳的奖励方式。这个方式就是，人无论是感受艺术美，还是创造艺术美，人都会获得愉悦。</p>
<p>2021年4月13日</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[你的顾客需要一个好故事]]></title>
            <link>https://yishulun.com/./src/posts/2021/12.html</link>
            <guid>https://yishulun.com/./src/posts/2021/12.html</guid>
            <pubDate>Tue, 13 Apr 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>你的顾客需要一个好故事</h1>
<p>事实上并非只有商家的顾客才需要这样一个好故事，包括我自己，手艺人，发电员的读者，也需要一个好故事。这个故事不是常规意义上的故事，事实上它是一个让读者成为主角，充满艺术之美的故事。</p>
<p>如何创造这样的一个好故事呢？有七个关键因素，书中作者称之为SB-7，这是一个很特别，但在中文环境确实又很容易记住的简称。</p>
<p>SB-7:</p>
<ol>
<li>一个主角</li>
<li>遇到一个麻烦</li>
<li>出现一个向导</li>
<li>向导手里有一个方案</li>
<li>召唤主角，开始行动吧</li>
<li>避免主角失败</li>
<li>麻烦得到解决，获得成功</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/20210413131937314ab4b3a16a82aec6946252689a85f.jpg" style="zoom: 50%;" />]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[《张爱玲传》值得一读]]></title>
            <link>https://yishulun.com/./src/posts/2021/16.html</link>
            <guid>https://yishulun.com/./src/posts/2021/16.html</guid>
            <pubDate>Tue, 13 Apr 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>《张爱玲传》值得一读</h1>
<p>在听这本书之前，我一直对张爱玲有误解。</p>
<p>我一直以为张爱玲是一位成长在深闺中、多愁善感的大小姐，笔下作品多男女情爱之事。听了以后，我觉得张爱玲是一个英雄，一个灵魂纯粹的英雄，一个众多男子都未能及她的人生战士。</p>
<p>张在4岁的时候，她妈妈就离开了她，她与继母生活中一起。17岁有一天她去看望生母，归家后继母怪她出门未告，打了她一巴掌。张觉得很委屈，与继母撕打，被父亲看到，张父抓住她的头发，往墙上撞，后又将她关在屋里，不准出来，即使张生病了也不给她看医生。</p>
<p>张细心研究家里的岗哨，终于在半年后，找准换岗间隙，扶着墙逃了出来。</p>
<p>这个经历，肯定对张的影响非常非常大。个人感觉，她性格中既敏感又自卑的部分，与这段家庭经历不无关系。后来她到美国后，与秃顶老头赖雅恋爱结婚，他们婚后不久，赖雅就中风了，从此赖雅成为张爱玲中老年岁月中十几年的压力和累赘。</p>
<p>张肯定值得更好的伴侣，但她从来没有挑剔别人，甚至以为自己可以挑剔别人，在爱情这件事上，她毫不世俗。包括她与胡兰成的恋情也是，她甚至从来不觉得胡配不上她，她只是惧怕。有一次，她和胡在街上散步时，胡说：“你身材这么高”，敏感的她，一下捕捉到了胡的自卑，她一下子与胡坠入了爱河。</p>
<p>她内心太自卑了，当她感觉到这段感悟有一丝安全时，她封闭的城门却打开了。后来在美国，她与秃顶老头赖雅估计也是相同的遭遇。或许赖雅也在她面前表现出了自卑。</p>
<p>很奇怪，一个不缺少自卑的人，却极易沦陷于他人的自卑。</p>
<p>这是关于张的爱情，另外还有一个关于张的谋生，听了之后也很感触。一个人无论多么富有才华，如果生不逢世，时间、究竟不对，即使有名气，也会受穷受挫。</p>
<p>张在上海成名以后，后来到了美国，那时候她已经是一位在中国香港、台湾富有名气的作家了，但她当时为了生活，还不得不挤在贫民窟里，不得不申请作家村的援助。</p>
<p>早年她拒绝过为港星写剧本，后来在这种宭迫的生活下，也不得不接受剧本撰写的邀约。这里至少说明两点：</p>
<ol>
<li>张不擅长经营自己</li>
<li>张在创作上非常有自己的主张，她有一些自己坚持的东西</li>
</ol>
<p>还有值得一提的是，张纠结20年，生前都未曾出版的小说《小团圆》：</p>
<img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/2021041318441720210413184417.png" style="zoom: 67%;" />
<p>是她对爱情美满的一种企图自圆。她喜欢美，她想让自己的爱情美满一些，希望从中找寻出一些意义，但是直至故去，都未能如愿。</p>
<img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/2021041318471669de29b9da6c70713238e276739497f.jpg" style="zoom: 33%;" />
<p>2021年4月13日</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[夜晚跳广场舞归来有感]]></title>
            <link>https://yishulun.com/./src/posts/2021/15.html</link>
            <guid>https://yishulun.com/./src/posts/2021/15.html</guid>
            <pubDate>Fri, 09 Apr 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>夜晚跳广场舞归来有感</h1>
<blockquote>
<p>狗来人避让，车走路通行。<br>
广场舞喧天，孑然背手归。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/2021041415413920210414154139.png" alt=""></p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[关于找不到wx-components文件的说明]]></title>
            <link>https://yishulun.com/./src/posts/2021/11.html</link>
            <guid>https://yishulun.com/./src/posts/2021/11.html</guid>
            <pubDate>Tue, 06 Apr 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>关于找不到wx-components文件的说明</h1>
<p>这是在充电平台上小程序课程下的一个读者问题：</p>
<blockquote>
<p>老师，关于在特殊情况下需要修改微信自带组件和weui组件样式，现在课程上的方法无法找到对应得样式了。</p>
</blockquote>
<p>这个问题似曾相识啊</p>
<p>我在我的windows PC上试了一下，通过搜索wx-components文件名称，确实找不到默认的样式文件了。</p>
<p>可能更新微信开发者工具后，被官方限制了，毕竟这只是一个hack方法。</p>
<p>文件找不到，样式也被修改了吗？于是旧老办法，修改progress组件的样式：</p>
<pre><code>.progress-box{
  width: 80%;
  margin:50px 20px;
}
.wx-progress-inner-bar {
  border-radius: 5px;
}
</code></pre>
<p>运行结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/2021040617442220210406174421.png" alt=""></p>
<p>哼，只是文件被藏起来了。毕竟重构样式名称可能涉及范围太大，所以官方并没有这样做。</p>
<p>本地搜索不到wx-components.css，没关系。网上有：<a href="https://gist.github.com/imoldman/b0f3332cb5713000e8fdef14b97080ab%E3%80%82%E4%BB%8E%E6%B2%A1%E6%9C%89%E6%9B%B4%E6%96%B0%E7%9A%84%E6%97%A7%E6%9C%BA%E5%99%A8%E4%B8%8A%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%89%BE%E5%88%B0%E3%80%82Mac%E6%B2%A1%E6%9C%89%E6%B5%8B%E8%AF%95%EF%BC%8C%E5%8F%AF%E8%83%BD%E6%9B%B4%E6%96%B0%E5%90%8E%E4%B9%9F%E6%89%BE%E4%B8%8D%E5%88%B0%E4%BA%86%E3%80%82">https://gist.github.com/imoldman/b0f3332cb5713000e8fdef14b97080ab。从没有更新的旧机器上也可以找到。Mac没有测试，可能更新后也找不到了。</a></p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[薇娅的成长之路]]></title>
            <link>https://yishulun.com/./src/posts/2021/14.html</link>
            <guid>https://yishulun.com/./src/posts/2021/14.html</guid>
            <pubDate>Thu, 01 Apr 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>薇娅的成长之路</h1>
<p>以下文字受启发于《薇娅：人生是用来改变的》。我是通过攀登读书了解这本书的。</p>
<p>原来我也以为薇娅是在直播界横空出世的，其实不是的。早年她在动物园做站版模特卖换季服装，当时的经历就锻造了今天的好口才、快反应及持久工作的能力，当时她是在拥挤的店里要站一天连续工作，并且在冬天里只穿很少的春夏衣服。</p>
<p>她对市场很敏感。当她看到一个女孩到她店里试完衣服不买，而是到淘宝上下单的时候，她就萌生了开网店的想法。</p>
<p>她很有韧性。放弃线下成功的服装店，杀入线上网店，因为不懂运营，经营效果不好。但却一直没有放弃。<br>
她还有不错的延迟满足感。淘宝直播刚起步的时候，小二找到她，想让她直播，当时只是能挂店铺链接，还不能直接卖货，并且直播没有直接的报酬，她也答应了。</p>
<p>薇娅身材保持的好，拍照片好看，做网店的时候就帮助其它店铺拍照片，做过淘女郎。这也是后来淘宝小二找她直播的原因。还有，她开始开的网店，就是因为一她拍的照片太美，而上了双11的推荐频道，从而带来了流量。包括刚步入社会时，她可以在店里做站版模特，在2002年上半天班就可以拿到1800块钱，这与她的天生丽质也是分不开的。这是她天生的资源。</p>
<p>薇娅的成功，是整合了个人资质，个人喜受，个人努力和社会需要的一种必然。在快速发展的今天，每个人都有机会，但并不是每个人都能抓住机会。</p>
<p>访谈中攀登又提到，子有四绝：勿意、勿必、勿固、勿我。这一点在薇娅身上也得到了体现。优秀的人总是相似的，总是有相似的优秀品质，子四绝便是。</p>
<p>这个访谈中还提到一个古老的话题，我是谁？</p>
<p>这个哲学问题，貌似已经有答案了，就是「走着瞧」。我们最终是谁，完全是我们自己活出来的，人生活着的意义就在于不断创造新的自己。</p>
<p>这个访谈中还提到另一本书《混乱》，书中有箴言：「无论命运将你抛到任何地方，只需要就地展开，做自己力所能及的事情」。这是一种「随地生长」的精神，这个精神在单身家庭成长的薇娅身上也有强烈的体现。</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[插入广告的正确姿势]]></title>
            <link>https://yishulun.com/./src/posts/2021/2.html</link>
            <guid>https://yishulun.com/./src/posts/2021/2.html</guid>
            <pubDate>Wed, 31 Mar 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>插入广告的正确姿势</h1>
<p>突然发现，原来在某乎这样插入广告就可以。某乎的这个广告过滤机制，应该是机器操纵的，它知道人一般会怎么样去插入广告。最好的公众号的插入方式，都可以统一都改成这样的方式，单独放一个链接，在上面放上引语。不要直接写「关注公众号」这样的字词。</p>
<img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/20210331123513image-20210331123507005.png" alt="image-20210331123507005" style="zoom:33%;" />]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[关于录制视频直人更多出镜的想法]]></title>
            <link>https://yishulun.com/./src/posts/2021/4.html</link>
            <guid>https://yishulun.com/./src/posts/2021/4.html</guid>
            <pubDate>Wed, 31 Mar 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>关于录制视频直人更多出镜的想法</h1>
<p>视频录制应该真人出镜，并且应该争取在大多数情况下都是真人正面全景出镜。个别的时间点，我们需要展示具体的文字或图片的时候，可以在视频剪辑的时候插入画中画。</p>
<p>必须的时候，可能需要购买一个高清摄像头，放在电视机上面，并且把它作为主要的视频录制设备。</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[生活如何艺术化与视频录制]]></title>
            <link>https://yishulun.com/./src/posts/2021/5.html</link>
            <guid>https://yishulun.com/./src/posts/2021/5.html</guid>
            <pubDate>Wed, 31 Mar 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>生活如何艺术化与视频录制</h1>
<p>在视频号上看到这个视频，突然有了想法，主要是两点：</p>
<ol>
<li>个人视频要露脸、露人，展示自己，在这个视频中，即使是展示编曲过程，小作者也是出镜的</li>
<li>关于艺术生活化，其实艺术可以渗透到生活中的每个角落，并不一定非要以目前的演唱会、博物馆这样的形式存在</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/20210331131239image-20210331131237755.png" alt="image-20210331131237755" style="zoom:33%;" />
<p>视频号无法提供二维码，也没有链接，感兴趣可以搜索一下。b站也有。这种艺术形式，可以形成高低差，有很大的传播效应。</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[忽然想起一个第一人称写作技巧]]></title>
            <link>https://yishulun.com/./src/posts/2021/6.html</link>
            <guid>https://yishulun.com/./src/posts/2021/6.html</guid>
            <pubDate>Tue, 30 Mar 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>忽然想起一个第一人称写作技巧</h1>
<p>为了说明问题，先引用一段余秋雨《文化苦旅》《阳关雪》中的几段话：</p>
<blockquote>
<p>一走出小小的县城，便是沙漠。除了茫茫一片雪白，什么也没有，连一个皱折也找不到。在别地赶路，总要每一段为自己找一个目标，盯着一棵树，赶过去，然后再盯着一块石头，赶过去。在这里，睁疼了眼也看不见一个目标，哪怕是一片枯叶，一个黑点。于是，只好抬起头来看天。从未见过这样完整的天，一点儿也没有被吞食，边沿全是挺展展的，紧扎扎地把大地罩了个严实。有这样的地，天才叫天。有这样的天，地才叫地。在这样的天地中独个儿行走，侏儒也变成了巨人。在这样的天地中独个儿行走，巨人也变成了侏儒。</p>
<p>天竟晴了，风也停了，阳光很好。没想到沙漠中的雪化得这样快，才片刻，地上已见斑斑沙底，却不见湿痕。</p>
<p>天边渐渐飘出几缕烟迹，并不动，却在加深，疑惑半晌，才发现，那是刚刚化雪的山脊。</p>
<p>地上的凹凸已成了一种令人惊骇的铺陈，只可能有一种理解：那全是远年的坟堆。</p>
</blockquote>
<p>在技巧上有两点值得说一下，一句是“在这样的天地中独个儿行走，侏儒也变成了巨人。在这样的天地中独个儿行走，巨人也变成了侏儒”，这种对比式排句很有意思。</p>
<p>但它还不是高级的技巧。下面这句“<strong>天边渐渐飘出几缕烟迹，并不动，却在加深，疑惑半晌，才发现，那是刚刚化雪的山脊</strong>”，这里用了第一人称，直接写了作者的主观感受，“天边渐渐飘出几缕烟迹”，烟迹就是作者的主观观受。作者知道这其实不是烟迹，但作者在用第一人称视角，在向我们再现他当时的感受。</p>
<p>在写技术类书籍时，有时候实战项目进行到某一阶段的时候，难免会出一些问题。虽然我们知道问题是怎么回事，但是最好当时不要说破，而是像余老师一样，只写当时的感受，让读者感同身受。最后再揭露答案。</p>
<p>与时俱进，用发展的眼光，用行走的视角写科普文字，写教育文学。感谢余老师，激发我的创作灵感。</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[巴黎是如何成为时尚之都的]]></title>
            <link>https://yishulun.com/./src/posts/2021/1.html</link>
            <guid>https://yishulun.com/./src/posts/2021/1.html</guid>
            <pubDate>Mon, 29 Mar 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>巴黎是如何成为时尚之都的</h1>
<p>巴黎，用100年的时间，由一个街上满是泥泞，没人愿意走路，一个夜间有野狼出没的城市，变成了今天的世界时尚之都。</p>
<p>时髦，这个词的含义在法国的字典里就是外国人来到巴黎学习怎么穿衣服。这个定义太过分了。</p>
<p>这个巨变是怎么产生的呢？每年很多人去巴黎旅游的，如果只是在百货商场打个卡，在博物馆打个卡，而不了解巴黎这座城市成长历史的话，根本就不会知道林荫大道、孚日广场、塞纳河老桥？圣路易岛，还有五苏老马车的魅力。</p>
<p>这个转变，在我看来在于两个字：连接。打造公共场所，让人与人之间的连接更加频繁；推倒城市的城墙，和人际之间看不见的城墙，让人与人之间的链接没有阻碍。</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[关于价值的判定]]></title>
            <link>https://yishulun.com/./src/posts/2021/3.html</link>
            <guid>https://yishulun.com/./src/posts/2021/3.html</guid>
            <pubDate>Sun, 28 Mar 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>关于价值的判定</h1>
<p>我们是如何判定一件事的价值的呢？靠知识与逻辑经验？靠经验？还是靠直觉？如果没有经验，又不具备相关的知识，一般我们是很难判定一件事的价值的。所以一般人很难突破自己，主要是因为不具备价值界定与判断的能力。试想一下，如果将时光倒回10年，你会做什么事？<br>
有人说，我会在北京回龙观买房。但是当时，你可能也知道这个房源信息，当时没有行动，主要原因在于你当时无法界定这件事的价值。<br>
有的人靠直觉，即使他没有相关经验，也无法从知识与逻辑上证明某件事能成，但是就坚定不移地做了。有时候这种直觉又被称为商业嗅觉。</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[提问的艺术]]></title>
            <link>https://yishulun.com/./src/posts/2021/30.html</link>
            <guid>https://yishulun.com/./src/posts/2021/30.html</guid>
            <pubDate>Fri, 26 Mar 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>提问的艺术</h1>
<p>这篇内容主要写给初学者，高手或老手可以略过了。</p>
<p>初学者有两个问题很显著：</p>
<ol>
<li>不会提问</li>
<li>不会搜索</li>
</ol>
<h2><strong>先说搜索</strong></h2>
<p>搜索一定要选择谷歌，不要用其它的搜索引擎。如果所在地区访问不了谷歌，可以安装谷歌浏览器，然后安装一个名称为「谷歌访问助手」的插件。搜索一下，网上有。</p>
<p>有了工具以后，具体查询的时候要注意用合适的关键词。基本原则是将我们自己问题中的关键字拿出来，输入进去，如果结果不理想，可以稍微变换一下关键字。选择关键字，主要靠经验，用的多了自然就准确了。</p>
<h2><strong>再说提问</strong></h2>
<p>这比搜索更重要。</p>
<p>很多新人不会提问。最近有一位读者在微信上私信问我问题，他上来只发了一句话：</p>
<blockquote>
<p>老师请教个问题</p>
</blockquote>
<p>然后就发了一个截图，截图中也没有错误信息，其它什么内容都没了。这件事给我造成了很大阴影，本来我就不喜欢微信这样断断续续的聊天，我觉得这种沟通方式很浪费时间。</p>
<p>关于提问的艺术，有个老外写了一篇「提问圣经」，国人翻译了中文版，见这里：<a href="https://learnku.com/docs/guide/smart-questions/2032%E3%80%82">https://learnku.com/docs/guide/smart-questions/2032。</a></p>
<p>这篇内容写的很好，但内容很多，我提炼一下，有以下几点特别值得注意：</p>
<ol>
<li>在提问之前，先尝试谷歌一下。除了谷歌，还可以尝试翻一下软件的FAQ文档或issue列表。</li>
<li>好问题本来就具有价值，所以要尽力提出有<strong>价值的问题</strong>。什么是无价值问题？那些通过搜索引擎查一查就能得到的答案，就是无价值或低价值问题。</li>
<li>如果是代码问题，在请教别人之前，一定要准备一个「最小测试样例」，并且要告诉别人怎么运行你的代码。这一点很重要，特别当问题是bug相关的时候。你想要别人帮你找出bug，就要把代码共享出来。如果是微信小程序，最好的方式是提供代码链接。其它技术或语言，可以提供github仓库链接。</li>
<li>在描述问题时，要尽量把问题和问题存在的基础描述清楚。写明白期望是什么，现象是什么。如果是调用了接口，怀疑调用代码有问题，一定要把接口文档或说明附上。总之，要保证用于解决问题的信息是对称的，因为别人不是你，不可能知道你脑袋里有什么。</li>
<li>基本的社交礼貌要具备。人与人都是平等的，不需要低三下四，但也绝不能认为理所当然。别人没有义务一定帮你，有可能是不了解，有可能是没有时间，都有可能。但要有自尊，不能因为别人不理你就情绪失控。</li>
</ol>
<p>原文有这么一句话对我印象深刻：</p>
<blockquote>
<p>我们回答问题的风格是为了适应那些真正对此有兴趣并愿意主动参与与解决问题的人，这一点不会变，也不该变。如果连这都变了，我们就会在自己能做得到的最好的事情上不再那么犀利。</p>
</blockquote>
<p>有这种态度的人，是真正的程序员。他们就像穿山甲，因为要穿山，所以练就了一副硬壳，没有了这副装备就什么也不是了。</p>
<p>2021年3月15日</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[如何做好一场技术演讲学习笔记]]></title>
            <link>https://yishulun.com/./src/posts/2021/29.html</link>
            <guid>https://yishulun.com/./src/posts/2021/29.html</guid>
            <pubDate>Thu, 25 Mar 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>如何做好一场技术演讲学习笔记</h1>
<h2>| 演讲之前需要做好哪些准备？现场由听众提需求吧</h2>
<p><strong>Stay hungry, Stay foolish！</strong></p>
<p>没有想到，流传已久的乔布斯斯坦福毕业演讲，却是他精心准备至少好几天的结果，尽管他当时已经是一位富有现场演讲经验的老手了。</p>
<p>这篇充电平台创立之初发布的小专栏，确实非常非常有价值。题目虽然是《如何做好一篇技术演讲》，但是却也适用于写作等其它需要做内容输出的地方。</p>
<p>概括来讲，这篇内容主要讲了三部分：</p>
<ol>
<li>精心准备内容；</li>
<li>做刻意练习，精益求精；</li>
<li>调整好心理状态。</li>
</ol>
<p>在第一部分，作者还拿研发的工程环节与演讲做了类比，在公司研发软件，软件上线之前会有需求评审、研发、提测、回归测试等多个环节，演讲也是如此，如果把最终演讲比作软件上线，那上线之前是有许多事要做的。这个类比很形象，程序员看了马上就会心领神会，会心一笑。</p>
<p>但是针对技术演讲，我还想做一点适用于自己的修改，关于第一部分，我设想的理想环节是这样的：</p>
<img src="https://cdn.jsdelivr.net/gh/rixingyike/images/202120210314204207.png" alt="image-20210314204206247" style="zoom:67%;" />
<ol>
<li>我是谁。自我介绍，我是谁，简单有礼貌。</li>
<li>讲什么。今天准备分享什么？它与前后节分享，有什么逻辑关系？特别是与上一节的分享有什么关系？</li>
<li>是什么。现场做一个软件演示，让听众直接感受到软件的运行效果。</li>
<li>啥原理。开始启发听众，它是怎么工作的，它的工作机制是怎么样的，它背后的工作原理是什么样子的，以此引导听众思考，激发听众的好奇心。</li>
<li>讲代码。打开代码，细致讲解代码是如何编写的，是如何工作的，解释给程序员听。</li>
<li>撸代码。既然了解了工作原理，接下来我们就开始做一个小实验吧。现场提出一个小需求，现场写代码，演示如何完成，最后展示劳动成果。当然了，如果这个需求是由现场听众提出来的，效果会更好。</li>
<li>咋运行。告诉听众，如果他拿了这套代码，如何在本地运行起来，有哪些需要注意的。</li>
<li>有啥用。和读者畅谈一下，这个软件的作用和意义是什么，未来它能干什么事情，我们对它还能做什么修改？</li>
<li>做总结。对今天的主题再做一个回顾，总结一下本次演讲的核心价值。如果有可能，对下期的内容做一个预告。</li>
</ol>
<p>你觉得怎么样？对我提出的<strong>现场由听众提需求，现场编码展示</strong>这个设计，是不是觉得很刺激，很fashion？只要能完成这个环节，我相信每个程序员听众都会抑制不了马上躬身编码的冲动的。</p>
<h2>| 怎样有效避免演讲前的紧张情绪？演讲四要素和一核三言</h2>
<p>先分享一个我自己的真实的小故事。我在充电平台录课，最初几次每次来了以后，我都不上楼，不进录音棚，都是先在楼下徘徊近一个小时再上去。干嘛呢？就是备稿，我要把那个逐字稿，一个字一个字的反复默诵，反复推敲和修改，直到我完全对它们轻车熟路。而在此之前，我已经在出租车上默诵了近一个小时了。即便如此，我对自己的录课表现仍然不满意，我觉得还是能看出很多紧张情绪，还有很多可以改进的地方。但对我这个一向不爱说话的人来讲，已经是很大的进步了。</p>
<p>这一篇是继《如何做好一场技术演讲》第一篇之后的，一个关于克服演讲前紧张情绪的一个内容小分支。</p>
<p>概括一下，主要讲了两方面内容：一、对演讲建立客观认知，二、客观地对待演讲四要素。做好对这两部分内容的了解，再加一点点刻意练习，就可以克服紧张心理了。</p>
<h3>1，对演讲建立客观认知</h3>
<p>这里有两个小分支必须明确。</p>
<h4>1.1，紧张是人源自基因的天性</h4>
<p>许多演讲大佬也会紧张，比如乔布斯在参加斯坦福毕业演讲之前，前几天仍在紧张地备稿，为此甚至肠胃因紧张翻江倒海。还有英国伟大的首相丘吉尔，在演讲前，还在车里自言自语地备稿。</p>
<p>了解这些伟大人物他们也会紧张，他们成名以后也仍然会积极的备稿，对降低我们的紧张情绪，在认知上是十分有效的。如果不经过刻意练习，我们大多数人的演讲水平都是差不多的。</p>
<h4>1.2，演讲前三分钟很关键</h4>
<p>如果能够平稳的度过正式演讲的前三分钟，接下来我们基本就不会紧张了。紧张不但是一种情绪，它也会伴随着我们体内血液流动加快、呼吸急促等在内许多生命特征并发出来。</p>
<p>克服了最初的三分钟，之后就平稳了。在开始的这三分钟，我们可以用一个风趣幽默的自我介绍，加一段背得滚瓜烂熟的课程介绍，再加一点其它内容，将这三分钟「对付」过去。</p>
<h3>2、客观的对待演讲四要素</h3>
<p>演讲四要素包括：听众、内容、道具和演讲者自己。</p>
<img src="https://cdn.jsdelivr.net/gh/rixingyike/images/202120210314204440.png" alt="image-20210314204439176" style="zoom:33%;" />
<h4>2.1，先说听众</h4>
<p>技术演讲，如果三分钟不能吸引听众的兴趣，可能听众马上就要拿起手机翻看朋友圈了。在线下脱口秀现场，一个脱口秀演员，如果30秒不能让观众发笑，可能大家都要吹口哨了。</p>
<p>要充分了解我们的群众是谁，他们普遍有什么需求？如果我们的听众是聋哑人，那么我们用声音演讲还合适吗，想来我们更应该用手语。</p>
<p>想想看如果我们面对的是刚入学的大学生，或者我们面对的是一帮企事业领导，我们的演讲会怎么样，不同的听众对象都会影响我们演讲的内容以及所用的口吻。</p>
<p>简单对听众做一些了解，就可以让我们现场更加胸有成竹。如果我们的听众都是小学生，我们又有什么好紧张的呢？</p>
<h4>2.2，再说内容</h4>
<p>内容很重要，有三点值得注意。</p>
<h5>2.2.1，一核三点</h5>
<p>听众在听完我们的演讲以后，<strong>我们希望他用怎样的一句话，向别人介绍我们这场演讲呢？</strong></p>
<p>这句话就是我们本次演讲的核心价值。核心价值是我们克服心理紧张的底气。</p>
<p>有了这个核心以后，我们再拓展出三个问题：</p>
<p>第1个，它的原理是什么？为什么可以做到这样？</p>
<p>第2个，它在我们生产生活中，有什么用处和作用？这一点可以明确听众如何省时省钱的价值，可以促进他们给我们打好评。</p>
<p>第3点，我们是怎么做到的？如果听众也想使用，他们应该怎么做？</p>
<p>将这三个点，还有一句话核心讲清楚，相信演讲就已经成功了一大半了。这就是<strong>一核三点</strong>。</p>
<h5>2.2.2，PPT 记住要多图少字</h5>
<p>PPT切忌堆砌很多文字，要多图少字，一图胜千言。</p>
<h4>2.3，道具</h4>
<p>包括PPT在内，舞台、提词器这些都可以算作道具。</p>
<h4>2.4，最后说一下演讲者</h4>
<p>最重要的一条，就是要多做正式演讲前的练习，<strong>不要让正式演讲成为第一次</strong>。</p>
<p>其次，在练习上要注重仪式感。例如用手机录音，然后回放，找出自己在语言上的弱点。还可以架起摄像机，正式给自己录一下，看看自己的表现。这些仪式感可以让我们提起精神，更加有现场感，排练效果更好。</p>
<p><strong>如果我们不将正式演讲作为第一次，那么我们还可能会讲很多次</strong>；反过来，如果是第一次的话，那么它可能就是最后一次。</p>
<p>以下是原内容的目录，供参考：</p>
<p>一、紧张情绪并不可怕</p>
<p>二、演讲之前要知己知彼</p>
<p>三、演讲内容要有价值</p>
<p>四、适可而止，不可贪多</p>
<p>五、PPT 只是配角</p>
<p>六、别让正式演讲是你的第一次</p>
<p>七、把握好最初的五分钟</p>
<h2>| 如何在演讲中讲个好故事？</h2>
<p>这篇内容的标题将我迷惑了，标题说“如何讲个好故事”，但其实它并不是单纯讲「如何讲故事」的，没有那么简单，这篇内容整体上讲了如何做好一场故事性的技术演讲。</p>
<p>先说一个讲故事的故事吧。</p>
<h3>白岩松的搞疫故事</h3>
<p>我们都知道白岩松是央视著名主持人，有一次他在湖畔大学讲课，分享的主题就是<strong>如何讲好一个故事</strong>，他的故事是这样讲的：</p>
<blockquote>
<p>疫情期间，我们是全国最早统计新冠死亡率的。</p>
<p>通过对比死亡数据我们发现，武汉的死亡率比整个湖北省要高，整个湖北省又比全中国高。为什么会这样呢？</p>
<p>为此我们采访了杭州的李兰娟院士，她说：“在武汉，是一群病人等着一个医生；而在武汉以外，是一群医生扑向一个病人”。我们听到这个答案以后，非常振奋，对抗疫这件事情一下子变得有信心了。为什么呢？因为如果说死亡率只和医护人员的多寡有关系的话，那我们只需要加派人手就可以了。</p>
<p>于是后来的事情大家都清楚了，咱们国家增派了4万名医护人员支援武汉。到5月份，武汉抗疫已经取得了决定性胜利，武汉的水上花园都全面开放给游客了。而与此同时，西方某些国家虽然一直号称群体免疫，不限自由，但其实一直都没有真正得到过「水上花园」这样的自由。</p>
</blockquote>
<p>好吧，现在白岩松讲故事的这个故事讲完了，在他这个故事当中有哪几部分呢，我们看一下：</p>
<img src="https://cdn.jsdelivr.net/gh/rixingyike/images/202120210326115329.png" style="zoom:50%;" />
<ul>
<li>
<p>第一部分，抛出问题。只有一句话，这句话就是“我们是全国最先统计新冠死亡率的”，这句话要勾起听众的好奇心。</p>
</li>
<li>
<p>第二部分，分析问题。媒体人通过现象看本质，提炼出事实，发现从武汉到湖北，再到全国，死亡率是依次降低的。这个分析要有理有据，要进一步抓住读者的好奇心。</p>
</li>
<li>
<p>第三部分，给出方案。这部分借助权威人士李兰娟院士的回答，给出前面疑问的答案，并且从逻辑上给出合理降低死亡率的方案。</p>
</li>
<li>
<p>第四部分，亮出结果。用赋比兴的修辞手法，陈述事实，对比中外，激发观众的爱国情感。</p>
</li>
</ul>
<p>这四个部分，可能你已经发现了，就是上面的四个小段落，它们就像三段悬索桥的四个桥堆儿一样，是一个挨着一个。所以你看，记不住故事的结构没有关系，只要记住了白岩松的这个抗疫故事，然后照葫芦画瓢填内容就可以了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/rixingyike/images/202120210326115108.png" alt="image-20210315120306512"></p>
<h3>“切西瓜式”等技巧</h3>
<p>对于怎么讲故事，在这篇内容中作者也有讲。但是绝不仅仅是只讲了这一点。</p>
<p>现场的灯光，舞台，大屏幕，和舞台边缘的提词器，还有我们的PPT，这些都可以算作是道具。</p>
<p>在演讲过程中，演讲者很忌讳回头看背后的大屏幕。这会让听众感觉这个演讲者不自信。其实可以看舞台下方的小屏幕，大屏幕看不看是无所谓的。</p>
<p>还有演讲的PPT要简洁、大方、风格一致，但是也要避免由此造成的呆滞，最好要有一点点跳跃，一点点装饰动画。</p>
<p>文中还提到了演讲者的仪表和姿势。穿着最好是牛仔裤+体恤，这是标准的乔布斯式，大家对这个形象其实已经很认可了。</p>
<p>还有就是手势。手掌与地面垂直，做切西瓜状，这是最简单的，也是最适合绝大多数人的演讲手势。伟人一般用的，是一种从内向外横扫一切的手势，这不符合一般演讲者的身份。德拉克洛瓦名作《自由引导人民》里面的自由女神，右手高高举起旗帜，这种姿势也不可取。还有攥紧拳头，从下往上捶击，这是工人罢工的姿势，也不足取。相比之下，只有经典的切西瓜式最合适，谦逊内敛，落落大方，适用性也最强。</p>
<p>还有开头那一句话对我印象也很深刻：“<strong>不管演讲今天多么重要，未来只会变得更加重要</strong>”。所以我们要学习做演讲，特别是学习如何用讲故事的方式做好一场演讲。</p>
<h2>| 如何把你的观点深深地刻在别人的脑海中？</h2>
<p>读了这篇文章我才知道，把话讲清楚、表达清晰，只是方便我们更容易被理解，但并不能让我们的观点深深的印在听众脑海中，除了理解之外，起决定性作用的还有细节。</p>
<h3>神经元是人类思考的物质基础</h3>
<p>白岩松在一次关于如何讲故事的演讲中，讲过讲故事就是要<strong>见人见细节</strong>。见人，就是要露脸，方便我们共情，因为大家都是人类嘛。见细节，是方便我们将未知的东西，与已知的东西建立直链接，特别是与具象的东西产生连接，而且是链接的越多越好。</p>
<p>我们人类的大脑，是由一个一个的神经元组成的，神经元之间靠树突连接。一个人他的神经元多，并不代表他一定聪明；相反，起决定性作用的，在于神经元之间的树突连接是不是很多。</p>
<p>我们每个人来到这个世界上的时候，大脑都是一片空白的。现实世界中的具象，会首先进入我们的大脑，然后我们通过生活实践，在这个具象的基础之上，又建立了抽象的概念系统。</p>
<p><strong>具象是抽象的根基</strong>。任何抽象的东西，其实都很难直接被我们大多数人记住。而那些能够与具体的事物联系、与生活相联系的内容，反而可以很快被我们记住。这就是白岩松说的讲故事要见细节。</p>
<p>还有在网文小说创作中，讲究三个字<strong>代入感</strong>。什么样的文字才容易产生代入感呢？就是要见人见细节，文字要让人能产生情感共鸣，同时有足够的细节描述，可以让人从抽象的文字中，联想到现实的生活场景中去。</p>
<h3>画面与故事的定义是什么呢？</h3>
<p>在这篇文字中，作者有这样一个定义。</p>
<blockquote>
<p>“凡是能让人在脑海中产生画面感的话语或文字就是故事。”</p>
</blockquote>
<p>这个定义我觉得有失偏颇。凡是能让人在脑海中产生画面感的话语或文字，应该是画面，而不是故事。故事是需要有情节的，情节是需要有起伏的，故事应该是由一个个画面组成的。</p>
<p>前面一篇中我们提到如何讲好一个故事，一共有三大段四个墩点：</p>
<ul>
<li>提出问题</li>
<li>分析问题</li>
<li>解决问题</li>
<li>亮出结果。</li>
</ul>
<p>这是对于技术性演讲而言，如果换成是写网文小说，更准确的表达应该是：</p>
<ul>
<li>给主角创造麻烦</li>
<li>继而麻烦让主角不得不行动</li>
<li>紧接着主角开始分析麻烦，继而尝试解决</li>
<li>最后是解决麻烦</li>
</ul>
<h3>怎么才能写出故事画面感</h3>
<p>前面提到，只有具象化的东西，才更容易让人记住。在这篇文章中，作者就向我们展示了哪些是有画面性的东西。这一点很重要，我原来就忽视了这一点。我原来以为的那些「具象」内容，其实对读者来说读起来很痛苦。引用文中的原例：</p>
<blockquote>
<p>“从前有座山，山上有个庙……”是故事画面，“让用户脸上带着微笑离开”是故事画面。</p>
<p>而“自然环境中的宗教聚集地”不是故事画面，“一流的用户服务”不是故事画面，“吸烟有害健康”也不是故事画面。</p>
</blockquote>
<p>对比一下前后，这些例子它们有什么区别呢？前面的例子，它不容易让听众想象出画面，它们都是抽象的，要么是概念，要么是判断，要么是推理。而后面的例子，都比较容易让人想到一个具体的物体或者是动作。</p>
<h3>面向听众演讲</h3>
<p>在这里面还有一点，就是能不能联想到具象的物体，跟听众也是有关系的。所以我们的演讲一定要考虑我们的听众是谁。这个要素很重要。</p>
<p>例如在技术性演讲中，我们要讲给谁听，这很重要。有时候我们习以为常的认为，那些HTTP网络请求协议，那些基本的「变量」、「函数」这些概念，在听众脑海中已是常识。但其实不是这样的，只是对于程序员来讲，如果他只是一个初学者，他还没有这些基本概念，他不知道你在说什么。他甚至可能以为，写代码就像写小说一样，想一想，代码就可以自动运行了。</p>
<p>这一点最近我深有体会，我觉得这是在技术性演讲中特别需要注意的。我们讲的常识，其实都是有一个空间范围和时间范围的。在哪个群体中，在哪个时代讲， 听众的常识都是不一样的。</p>
<h3>刻意增加幽默</h3>
<p>除了让内容具象化，还有一个很高级的技巧可以帮助我们让读者接受我们的观点，它就是幽默。这篇文字的评论区有一位读者贴了一个经典案例：</p>
<blockquote>
<p>9月4日晚，无业游民张某，约网友刘某到自己的出租屋喝酒。期间，刘某感叹有钱人太多，张某随即表示“不如出去弄点钱”，刘某随即响应。解放路的监视探头显示，9月5号凌晨5时16分许，他们的早餐摊支起来了。</p>
</blockquote>
<p>这个例子里面是有反转的，最后一句里面藏着一个小幽默。这样的段子，可以让我们的演讲氛围更加轻松，让我们的观点更容易被读者所接受。但是还是不能被观众轻易的记住，如果想让我们的观点深深的印在听众脑海中，还是要想办法将我们讲的内容，与读者的生活，与具体的事物尽量联系起来。</p>
<p>这里面就有一个矛盾。我们讲的内容读者都知道，读者会认为没有意思；如果完全不知道，又会让他觉得索然无味，很难理解与记住。所以，我们需要将那些听众不知道的、不了解的、未知的东西，与他们已知的东西拼命的联系起来，特别是与他们已知的具象的东西连接起来，这样才可以深深的印在他们的脑海里。</p>
<h2>| 演讲中的肢体语言管理和声音控制有哪些门道？</h2>
<p>这篇内容洋洋洒洒，妙趣横生，特别是前半部分。但是读了以后，感觉没有什么用，还是不知道怎么操作。因为内容没有刻意与具象的事物联系在一起，估计过不了多久我们也就全部忘掉了。</p>
<p>关于手势，对于大多数人来讲，最简单的还是切西瓜式。这也符合文章所讲的激情面和真实面，基本符合。</p>
<p>关于声调，这个就很难把握了。一场好的演讲，绝不是演讲者本人的独角戏，肯定是演讲者和听众共同完成的，就像演讲者带着听众一起跳舞一样。</p>
<p>好的演讲者懂得与他的听众保持「交流」，脱口秀演员管这个叫做节奏。具体怎么把握这个节奏，我也不知道，我唯一想到的就是多练习，并且是现场练习，在现场演讲时要注意和观众进行「交流」。</p>
<p>神枪手是拿子弹喂出来的，相信演讲高手也是通过一场一场的演讲历练起来的。</p>
<h2>| 8 个技巧，帮你做一场漂亮的技术大会演讲</h2>
<p>读了这篇文章受益匪浅，干货很多，我最大的感受是三个字：工程化。</p>
<p>所谓工程化，就是让整个演讲变成像程序一样，像可控的代码一样执行；使每个环节，都有可以遵循的公式，应用这些公式，甚至即使是机器人，也可以代替我们完成任务。关于工程化的具体想法，稍后在总结中细说。</p>
<h3>开场公式</h3>
<p>作者的这个开场就很好：</p>
<blockquote>
<p>大家好，我是来自 58 到家的架构师沈剑（这一句点名了演讲的公司、职位和姓名）。<br>
我在百度、58 同城有过多年的架构工作经验（这一句就是吹吹牛，增强信服力）。<br>
接下来我会和大家介绍 58 到家订单中心的架构演进细节（这个就是内容介绍了）。</p>
</blockquote>
<p>一共分为三部分，大约100个字。根据这个内容，我们可以抽离出这样一个开场公式：</p>
<blockquote>
<p>大家好，我是来自<em>某某公司</em>的<em>某职业岗位</em>某某。<br>
我在<em>某某公司</em>、<em>某某单位</em>做过多年<em>某某项</em>工作，有多年相关工作经验，曾获得过<em>什么奖项</em>。<br>
接下来我和大家探讨<em>一个什么主题</em>。</p>
</blockquote>
<p>只要按照这个公式，把空填好了，背熟了，开场时最紧张的第一个1分钟，就可以轻松得迈过去了。</p>
<h3>如何组织内容</h3>
<p>这个话题已在前面多篇内容已经涉及到了，概括起来公式就是：</p>
<ul>
<li>提出问题</li>
<li>分析问题</li>
<li>解决问题</li>
<li>提炼总结</li>
</ul>
<p>这是讲故事的内容结构，对应这篇内容中的“问题缘起 - 方案 - 优化方案 - 总结”，结构是类似的，只是叫法不一样。另外参考网文小说的写法，在“提出-分析-解决”这个环节，可以多次循环，让演讲略有波折。</p>
<h3>如何组织PPT内容</h3>
<p>我写PPT属于小学水平，一直用写书的思维去写PPT，其实这是不对的。</p>
<p>PPT是画面，我们更应该用画画的思维去创造它。幻灯片呈现给听众的是一张画，不要期望听众看这张幻灯片就能明白我们讲什么。PPT只是配角，演讲者才是主角。看PPT就明白了，还要我们演讲者干什么呢？</p>
<p>文章中作者举的对比例子就很好，概括一下有以下规律可循：</p>
<ol>
<li>不要用1234这样的横向列表，要用没有数字的、有图标的纵向列表</li>
<li>不要用单一的白色背景，要用其它颜色，在一个页面上要争取用多个色块</li>
<li>多使用简洁的图标，少使用文字</li>
</ol>
<p>不要想让听众通过幻灯片上的文字就明白我们的逻辑。事实上看起来有没有逻辑貌似不重要，整体看起来高端大气上档次才重要，毕竟PPT只是一个道具嘛。</p>
<p>附优秀的PPT示例：</p>
<img src="./assets/d9e4c0b07b9be56089c38d3965156907.png" alt="img" style="zoom:25%;" />
<img src="https://cdn.jsdelivr.net/gh/rixingyike/images/202120210314155130.png" alt="img" style="zoom:25%;" />
<p>不好的示例是这样的：</p>
<img src="https://cdn.jsdelivr.net/gh/rixingyike/images/202120210314155204.png" alt="img" style="zoom: 50%;" />
<p>以前我就经常写这样的PPT。有图、有列表，看似很清晰很完备，其实很糟糕。</p>
<h3>如何把握好演讲时间</h3>
<p>或者说如何把握好演讲的节奏。读完以后我的想法是这样的：</p>
<ul>
<li>根据演讲时长准备内容，每张PPT控制在5分钟，一个45分钟的演讲，我们只需要准备不超过10页的PPT就可以了。</li>
<li>将每张PPT里的料点，提炼成一个段子或一个对比句子，演讲时只要保证这个段子没有忘记就成功一半了。</li>
<li>其它内容，幻灯片之间的衔接，段子之间的跳跃，根据现场情况临时发挥，适当加一些“水”话进去。</li>
</ul>
<p>如果时间紧张了，就把水分挤一挤；如果前面讲快了，后面就适当多放些水。</p>
<h3>收尾的公式</h3>
<p>通常一个演讲最终只有10%听众是记住的。在最后时刻，把自己的<strong>一核三点</strong>重审一下，这里为了效果好，我觉得有三点需要注意：</p>
<ol>
<li>总结尽量用段子包装一下</li>
<li>尽量与生活的具象事物联系起来，像<strong>切西瓜式</strong>这个描述，就是一个很成功的抽象与具象的联系</li>
<li>最好有一些或一个「专有名词」，这些名词是只有听了前面的演讲才能明白的，这个地方的例子还可以举「切西瓜式」</li>
</ol>
<h3>问答环节的公式</h3>
<p>这个环节作者分享的三个话术都十分实用，也是应对三种情况的公式。</p>
<p><strong>1. 遇到挑战者</strong></p>
<p>我们可以说：“今天分享的只是我们自己的实践，解决方案有很多，相信在不同场景、不同需求下会各有优缺点吧~”，然后回答下一位的问题。</p>
<p><strong>2. 不能100% Get到提问者的点</strong></p>
<p>这个时候我们可以说：“这位朋友要问的是不是这样一个问题呢…”，然后转向这个问题的现场分析与解答。</p>
<p><strong>3. 遇到一个不能回答或难于问答的问题</strong></p>
<p>原因可能有很多，但有些问题就是不方便在公众场合回答。</p>
<p>这个时候我们可以说：”这是个好问题，但很难用一两话讲清楚，感兴趣的话我们线下交流。”</p>
<p>总结一下，上面这三个话术都是在打太极。社会人，公众场合还是以和为贵。许多时候听众提问，除了想交流、想得到解答，有时候就是想有一个表达的机会，你机会给他了，基本他30%的需求就已经被满足了。如果提问者还会得到一些小礼品，那么50%的满意度已经有了。</p>
<p>以上吧，就是我读了这篇文章的想法。总体来讲，如果把演讲当作一个可控的工程，让每个环节都有范式可依，有章可循，这样演讲效果和演讲时间基本都是可控的了。几乎所有的公开演讲都有时间限制的，如果因时间控制得不好而仓促结束，这比某个环节讲的不好还要糟糕，毕竟完成比完美更重要嘛。</p>
<p>接下来我谈一谈我学了这个课程的总体感受。</p>
<h2>总结：将技术演讲工程化</h2>
<p>从演讲效果上讲，演讲从低到高有好几个层次：</p>
<ol>
<li>
<p>讲清楚了，这个时候逻辑是清晰的</p>
</li>
<li>
<p>观众听明白了，并且感觉受益了，听众觉得有价值</p>
</li>
<li>
<p>现场效果好，观众不时发出笑声或鼓掌，效果好，就像乔布斯发布第一代iPhone那样</p>
</li>
</ol>
<p>要达到第三个层次是很难的，大部分人第一个层次都很难做到，大多数人都很难有条理地将事情请明白。但讲明白，还不代表对听众有价值。在第三个阶段，就不只是讲清楚和有价值这么简单了，是要在总体逻辑连贯的前提下，增加幽默效果。就像天上的星座，以猎户座为例，猎户座各个星星之间本来就是没有连线的，是我们人类在想象中给它画上了这些线。在第三阶段，我们要特意擦掉那些使逻辑看起来更清晰的线，使演讲效果更加简洁，更具幽默感。</p>
<p>具体而言，我读了这个课程以后，有如下收获：</p>
<ol>
<li>将演讲工程化，可以最大程度地保证演讲效果和控制好演讲时间。包括开场公式、问答环节公式、收尾公式等。</li>
<li>一场好的演讲绝不是演讲者在独舞，好的演讲者要懂得和他的听众保持「交流」。神枪手都是拿子弹喂出来的，优秀的演讲家都是一场场演讲历练出来的。</li>
<li>神经元是人类思考的基础，神经元之间的连接越多，越容易记忆和理解。演讲内容如果想让听众理解和记住，就要刻意和现实生活中的具体事物联系起来。那么虚无缥缈的概念，在听众离场的时候，就已经被忘到九宵云外了。使内容具象化，充满画面感，才有可能刻到听众脑海里。</li>
<li>故事的结构是这样的：<strong>提出问题、分析问题、解决问题和总结问题</strong>。人人都想听故事，讲故事是一般人提升演讲效果的不二法门。如果忘记了这个故事结构，没关系，就想一想白岩松讲的那个抗疫故事。</li>
<li>刻意加点幽默，能让现场效果更好。</li>
<li>演讲者手势，最简单的就是双肘90度沉于身体前方左右两侧，手掌与舞台垂直，做切西瓜状。「切西瓜式」，看人家这个名称起的多好，一下子就记住了，因为它是具象化的。</li>
<li>演讲者的穿着，牛仔裤+黑色T恤。</li>
<li>PPT，<strong>一图胜千言</strong>。要花些心思，将逻辑清晰的横向列表，变成<strong>一下看不懂</strong>的竖向列表。删除多余的文字，多添加一些图标、背景色块和箭头。<strong>演讲用的幻灯片是作为一张画呈现的，并不是作为一页书呈现的</strong>。</li>
<li>紧张是人类公开演讲都有的情绪，是天生的，唯有多多刻意练习，录音练习、架摄像机练习、找朋友当面练习等等都可以。</li>
<li>正确和理智地对待演讲四要素：<strong>演讲者本人、内容、道具和听众</strong>。内容要随听众而变化，道具要为演讲服务。PPT也是演讲者的道具之一。在内容上<strong>一核三点</strong>很重要，想明白听众可能会怎么向别人介绍我们这场演讲，为什么会这样，有什么用途，听众如何做到。</li>
</ol>
<p>以上就是所有内容了，不知道你学习了之后有什么感受，欢迎分享讨论。如果你想要本文的PDF版本，可以在#公众号：艺述论 回复数字「101」下载。我们下期再见。</p>
<p>2021年3月26日</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[充电平台小程序实战专栏导读]]></title>
            <link>https://yishulun.com/./src/posts/2021/31.html</link>
            <guid>https://yishulun.com/./src/posts/2021/31.html</guid>
            <pubDate>Thu, 25 Mar 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>充电平台小程序实战专栏导读</h1>
<h2>| 课程介绍</h2>
<p>初学者为什么要学习微信小程序？</p>
<p>录课结束三个月后，我再回头看这节课，感受只有四个字：“录的真好！”</p>
<p>对于不知道自己应不应该学、合不合适学小程序这门技术的读者来讲，只要看了这个视频就有答案了。</p>
<p>极客时间的小伙伴，若没有他们的严格把关，恐怕我只能做到60分；有他们在，把我身上的懒虫逼走了，硬是提到了80分。但就这一篇开篇词，我给90分。哈哈。</p>
<p><strong>这个视频主要讲了三点：</strong></p>
<ol>
<li>为什么要学习微信小程序开发？</li>
<li>学习微信小程序有哪些难点？</li>
<li>如何学习这门小程序课程？</li>
</ol>
<p><strong>个人应该做什么样的需求</strong></p>
<p>对于第一个问题，也有三点：</p>
<ol>
<li>从用户体验的角度考虑：小程序顺应了时代需要</li>
<li>从商户运营的角度考虑：你需要小程序</li>
<li>从开发的角度讲：小程序走到了技术前沿</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/rixingyike/images/202120210325162549.png" alt="image-20210325162547699" style="zoom:33%;" />
<p>前天我看到腾讯正式发布了2020年财报，提到小程序的交易额增长了一倍。小程序虽然已经4岁了，但市场才刚刚开始，现在正是入局的时机。前天我还在知乎上看到有人分享一个视频，依靠小程序流量主月赚2000米。</p>
<p>那么，现在入局的话，对于个人开发者，独立开发者应该做哪些应用呢？</p>
<p>其实这个答案在这个课程视频里就有，可能很少有人注意到了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/rixingyike/images/202120210325162904.png" alt="image-20210325162902821"></p>
<p>有人可能会问，为什么不做低频高明长？费流量。</p>
<p>那为什么不做高频低时长？这个领域一般是巨头、大厂在做，竞争大，例如美图秀秀等。个人开发者就不要往这个领域挤了，个人在体验上是很难做过巨头的。现在不像张小龙单枪匹马写Foxmail的时代。</p>
<p>做那些有市场需要，但需求少，巨头不屑于做的小应用。因为网民一般都有路径依赖，你把一个小功能做好了，下次他还会想到你。从小程序的定位来讲，这是当初张小龙想让小程序履行的职能。扫码即用，用完即走。</p>
<p><strong>学习小程序有什么难点？</strong></p>
<p>再看第二个问题，有什么难点，其实在我看来，<strong>没有什么难点，只有麻烦点</strong>。你想使用微信支持，难道还要注册一个公司吗？你想使用小程序直播，难道还要先搞定一个在线音视频营业许可证吗？</p>
<p>有人说，用公司的。公司不让用，或者没有公司怎么办？</p>
<p>不用担心，我在课程里面都给你准备好了，直接用我的学习。</p>
<p>还有小微商户支付，我也准备好了。它能让你直接用个人银行卡收钱，这个太爽了，这是多少独立开发者一起梦寐以求的事。这些我都给你准备好了。</p>
<p>就此三项，如果个人去折腾，花精力不说，花的钱也是这个课程单价￥199可以cover的。</p>
<p><strong>还有最后一个问题，怎么学？</strong></p>
<p>PBL，在一个项目里面，学习所有的知识点。坚持知行合一，眼到心到手到。剩下的就交给时间。</p>
<p>我觉得，对新人来讲，看这个视频学习小程序，远比看书要容易多了。而之前有一个人在群里说，他看完我的《小程序从0到1》立马就接了一个外包。学完这门课程，依然可以，至少做一个可以独立赚米的，不依靠任何公司的小程序应用，是没有问题的。</p>
<h2>| 内容综述</h2>
<p>这节课主要介绍了整门课程的内容规划。主要分三部分：第1部分讲原理和框架；第2部分讲组件和接口；第3部分是本门课程的主体部分，也就是全栈实战部分。</p>
<p>由于时间关系，在这个规划里面，有两个点“查看我的历史订单”和“查看物流状态”，这两个点并没有实现。但是他们所依赖的增删改查这些基本技能，其实在课程里面已经有了。后续，我会考虑把这个项目继续完善，争取给读者提供一个商业环境可用的源码版本。</p>
<p>这节课还提到了微信小程序的双线程运行机制，底层的evaluateJavaScript，这个函数像一个很窄小的水管，连接着左右两个大水箱，它确实是小程序性能的瓶颈。但是这一块，我感觉微信团队，他们也在想办法解决，wxs就是证明。我觉得未来这一块，<strong>如果这个问题解决了，小程序可能真的会取代 App</strong>。</p>
<p>还有一点，就是在课程规划的时候，当时没有提到<strong>云开发</strong>和<strong>小微商户</strong>。但其实在实际的课程里面，我们特意加了这两项。特别是最后一项，它对于个人开发者来讲，确实是一个营收利器。<strong>小微商户可以帮助个人直接将钱收到个人银行卡，并且还是合法的。</strong></p>
<h2>| 小程序的特点及开发能力</h2>
<p>什么是微信小程序？</p>
<p>如果用一句话概括，它是介于App和微页面之间、开发成本比App低、页面体验比微页面好，有4亿+海量用户基础的这样一门技术。微页面能做的，它都能做；App能做的，它95%都能做，有一些小程序能做的，App却做不了，例如在微信群内获取群id等。与平台紧密相关的平台能力，是小程序的长项。</p>
<p>该视频还介绍小程序与公众号之间的异同，还有小程序的发布流程等，大致了解一下就可以了。在目前来说，微信已经放弃原来的企业服务号，改由小程序肩负起提供企业服务的责任了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/rixingyike/images/202120210325181026.png" alt="image-20210325181024653"></p>
<p>现在公众号是企业进行品牌宣传的窗口，视频号是企业在短视频时代攫取流量红利的手段，小程序才是企业为用户提供服务的场地。</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[左耳听风专栏学习笔记]]></title>
            <link>https://yishulun.com/./src/posts/2021/32.html</link>
            <guid>https://yishulun.com/./src/posts/2021/32.html</guid>
            <pubDate>Thu, 25 Mar 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>左耳听风专栏学习笔记</h1>
<blockquote>
<p>这是我在充电平台学习<a href="http://gk.link/a/10pr7">《左耳听风》</a>专栏的笔记，仅是部分。</p>
</blockquote>
<h2>开篇词 | 洞悉技术的本质，享受科技的乐趣</h2>
<p>分享文章，不仅仅是为了宣传，更多是为了与他人讨论，激发更深入的深入思考。学习别人的知识，如果有真正的思考，那么可能有三个阶段：</p>
<p><strong>在第1个阶段</strong>，我们读了以后，有了自己的想法，大胆分享出来，然后遭到了批判，别人可能说我们目光狭隘，狂妄无知。</p>
<p><strong>在第2个阶段</strong>，我们预感到可能会有人批评我们，而刻意在用词上柔和了一点点，这在一定程序上是一种「懦弱」的表现。</p>
<p><strong>在第3个阶段</strong>，我们明知可能会招来非议，却仍然大胆地表达自己的想法。这是勇，是儒家三宝里的「勇者无惧」。</p>
<p>如果有思考，肯定就是要表达出来的；如果没有思考，那就另当别论了。反过来思考一下，有些东西线上是不适合讲的，所以有时候真正的交流还在线下，这也是为什么有时候明明可以在线交流，却一定还要举办线下活动的原因了。</p>
<h2>| 程序员如何用技术变现（上）</h2>
<p>这篇文章我最大的心得是，<strong>优秀人才都普遍具有三个特征</strong>，稍后我们看具体是哪三个特征。</p>
<p>我感觉这个专栏作者的经历真是非常富有传奇色彩。1997年，5个Web页面1万块钱，一个页面就是2000块钱。现在基本上一个页面也是2000块钱，只不过要带上「动态」二字。</p>
<p>作者因为不会网页设计和开发，放弃了这1万块钱的外快，后来他开始自学网页开发，并且自学以后还在网上分享，分享他设计网页的一些技巧，例如「抽屉菜单如何设计」等。这个菜单设计，在当时就属于有一些难度的高级技巧了。</p>
<p>因为在网上做了这些分享，而被电脑报的编辑看到，从而成为电脑报的特约撰稿人，从此专栏作者开始赚稿费了。</p>
<p>后来机缘巧合发现了一个牛x的性能优化工具，叫Purify。因为觉得好，开始读Purify的英文文档，进行全面细致的深入研究，并且还在网上分享研究心得。由此被一家需要使用Purify的公司看到，开始进入企业内训领域。一天税后收入5000块钱。这是20年前的企业内训价格了，在今天来看的话，至少两万起了。</p>
<p>再后来因为继续钻研高精尖技术，继续坚持分享，开始被公司邀请进入内部解决疑难杂症问题。两天时间，报价1万块钱，人家给了10万。感觉作者当时很客气，他是按企业内训价格给报的价，但是人家是按节约的成本给付的报酬。一个技术难点被憋住了，公司投入好几个人进去，花了几天甚至几周时间，企业的沉没成本已经很大了。10万块钱，可能只是被节约下来的一小部分。</p>
<p>作者后来又有一次深入公司解决疑难杂症的机会，两天时间，700行代码，企业给了20万。这个也是应当给的，可能这一次节约的沉没成本更多了吧。</p>
<p>从作者的这些经历看下来，会不会有人觉得他的的运气好？</p>
<p>我觉得在这个快速发展的时代，每个人其实都是有机会的，我觉得不是作者的运气好，是他具有一般人不具备的品质。接下来容我归纳一下这些品质，不妨你也对比一下，看自己有没有。</p>
<p><strong>勤奋好学</strong></p>
<p>第1点，就是勤奋好学，并且是主动学习，这一点基本上就把80%的人给比下去了。很多人学习都是被动的，甚至很有可能他从事的那个职业，也不是他自己喜欢的，只是为了拿一份薪资而已，所以根本也谈不上主动热爱。</p>
<p><strong>善于思考与总结</strong></p>
<p>第2点，就是作者很善于思考和总结，并且还善于把总结出来的理论，继续应用在实践当中。在作者上面这几件事情里面，其实前后都是有因果联系的。如果没有<strong>电脑报</strong>约稿，可能就没有后来的Purify分享，没有Purify分享，可能就没有后来的企业内训，没有继续高精尖问题的<strong>钻研</strong>，可能就没有后来解决<strong>疑难杂症</strong>问题的机会。这里面是有内在联系的，善于思考，善于总结，善于在实践中调整，这一点基本上把90%的人都比下去了。</p>
<p>举一个例子，作者刚开始时还研究<strong>如何实现抽屉式菜单</strong>，但是后来他就不研究这个了，为啥呢，因为研究的人多了，研究明白了，没意思了，太简单了，这个已经不属于高精尖技术了，后来他就注重研究那些有难度的、有挑战性的技术。这个也不一定就是出于等着某一天有公司请他去做企业内训，或者解决某些疑难杂症问题这个目的去学习的。</p>
<p>江湖上有很多武功，你要选哪一种呢？比如说独孤九剑和辟邪剑谱，比如说降龙十八掌和葵花宝典。武功是有正有邪的，所以在这个里面，我们看到，作者修练的都是正派功夫。那么所谓邪门歪道的武功是什么呀？比如说破解用户名、密码，研究一些黑客技术等。这些东西不要去研究，这些东西研究了也无处分享，不分享别人怎么知道你会。</p>
<p>我曾经因为工作需要，研究过验证码的破解，首次破解成功率达到95%以上，二次成功率几乎100%。我还分享过如何破解，后来有一天被一个北美的哥们看到了，他联系我。我把帖子删掉了。</p>
<p><strong>三、富有分享精神</strong></p>
<p>第3点，就是作者不惮于将自己的研究成果无私地分享出去，非常富有分享精神。很多人是不会分享，还有一些人是不愿意分享，从这点来看，作者又把99的人比下去了。</p>
<p>以上就是我读了以后，我认为一个优秀人才一般都具备的三个基本品质。所以，我觉得也不用羡慕别人运气好，要先看自己是否具备这些品质，是否付出了长年累月的努力。</p>
<p>前天在知乎上有一个人和我评论互动。他说他27岁了，比较迷茫，问现在学编程还来得及吗，学了以后能做一名程序员吗？</p>
<p>我就鼓励他大步前进，如果对编程感兴趣，现在入行就是最好的时机。然后他又觉得，如果现在开始学很多基础知识，像计算机基础，网络基础，数据结构，算法，数据库等等，等学完了基本到30岁了，到时候还有公司要吗？</p>
<p>这时候我就给他一个建议，我说你可以先学会一门实用的技术，让自己有被企业利用的价值，先找一份工作，然后你在工作当中再充电，再夯实基础。</p>
<p>然后他又犹豫说，那到35岁是不是又要被公司给淘汰了？</p>
<p>我接着跟他讲，技术学到了是任何人都「淘汰」不了的，不要觉得技术只有卖给公司才有价值。当然了，这跟学什么技术也有关系，所以我现在主张程序员入门，可以先从应用型技术学起，从能独立赚钱的技术学起，比如说微信小程序。微信小程序已经覆盖了4亿人，市场是非常大的。</p>
<h2>| 程序员如何用技术变现（下）</h2>
<p>这一篇文章听下来感觉实操性并不强。总的来说，怎么样才可以用技术变现呢？就是首先要先让自己变得值钱。那怎么样才能变得值钱呢？就是要做到别人做不了的事情。</p>
<p>做到别人做不到的事情，感觉这个挺难的。但其实如果我们划定一个范围的话，这件事情好像也没有那么难。我们不需要做到第一名。</p>
<p>就像开餐馆一样，这个世界上有很多餐馆，各大菜系都有。每个餐馆的价格、服务、以及做菜的水平都是参差不齐的。但是那些做得差的餐馆，他们依然也活了下来。有的是靠低价，比如农村大集市里的山东拉面哥；有的是靠地段，比如说北京东单的簋街；有的是靠服务，比如说海底捞。他们活下来的方式都不一样。</p>
<p>那与程序员这个手艺人行业对比一下，我觉得道理也是一样的。我们没有必要非要在某一方面做到顶级。只要我们能给周围的人，给一部分人提供价值，我们就能挣到钱了。</p>
<p>有时候信息是不对称的，要么他们不知道，要么就是他们着急要。就像一个饥饿的人，他就想马上吃一碗面，而我们恰好就开了一家还凑合的面馆。</p>
<p>技术变现这件事情，我之前还听过别人的演讲。大致总结一下，有一个核心的点很重要，就是我们要努力提高我们收入里面的被动收入，而减少一次性收入。</p>
<p>举个例子，比如说像软件外包，这个事情就很不划算，因为你投入一份时间，你就赚一份钱。相对来讲，你做一个模板小程序，然后你给很多人用，重复销售，那这个相对就高级了一些。</p>
<p>还有企业培训也是，你设计了一套课程，你可以重复给很多企业讲。但如果只是与一个企业的业务紧密结合进行培训，那基本上这个就是为他们量身定制的，不可能再二次销售了。这种情况下相应的内训价格就要高一些，至少要比一般的报价高两到三倍吧。</p>
<h2>| Equifax信息泄露始末</h2>
<p>这是2017年发生在美国的一次非常著名的征信公司信息泄露事件，波及多个国家的1.43亿用户，影响非常恶劣。事故的直接原因是运维人员没有及时更新补丁，没有及时修复一个旧版的Apache Struts漏铜，致使黑客有机可乘。</p>
<p>Apache Struts是著名的开源软件，所以你看，不一定是开源软件就一定更加安全。前几天还听到一个报告，说是大概50%（具体数字记不清了，大概比这个还要高一些）以上的开源软件都存在安全问题。</p>
<p>软件安全问题不容忽视，这里确实应该提高认识。</p>
<h2>| 从Equifax信息泄露看数据安全</h2>
<p>这篇文章听下来我的体会是：<strong>给敏感信息加一个保险箱，给箱子上一把锁，并且钥匙还要定期更换。</strong></p>
<p>箱子的钥匙，也就是密钥，由一个部门或子公司保管，箱子则由另一个部门和子公司保管。</p>
<p>需要从箱子里面取东西的时候，由箱子自身向外提供一个小水龙头，同时还要进行流量监控，发现流量大了立马停止输出并拉响警报。另外，提供数据的时候，还要先对口令，也就是密钥。这个密钥要定期更换，并且密钥不能体现出某种社会工程学上易于猜透的公式特征。</p>
<p>箱子给数据使用者返回的信息要进行脱敏，打马赛克，例如银行卡只返回后4位数字，前面都是星号。</p>
<p>在登录入口多加一些防范，例如限制登陆IP，强制使用安全证书，强制使用复杂的密码，强制定期更换密码。强制使用复杂的密码和定期更换密码，这个规则可能会让员工反感。可以使用带自动生物验证的电脑，将这一步骤简化。<strong>让人觉得简单，就容易让安全措施落实。</strong></p>
<p>再总结一下核心要点：<strong>在内部建立子系统，对内部也要加以防范。对内提供的数据接口，对内部调用也要加以限制和监测</strong>。</p>
<p>安全漏洞不是一劳永逸的，它是随着软件的发展而不断进化和生长的，它非常具有服务特性。可以说安全服务是一个消耗品，就像家里的卫生纸一样。我觉得在这个方面，以后国内市场的需求会越来越大的，甚至我觉得都可以专门有这样的一项to B的生意。至少专门有这样的一个专栏课，肯是是很有价值的。</p>
<p>我查了一下，在充电平台上确实有一个这样的安全专栏，叫做《<strong>安全攻防技能30讲</strong>》，我已入手，也把这个课程推荐给你：</p>
<img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/20210329095750image-20210329095748724.png" alt="image-20210329095748724" style="zoom: 50%;" />
<h2>| 何为技术领导力？&amp; 06 | 如何才能拥有技术领导力？</h2>
<p><strong>先看第05篇</strong></p>
<p>一看到领导二字，貌似这和组织关系有关系了，其实不是的，这里讲的技术领导力，是指工程师<strong>主动发现问题，并推动问题解决的能力</strong>。</p>
<p>当然，我这么解释有点偏面，这是对人而言，对一个企业，甚至一个城市、一个国家，也可以谈论其技术领导力。在这里，起决定性作用的是工程师，并且这里的工程师，可不是一般的工程师，它应该被描述为「国家的希望」，甚至「人类的福祉」。我们看一下这里的工程师，他需要做哪些事情：</p>
<ol>
<li><strong>发现问题</strong>。发现生产生活中存在的矛盾或痛点。</li>
<li><strong>提出问题</strong>。只是发现问题还不可以，因为有的人虽然发现了，但是他觉得这件事与他无关，事不关己则高高挂起，这不是真正的有领导力的工程师。</li>
<li><strong>分析问题</strong>。不仅是分析问题，还要调查并给出一个或几个解决方案。</li>
<li><strong>解决问题</strong>。有了方案以后，方案并不一定可以落地，资源永远都是紧缺的，不然的话它可能就不是一个真正的问题了。这个时候，需要工程师主动、有韧性地、坚持不懈地推动方案落地，直到问题完美解决。</li>
</ol>
<p>所以你看，这里的工程师哪里是招聘网站上提到的工程师啊，他是一身身兼数职，既是产品经理，又是项目经理，可能还是一个QA，当然最本质的，他是一位可以写代码、可以让技术方案落地的程序员。在这里，工程师不等于程序员，工程师大于程序员。</p>
<p>昨天我还刚看到一篇文章，说清末名臣左宗棠发现新疆「伯克」制度日益腐败，民族分化问题日益严重，于是他五次向朝廷上书，要求新疆建省，立乌鲁木齐为省都。这件事情肯定是有阻挠的，在当时那个腐败的年代，在一个摇摇欲坠的朝廷里面，他肯定知道做件事的难度。但是为了做成这件事，左大人是坚持不懈啊，不断寻找有利时机，前后五次上奏，最终在他去世前一年，终于把这件事办成了。如果没有当年左大人办的这件事，恐怕今年新疆的棉花不会收成这么好。</p>
<p>我们对比一下左大人和工程师，按这篇文章作者的标准，<strong>一位有领导力的工程师就是一个会写代码、懂技术的左大人</strong>。所以你看，这里的工程师规格是非常高的。</p>
<p>那么进一步思考一下，这样的工程师他主要做什么事情呢？</p>
<p>我们知道创新的事情有两类：</p>
<ul>
<li>一类是从0到1的事，这件事之前从来没有人做过，突然有一个人做了，这就是从0到1的事，例如瓦特发明蒸汽机、莱特兄弟发明飞机、爱因斯坦发现相对论、牛顿发明微积分等等，这些都是从0到1的事情。</li>
<li>另一类是从1到1万的事，这一类里面的事已经有人做了，大家都看到这件事的价值了，但是还有不少问题和可优化的空间，现在需要将它不断完善，不断地进行深入改造，使它更加易用、成本更低、效果更高。在这方面例子也有很多，例如汽车、飞机、高铁、电子计算机等等都是这方面的例子。</li>
</ul>
<p>这两类事情按说工程师都可以做，但第二类需要的工程师更多。文中所言的工程师，主要也是做第二类事情。</p>
<p><strong>接下来看06篇有关的内容</strong></p>
<p>作为一名技术领域的工程师，那么如何提升个人的技术领导力呢？除了高标准要求自己，坚持终生学习，坚持做正确的事以外，很重要的一条，就是打好技术基础。在这方面作者还给出了一些具体的建议，一共是八条：</p>
<ol>
<li>
<p>学习基础的编程语言，例如C，推荐阅读《C语言程序设计（第二版）》</p>
<img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/20210329103856image-20210329103855231.png" alt="image-20210329103855231"  />
</li>
<li>
<p>学习普遍的编程范式，例如面向对象编程、函数式编程、经典的23个设计模式，这些都是编程前辈总结的思想精华。推荐阅读《设计模式-可复用面向对象软件的基础》</p>
</li>
<li>
<p>学习算法和数据结构</p>
</li>
<li>
<p>学习计算机原理，推荐阅读《深入理解计算机系统》</p>
<img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/20210329103938image-20210329103935750.png" alt="image-20210329103935750" style="zoom: 15%;" />
</li>
<li>
<p>学习操作系统原理</p>
</li>
<li>
<p>学习网络通信原理</p>
</li>
<li>
<p>学习数据库原理</p>
</li>
<li>
<p>学习分布式架构原理</p>
</li>
</ol>
<p>学完这些，基本上二三年时光都过去了。但是并不是学完就结束了，学习它们只是一个开始，这些内容需要用一生的时间去不断锤炼。</p>
<p>在学习资料的获取上，作者提到，一定要从源头学起，用好英文。学习者采用的学习方式，与学习者的水平也是紧密相关的，概括一下大致有三个层次：</p>
<ol>
<li>第一个层次，只使用中文搜索引擎，只阅读中文书籍或文档。达到这个层次说实话已经很不错了，因为大多数程序员是不读书的，连这个都达不到。</li>
<li>第二个层次，使用谷歌搜索英文资料，阅读外文书籍和原始的英文技术文档。</li>
<li>第三个层次，翻遍这世界上的角落，都找不到问题的答案了，跑到官方Git仓库上看issue列表，和原作者直接交流。甚至原作者都没有答案，你在这个技术上跑到了世界的最前尚，你动手写代码，解决了这个问题，然后再把解决方案分享给其它人。</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/20210329213949image-20210329213943242.png" alt="image-20210329213943242" style="zoom:67%;" />
<p>以上就是我读了这两篇内容之后的感受，做一名工程师不容易，做一名有技术领导力的工程师更不容易。学好上面这些基础内容，或许才真的可以达到「代码改变世界」的境界。</p>
<h2>| 推荐阅读：每个程序员都该知道的知识</h2>
<p>这篇干货文章没有语音，只有文字。在这篇文章里面，作者推荐了一本电子书，叫《C++软件性能优化》，176页，全英文，我不知道有多少人会看。</p>
<p>另外，还有一个关于Github开源代码bug 的研究报告 。这个报告很有意思，总结一下有这样几个点值得注意：</p>
<p><strong>第1点</strong>。Bug产生率与软件所在的领域无关，但却和编程语言是相关的。语言设计的不好，就容易出Bug。函数式编程语言的Bug，比一般过程式编程语言要少。对于这个结果，我的第一感觉是，并不一定函数式编程语言它更具优势，可能是它被用的少。但其实不是这样的，更有可能的一种解释是，函数式编程它是一种线性思维，它不是发散的，它没有提供给程序员更多犯错的可能。</p>
<p><strong>第2点</strong>。静态编译的语言，比动态编译的语言Bug要少；强类型的语言，比弱类型语言Bug要少。</p>
<p>什么是静态编译的语言？像C、C ++，Golang，这都是静态编译的语言。反过来像PHP，JS，Ruby，这些都是解析执行的，属于动态语音。</p>
<p>什么是强类型？像Golang、C、C++，这些都是强类型。JS 中一个变量可以随意地改变类型，它是弱类型。</p>
<p>这个规律很好理解，弱类型语言是动态编译的，确实比较容易出Bug。反过来，如果是静态编译、强类型，有很多Bug在编译过程中就被开发者干掉了，因为不干掉的话就编译不过去嘛。</p>
<p>这两个弱点JS都具备，正因为如此，微软搞了一个TypeScript，简称TS 。但是很奇怪，通过这个报告我们可以看到，TS的Bug比JS还要高。按理说TS因为时间不长，比较新，语法更先进，它的Bug应该更少，但其实不是。</p>
<p>所以还是那句话，语言它只是一个工具，语言本身它没有什么绝对的好坏，关键还是使用工具的人。TS它其实只是在JS表面上放了一些语法糖，做了一些人为的限制，来规避一些可能容易发生的错误，但本质上它编译以后还是JS。</p>
<p><strong>第3点</strong>。在这个报告里面，我们可以看到像一些传统的语言，C和C++的Bug 率是很高的，而Go语言相对是比较低的。鉴于Go语言它也是互联网时代的C语言，它在分布式系统中很有优势，所以它仍然是目前被建议学习的首款后端语言。</p>
<p>在评论区有读者提了一个很好的一个问题，这个问题很有辩证性，他是这样问的：</p>
<p><strong>对于初学者，学习是应该从上到下学习，还是从下到上学习？</strong></p>
<p>从上到下学习，就是说先从应用型技术学起，先做项目，在做项目的过程当中再去深入学习。这个是我一直主张的PBL学习思想。从下向上学习，它是指我们先把计算机的一些基础知识，网络基础，算法，数据结构，数据库，分布式技术等等这些底层的东西，先学好，打好根基，完了再去学应用层技术。</p>
<p>这是一个好问题，但其实对于不同的人来讲，它可能没有标准答案。我的建议，还是要从上向下学。你先学一门技术，甚至靠这门技术先找到一个工作，然后你在工作当中，再去注意夯实基础。我反对先完全从基础学习，特别对那些不是计算机专业的初学者来讲，因为当你离开学校以后，可能社会不会给你这个学习时间的。</p>
<h2>| Go语言，Docker和新技术</h2>
<p>如何提前判断一个技术能否引领未来的潮流呢？主要看4点：</p>
<ul>
<li>第1点，它解决了生产生活中的什么问题？</li>
<li>第2点，它有没有一个大型商业公司在背后推动。</li>
<li>第3点，它上手是否足够简单？</li>
<li>第4点，它的开发是否足够方便？效率是否足够高？社区是否足够完善？文档是否足够丰富？</li>
</ul>
<p>目前来看，Docker 和Golang 都是符合这个标准的新技术，现在学习还为时不晚。还有Paas也值得了解。有些读者可能不知道Paas的含义，它是Platform as a service的缩写，平台及服务，像谷歌的Google App Engine就是最早的Paas服务之一。</p>
<h2>| 答疑解惑：渴望、热情和选择</h2>
<p>公司总是加班，没有时间学习怎么办？我也想分享，如何才能长时间数年如一日的坚持？对于年轻人来讲，如何规划自己的人生道路。</p>
<p>这篇内容，作者主要回答了上面这三个问题。这三个问题是每个程序员都会遇到和思考的。我读了以后，深有体会，下面我说一下自己的感触。</p>
<p>对于公司总是加班，没有时间学习，这个要想想老祖先孟子说过的一句话：<strong>行有不得，反求诸己</strong>。作者的回答就很好，你有时间刷短视频，有时间打游戏，但是没有时间学习，为啥？因为学习是一个痛苦的事，是一个反人性的事，而打游戏是一件让你快乐的事情。</p>
<p>在学习这件事情上，要求我们主动鞭策自己，主动找碎片时间，常年坚持，积少成多，知识来源于点滴积累。另外还有一点，如果你真的到了一个经常加班以至于学不到新东西的程度，索性不如辞职。这个公司它已经不能让你成长了，无论是公司内成长，还是自修式成长，都不能让你成长了，那么你就选择果断地离开。离开也是一种成长，这条建议特别适合20~30岁的年轻人。</p>
<p>再看第2个问题，如何常年如一日坚持写作。人类会说话有100万年的历史，但是有文字会写作，只有1万年的历史。写作这个事情，确实是有难度的，它可能并不适合所有人，有的人天生就能写，但是有的人就不行。有的人一旦坐下来写作，他的大脑就短路了，脑子一片空白。但是这样的人，一般他善于交谈，一旦他和别人开始聊天，他的思维就连贯了，他的各种想法开始层出不穷。所以我觉得，写作这个事情也不必强求，如果你不擅长写，你可以尝试其他方式，比如说录短视频。运营一个视频号目前也是机会，找到适合自己的方式就好。</p>
<p>另外还有写书，这件事情有的人觉得写书在中国因为版税低，收入很低，远远不如做其他的事，像企业内训、软件外包来钱快。我想说的是，像企业内训和软件外包，这些事它就像沙滩上的城堡，海浪一来，随着岁月的冲刷，到年老的时候什么都没有了。</p>
<p>但是你写的书，当你年老的时候还能陪伴着你，这是一种岁月的回忆。另外，写书的收获不在于书内，而在于书外。还有就是，目前咱们国家正在处在科技腾飞的起飞阶段，这个时候需要有人做知识的布道者，做知识市场的开拓人，这既是荣誉也是机会。</p>
<p>再说最后一个问题，如何规划自己的人生。在这个问题上我觉得作者给的建议，都十分有用，20 ~ 30岁就是要拼命让自己成长，尝试各种可能性，说的更直白一点，不要长期在一个岗位上做重复的事情，一旦你感觉自己没有成长了，马上换岗。当然我不是鼓励跳槽，除了跳槽以外，你还可以选择内部创业或转岗，如果公司内部不给你机会，那你就到外面去寻找机会。30 ~ 40岁，正是干事业的时候，如果此时你的激情还没有完全被社会磨灭的话，你可以选择创业，选择一个适合自己的方向，去做一件自己真正喜欢的事情。</p>
<p>现代人的平均寿命已经提高了，原来我们讲一个人最年富力强的青春年华是在20 ~ 40岁，现在我觉得可以延长到50岁。30 ~ 50岁，一个人都随时可以开始创业，为社会创造价值。如果你觉得晚了，可以想一想褚橙。</p>
<p>至于具体从事什么样的职业，这个问题，我觉得很多时候，其实主要是看两点：一个是自己的性格，一个是运气。本质上我们做的很多选择其实都源于自己的性格。但我觉得这里有两点，可以分享一下：</p>
<p><strong>第1点</strong>，无论在任何情况下，哪怕你在一个竞争多么激烈的城市，一个内卷多么严重的公司，你始终都要坚持做一个不伤害他人的人，任何时候都不要做亏心事。这是第1点，因为不值得。可以不行善，但也不要作恶。</p>
<p><strong>第2点</strong>，要坚持自己的初心，有时候要有一点点情怀。有的人可能会说，那如果照你这样说的做的话，我可能就没有饭吃了。这个社会还不至于，整个社会的风气在慢慢变化，尤其在大都市。有时候这样做，反而可以找到志同道合的人，反而有一些不一样的机会。</p>
<h2>| 如何成为一个大家愿意追随的Leader？</h2>
<p>分享一个小故事吧，大概10年之前，有一年公司颁发最佳员工奖。当时大领导找到我，说你和你的属下都应该得奖，但是今年总公司只给了一个名额。我说如果只有一个名额，那么就把这个名额让给我的好兄弟吧。而我甚至从来没有把这件事情告诉过获奖人，我觉得这是他应该得的，也是我当时作为一名Leader应该做的。但是这并不是说，我就是一位合格的Leader，我还有许多需要学习的地方。</p>
<p>这篇文章讲如何做一名大家都愿意追随的 Leader，注意，这里的定语是大家都愿意追随，但是这样的Leader并不是谁想追随就能追随的，因为太稀少了。100个人里面没有一位，1000人里面也没有一位，1万人里面才可能出一位。</p>
<p>文章里有大量的篇幅对比了Boss和 Leader的区别。简言之， Leader是用自己的技术领导力，用个人魅力去带领团队，做事情的时候总是说「<strong>跟我上</strong>」，有肉吃和大家一起分享。甚至为了兄弟多得一些利益，愿意把自己的让出来。而Boss主要是用行政命令和制度，用组织关系，以机械的方式驱赶团队，「给我上」。一旦项目进展不顺利了，就要有人背锅，领导是永远没有错的。</p>
<p>两者在对待离职员工这件事情上会有本质的区别。 Boss的态度是，不准走，走就扣你工资，走就通过行内朋友打压你，让你找不到工作。而Leader则是帮助你，主动推荐公司给你，衷心祝你有更好的发展。即使你错了，也要帮助你提升认知。</p>
<p>一个由Leader带领的团队，是以项目为单位进行组织的。而Boss带领的团队，一般都是以工种进行划分的。如果你所在的公司有明确的前端后端分工，有专门的产品经理、QA，那么恭喜你，你的领导可能只是一个Boss，他不太可能是你可以真心追随的Leader。</p>
<p>尽管真正的 Leader这么少，但让人值得高兴的是，并不是只有在组织关系上的 Leader，你才可以追随。事实上你在社区里发现的，你都可以追随。你可以读他的书，学他的课，可以和他一起维护他开创的开源项目。追随的方式有很多种。</p>
<p>==（好，以上是前10篇的笔记，大约8800字）==</p>
<h2>| 程序中的错误处理：错误返回码和异常捕捉 &amp; 12 | 异步编程以及我的最佳实践⭐️</h2>
<p>这两篇关于错误如何处理的文章，干货特别特别多。它是帮助我们正确处理错误的终极方法论。包括各种常见语言，常遇错误，都谈到了。</p>
<p>软件不可能没有错误，当出现错误的时候，我们应该思考两个问题：</p>
<p>第一，这个错误是在哪里产生的？<br>
第二，这个错误最终要由谁来买单？由谁来消化？</p>
<p>我们依次看一下软件中三类常见的错误。</p>
<img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/20210331140429image-20210331140422862.png" alt="image-20210331140422862" style="zoom: 67%;" />
<p><strong>第1类</strong>，关统底层基础设施产生的错误，比如远程服务器通讯失败，内存耗尽，网络资源无法拉取等等这些错误。它们最终要由运维人员来买单，所以对这些错误的处理，我们要 Catch，同时监控，然后发短信或语音警报。</p>
<p><strong>第2类</strong>，中间件模块代码中的错误。这类错误有可能是调用底层代码产生的，也有可能是接受了来自上面业务层不合理的输入触发的。这些错误最终是要由开发者来消化，所以这些错误我们要Catch，并且要暴露出来。哪里出错了，具体错误信息是什么，然后都要报告给开发者。这些错误都要在开发阶段解决，所以越早暴露越好。</p>
<p>业务错误，一般公司要靠测试用例和QA把他们全部覆盖住。同时还需要程序员写上足够的Unit Test代码，自动化测试跑一跑，保证代码的健壮性。模块代码要有Swagger 文档，上层消费代码调用的地方需要考虑到所有错误，在文档中要有体现。</p>
<p><strong>第3类</strong>，发生在业务代码处。有可能是调用底层代码或者是模块代码产生的，也有可能是来源于用户错误的输入。对于前者，要把它们全部Catch 住，并在开发阶段消化掉；对于后者，要把信息通过界面反馈给用户，建议用户做出适当合理的调整。</p>
<p>对程序错误的处理，从处理与不处理来讲，又可以分为两种：</p>
<ul>
<li>
<p><strong>一种情况</strong>，是把错误抓住，再向上抛出去，本身不处理。这种情况一般发生在中间件模块层，当应用代码调用出错的时候。还有就是发生在业务代码层，由用户输入不当导致的错误，这种错误还给用户，让用户自己来消化。</p>
</li>
<li>
<p><strong>另外一种情况</strong>，是抓住错误以后自己消化掉，并且做相关的错误日志记录。这种错误一般属于运维错误，不是开发阶段能够解决的，一般在开发阶段也暴露不出来。</p>
</li>
</ul>
<p>当涉及到异步代码的时候，JS里面的<strong>异步转同步</strong>编程是最理想的一种方式。结合async / await语法可以让代码非常简洁。但是在这里，我不喜欢使用try-catch，至少不在明面上使用。我们至少可以在一层代码里面，例如在中间件模块层或者是业务代码层，专门有一个地方统一封装一下try-catch ，这样其他地方就不需要再写类似的catch代码了。</p>
<p>举一个最常见的场景，在业务层请求后端接口，这个地方，我们可以直接将try-catch和相关的 then 捕捉，都封装到一个requst 方法里面，并且这个方法还包含 n 次网络错误重试。这样我们在调用接口的时候，只需要使用await同步调用这个request方法就可以了。举一个代码伪例看一下：</p>
<pre><code class="language-js">let res = await http.request(url,data)// 内含网络不佳、服务器打盹等情况下自动3次重试机制
if (res &amp;&amp; res.errMsg === ‘ok‘) {
  ...
}else {
  ...
}
</code></pre>
<h2>| 魔数 0x5f3759df</h2>
<p>这篇内容虽然是选读，但非常值得一读。之所以作为选读，我觉得不是因为不重要，而是因为它确实有点难。普通文章可以2倍速快过，这篇文章可能对于大多数读者，即使全神贯注，第一遍也只是能了解个大概，很难明其细理。</p>
<p>既然这么难，为什么还值得阅读呢？因为它充分体现了程序员的一种孜孜不倦的探索精神。文章里说的这个魔数，它很神奇，是杜甫诗中那种「造化钟神秀」的神奇。这个魔数就像人类是如何进化出来的一样，它是<strong>理性+直觉</strong>的智慧结晶，是一代一代程序员大神接力完成的一个小壮举。</p>
<p>接下来我们就一起感受一下这个魔数吧。原作者已经很讲的很好，但有些读者仍然觉得没有看懂，我结合自己的学习体会，努力让内容再变得更加容易理解一些。</p>
<p>这个魔数是在下面代码第9行用到的：</p>
<pre><code class="language-c">float Q_rsqrt( float number ) {
    long i;
    float x2, y;
    const float threehalfs = 1.5F;

    x2 = number * 0.5F;
    y  = number;
    i  = * ( long * ) &amp;y; // evil floating point bit level hacking
    i  = 0x5f3759df - ( i &gt;&gt; 1 );  // what the fuck? 
    y  = * ( float * ) &amp;i;
    y  = y * ( threehalfs - ( x2 * y * y ) );  // 1st iteration 
    // 2nd iteration, this can be removed
    // y  = y * ( threehalfs - ( x2 * y * y ) ); 

    return y;
}
</code></pre>
<p>我们先不要先这个代码，即使是程序员，第一眼也很难直接看懂。首先，我们想一个问题，就是计算机是如何表示小数的？</p>
<p>整数很好表示，十进制转二进制就可以了。例如10，不断除以2，将余数从左向右排列，例如10转成二进制是1010：</p>
<img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/20210402180107image-20210402180105134.png" alt="image-20210402180105134" style="zoom:50%;" />
<p>但是小数怎么表示呢？要知道计算机里只有0和1，没有小数。我们举个例子，例如0.2这个小数，如何用二进制表达？</p>
<table>
<thead>
<tr>
<th>二进制</th>
<th>分式</th>
<th>十进制</th>
</tr>
</thead>
<tbody>
<tr>
<td>0.01</td>
<td>1*2^-2^</td>
<td>0.25</td>
</tr>
<tr>
<td>0.010</td>
<td>2*2^-3^</td>
<td>0.25</td>
</tr>
<tr>
<td>0.0011</td>
<td>3*2^-4^</td>
<td>0.1875</td>
</tr>
<tr>
<td>0.00110</td>
<td>6*2^-5^</td>
<td>0.1875</td>
</tr>
<tr>
<td>0.001101</td>
<td>13*2^-6^</td>
<td>0.203125</td>
</tr>
<tr>
<td>0.00110011</td>
<td>51*2^-8^</td>
<td>0.19921875</td>
</tr>
</tbody>
</table>
<p>（表格转绘于<a href="https://zhuanlan.zhihu.com/p/37524827">知乎答案</a>）</p>
<p>在这张图里，中间那一列，星号前的数字，是小数点后面的十进制值，星号后面是2的n次幂，小数点后面有几位，n就等于几。我们看到，第5行数字还大于0.2，第6行数字就少于0.2了，并且第5行只是比第5行二进制在尾部少了一个0.00000001。</p>
<p>我们发现，有些数字计算机无法精准表达，只能近似。明白了这一点，对于我们理解一个老生常谈的问题「浮点数0.1+0.2为什么不等于0.3」很有帮助。</p>
<p>有的读者可能会想，既然整数能用二进制表示，小数应该也能用二进制表示，为什么不能直接将小数用二进制表达成一个「整数部分+小数部分」这样的形式呢？</p>
<img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/20210403094451image-20210403094450055.png" alt="image-20210403094450055" style="zoom:150%;" />
<p>答案肯定是可以的。在上个世纪80年代，在小数形式没有被IEEE754浮点标准统一之前，确实存在很多表示小数的形式，其中之一就是<strong>定点数</strong>。如上图所示，78.375这个小数主要就由两部分组成，绿色区域是1001110，是十进制的78，红色区域是0.01100000000000000000000(20个零)，是十进制的0.375。这就是定点数的表示方法。</p>
<p>定点数的表示方法结构清晰、简单。</p>
<p>与定点数相对的是浮点数，目前应用最广泛使用的浮点数标准是IEEE754。一般教科书上32位浮点数的公式是这样的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/20210403173459image-20210403173457541.png" alt="image-20210403173457541"></p>
<p>其中E是指数区的数字，M代表的是尾数区的一个比值大小。</p>
<p><img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/20210403172112image-20210403172105901.png" alt="image-20210403172105901"></p>
<p>（图片转自<a href="https://fabiensanglard.net/floating_point_visually_explained/index.html">https://fabiensanglard.net</a>）</p>
<p>这个公式是怎么来的呢？为什么定点数这么清晰，但是最后复杂的浮点数却统一了天下呢？接下来我们看一下这个浮点数公式是怎么推导出来的，以及它有什么优点。</p>
<p>基于前面对定点数的了解，想一想0.2那个数字，我们不难想象，在二进制中，对于任何一个小数，都存在一个n，使其介于 2^n^ 与2^n+1^之间。</p>
<p><img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/20210402183919image-20210402183917560.png" alt="image-20210402183917560"></p>
<p>其中n可以是正数，例如2^1^（2） &lt; 3.14 &lt;2^2^（4）；也可以是负数，例如2^-3^（0.125） &lt; 0.2 &lt;2^-2^（0.25）。这也很好理解，假设2^n^有10个二进制位，那么2^n+1^刚好就有11位，在它俩之间，由于后面子位的变化，肯定还能容纳一些数字，于是它俩就构成了一个两端是整数的闭区间[2^n^ ，2^n+1^]。</p>
<p>那么，我们能不能这样，对于任何一个小数，我们能不能先确定它所在的<strong>闭区间的下限</strong>，以其作为起始值，然后再加上一个不大于<strong>2^n+1^-2^n^</strong> 的偏移量，这样不就可以表示一个小数了吗？</p>
<p><img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/20210403174448image-20210403174446637.png" alt="image-20210403174446637"></p>
<p>（图片转自<a href="https://fabiensanglard.net/floating_point_visually_explained/index.html">https://fabiensanglard.net</a>）</p>
<p>这是一个使用窗口和偏移量解释浮点数的例子。我们以3.14举例，它的闭区间是[2^1^ ，2^2^]，闭区间下限是2^1^，即2，二进制表达是10。由有在IEEE754浮点数标准中，E区为了同时可以表示正负指数，故意作了偏移，E-127等于指数，指数是1，所以E等于128，二进制是10000000（七个零）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/20210403175518image-20210403175516227.png" alt="image-20210403175516227"></p>
<p>（图片转自<a href="https://fabiensanglard.net/floating_point_visually_explained/index.html">https://fabiensanglard.net</a>）</p>
<p>那么尾部区数字应该是多少呢？</p>
<p>尾数区等于(3.14 - 2)/(4 − 2)*2^23^，等于4781507，二进制表示就是10010001111010111000011。相当于把尾数区分成2^23^个段，然后将3.14在闭区间[2^1^ ，2^2^]所在的位置，映射到这个尾数区域中来。</p>
<p>最终如上图所示，这正是3.14使用IEEE754标准表示的二进制形式。</p>
<p>现在我们尝试做一件事情，从这个示例中，归纳出浮点数的公式。为了表示方便，我们先将表示正负的符号位略去：</p>
<p>X = 闭区间窗口左边界 + 窗口偏移量 = 2^n^ + M / 2^23^ * (2^n+1^-2^n^)</p>
<p>其中M是偏移量。因为二进制比较特殊，2^n+1^-2^n^其实就于2^n^ * 2 - 2^n^，等于2^n^。所以：</p>
<p>X = 2^n^ + M / 2^23^ * 2^n^</p>
<p>组合一下，并且将n由E-7替换掉，再加上符号位，就变成了：</p>
<p>X = (-1)^S^ * (1+M/2^23^) * 2^n^</p>
<p>对于上述公式，忽略一些常数，可以简化为：</p>
<p>X = (1+m)∗2^e^</p>
<p>对于整数，不需要偏移量，32位的整数公式可以这样写：</p>
<p>X = E∗2^23^ + M</p>
<p>那么接下来我们看一下，浮点数有什么优点呢？</p>
<p>浮点数虽然复杂，但是相同的二进制位数，它比定点数表示的范围更大，精度更高，因为它应用的范围最终也最广。当然了开始的时候程序员可能也没有想这么远，定点数可能是浮点数产生的土壤，正是因为看到了定点数的不足，然后才在此基础上才发明了浮点数。</p>
<p>解释了这么多，刚刚在解释魔数上走完了第一步。接下来就是关于平方根倒数据公式的推导，首先看一下正宗的平方根倒数公式：</p>
<p><img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/20210403204231image-20210403204229490.png" alt="image-20210403204229490"></p>
<p>平方根基本都理解。什么叫倒数？标准定义是，一个数与其乘积为1的数。也就是将一个数作为分母，1作为分子，这样形成的数就是原数的倒数。表现在指数上，就是在指数的绝对值上加上负数。平方根表现在指数上，是2的倒数。同理，如果是立方根，就是3的倒数。</p>
<p>接下来，我们将公式两边取以2为底的对数，于是公式变成了这样：</p>
<p><img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/20210403205038image-20210403204842047.png" alt="image-20210403204842047"></p>
<p>什么是对数？</p>
<p>一般人对幂运算比较清楚，但是对对数可能不了解。像2^n^这是幂运算，所谓对数是求幂的逆运算。如果有a^x^ =N，那么数x就是以a为底，N的对数。</p>
<p>取对数一般用数学符号log表示，以2为底取y的对数，就是log~2~(y)。对x^-1/2^以2为底取对数，就是log~2~(x^-1/2^)。</p>
<p>参照对数的基本运算规则，我们看一下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/20210403210123image-20210403210122126.png" alt="image-20210403210122126"></p>
<p>log~2~(x^-1/2^)也等于-1/2 * log~2~(x)，应用的是第4条规则。</p>
<p>接下来就要用到前面提到的浮点数公式了，因为x是小数，我们将简化的浮点公式（X = (1+m)∗2^e^）带入上面的公式，于是得到：</p>
<p>log~2~( (1+m~y~)∗2^ey^) = - 1/2 * log~2~( (1+m~x~)∗2^ex^)</p>
<p>再运用一下上面提到的第2条和第6条对数运算规则，于是就变成了：</p>
<p>log~2~(1+m~y~) + e~y~ = -1/2 * (log~2~ (1+m~x~) + e~x~)</p>
<p>到这里，在逻辑上数学公式能做的事基本做完了，接下来要到发挥想象力的时候了。由于m~y~和m~x~都是M与2^23^的比值，它是一个在区间(0,1)之间的值。这样一来，我们可以将对数曲线函数，得以近似转换为一个直线函数：</p>
<p><img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/20210403211457image-20210403211241641.png" alt="image-20210403211241641"></p>
<p>这一步是关键，因为我们本来要计算的就是近似值，就是为了牺牲一定的准确度，而换取高效率。不得不佩服第一次想到这个办法的程序员，他一定相当的聪明，不仅长于逻辑推理，还富有想象力。</p>
<p>再往下就没有什么需要多加解释的啦，原文中就写的很明白，基本上就是代入前面已经推导好的浮点公式和整数公式，最后终于将平方根倒数公式推导成为了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/20210403211717image-20210403211716119.png" alt="image-20210403211716119"></p>
<p>其中I~x~是一个整数，R是一个常量。</p>
<p>接下来，又到了程序员秀工程智商的地方了，这个R是啥？R就是这篇文章标题中提到的魔数。那这个魔数是怎么算出来的呢？</p>
<p>可能就是基于大量历史数据，归纳出来的一个估值。正常情况下，我们可以用平方根倒数公式，用正常的、效率低的方式，算出应该的得数，然后将得数代入上面的这个精简的公式，将I~y~替掉，算出R的值。</p>
<p>由于我们前面将对数曲线函数，转换成为了直线函数，这中间是有误差的，所以就多次代入，暴力求解，最终得到一个使测试数据误差最小的R常量。然后再把这个常量用到程序代码中。</p>
<p>优化这个常量R，是一个从1到1万的活，是一个工程的话。前面我们提到的曲线转直线，以及将浮点公式带入，是一个从0到1的创举。</p>
<p>故事讲到这里，刚进行到了第二步，接下来还有进一步的工程优化。</p>
<p>由于前面我们在计算过程中取了近似值，误差肯定是有的。接下来又有一位聪明的工程师想出了使用牛顿迭代法，近一步将误差缩小。我们看看他是怎么做的。</p>
<img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/20210403213124image-20210403213122916.png" alt="image-20210403213122916" style="zoom:50%;" />
<p>所谓<strong>牛顿迭代法</strong>，是在曲线上不断做切线，取切线与坐标轴的交点，例如x~1~，再于曲线上x=x~1~的点继续做切线，不断向方程解逼近的一种近似求解的方法。这种方法非常像创业，在创业中只要能找到像牛顿迭代法这样的抓手，一步一步逼近，效率就会越来越高，成功也会越来越近。</p>
<p>牛顿迭代法依据其定义，还有一个通用公式：</p>
<p><img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/20210403213641image-20210403213639456.png" alt="image-20210403213639456"></p>
<p>在这里f’(x~n~)是f(x~n~)的<strong>导函数</strong>，这又是一个概念。</p>
<p>什么导函数？导函数是怎么来的？网上有人做了一个简单的推导：</p>
<img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/20210403213731image-20210403213728962.png" alt="image-20210403213728962" style="zoom: 25%;" />
<p>（图片转自<a href="https://www.zhihu.com/question/61401053/answer/187375676">知乎</a>）</p>
<p>所以，对于f(y)=y^-2^−x这个函数，因为x此时相当于是常数，直接被略去了，所以它的导函数，按上面推导出来的公式，是f‘(y)=-2 * y^-2-1^。那进一步变换一下，就成了f’(y)=-2y^-3^。</p>
<p>然后将函数，与导函数，代入上面牛顿迭代法的通用公式，于是就得到了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/20210403215702image-20210403215700412.png" alt="image-20210403215700412"></p>
<p>这一步没有别的目的，就是用牛顿迭代法，使我们前面近似求出的平方根倒数更加精准一点。原文中有明确讲解的，我都不再讲了。强烈建议感兴趣的读者阅读一下原文。</p>
<p>好了，这个关于魔数的故事讲完了。我不知道你是什么感觉，我的感觉是这样的，它非常像我们人类的进化。今天我们看自身，我们觉得人类与猿猴已经相去甚远，但是在我们进化的过程当中，也有可能充斥着一些魔数。这些魔法它们怎么产生的？无非就是在资源不充足、算力不够的情况下，个别富有想象力的天才猿猴突发奇想，走出了一条不同寻常之路。之后又有人在他从0到1的基础之上，继续迭代完善，以至于后来人类都看不到来时路的模样了。</p>
<h2>| 推荐阅读：机器学习101</h2>
<p>这篇文章推荐了大量的关于机器学习和深度学习的课程以及资料，好多都是免费的。全部学完这些内容，基本上整个夏天都要过去了。</p>
<p>我个人比较倾向于学一些实用型的技术，就是怎么样在工程层面，加一些已经可以直接应用的人工智能功能，到应用中去。我感觉关于TensorFlow的那9节课就不错，每节只有10分钟。</p>
<h2>| 时间管理：同扭曲时间的事儿抗争 &amp; 16 | 如何利用好自己的时间？</h2>
<p>这两篇文章是关于如何管理时间的，这是每个人都应该学习的内容。</p>
<p>在学习时间管理之前，首先要了解一下，人作为一种智慧动物，与时间有关的规律有哪些；其次，要懂得管理自己的周遭环境和人际关系；最后，要学会管理自己的目标和行为。</p>
<p><strong>1，认识规律</strong></p>
<p>有一本书叫《蜥蜴脑法则》，这本书提到在我们每个人体内，在理智的大脑之下，都有一个原始的蜥蜴脑存在。这个蜥蜴脑总想贪图享乐，好逸恶劳。当我们工作了一段时间以后，它会说，“休息一下吧“。一个自律的过程，就是不断与这个蜥蜴脑作斗争的过程。可以说，自律如逆水行舟，不进则退。</p>
<p>还有充足的睡眠，与富有营养的食物，这些都为自律提供了良好的物质基础。据有关研究发现，当人处于饥饿状态的时候，血液中的血糖过低，这时候自控力会大大降低。所以如果要保持良好的自律习惯，保持良好的作息，按时吃饭，不暴饮暴食也很重要。</p>
<p>在时间管理领域还有一个「<strong>二十英里法则</strong>」。有这样一个故事，美国西海岸圣地亚哥距离某地目录有3000英里，有一个心理学家发现，能够坚持徒步到达目的地的人，不是走的最快的，也不是因环境变化而聪明应对的，相反只有那些不管什么天气，每天只走20英里的人，才能最终到达目的地。这个典故告诉我们，时间是我们的朋友，只有坚持不懈的人，才能获得时间上的复利。</p>
<p>人很容易受环境影响。在一个干净的餐厅，例如KFC，如果服务员不停地打扫，这种情况下就餐的人也不好意思随地丢垃圾，甚至还会主动将餐盘收走。再举一个例子，在图书馆，大家都安静看书，你也不会好意思大声喧哗。如果环境能给人及时反馈，或者人能预知到这种反馈，这时候人的言行就会受到环境的约束。我们可以利用这一点，达到养成某些习惯的目的。</p>
<p>还有一个<strong>承诺一致</strong>原则。如果我们在某个场合公开说了什么话，就倾向于兑现这个承诺。</p>
<p>以上，就是在人的身上，与时间管理有关的规律，这些规律都是客观的。利用好这些规律，才能把时间管理这件事做好。</p>
<p>接下来我们看环境。</p>
<p><strong>2，管理环境</strong></p>
<p>环境分为现实的物质环境，和虚拟的人际关系。</p>
<p>为了让每天的工作都卓有成效。我们可以设个闹钟，定点起床，专门准备一间书房或一个角落。工作的地方远离沙发、床铺和电视，摆上闹钟，纸、笔等学习和工作用具，这样的环境利于帮助我们进入工作状态。</p>
<p>如果你在某个公开场合，立了一个Flag，让大家看到了。有许多同行人，那么同行人可以监督你或鼓励你。例如最近充电平台上架的<strong>学习排行榜</strong>功能，就是在学习活动中融入了游戏元素。</p>
<p>这两篇文章里面，提到了外企和国企的氛围差异。在15年前就是这个样子，不要企望短期内这个风气可以改变。在国内企业，厂子里确实有一些人是不好好工作的，是混水摸鱼的，正是这些人的行为，形成了普遍的一种领导对员工的认知，以为只要不管理，只要监管松一些，下属就会偷懒。</p>
<p>事实上，还有一些有理想有追求的人，即使公司放假了，要求员工休息，他都在奔跑。如果没有智慧的领导，以一种大众的偏见，用一刀切的制度，管理所有下属，那么势必会打扰甚至伤害这些积极工作的人。有时候他们还会觉得，如果制度不能一视同仁，会让人不服。为了让庸人服气，不惜伤害真正用心的人。不能因人而管理，是没有智慧或懒惰的体现。</p>
<p>这种职场状态是普通的，抱怨是没有用的，唯一有效的应对方式就是了解，然后变被动为主动，主动管理自己和领导、和周围同事及下属的关系。</p>
<p>一个有效的办法，就是让自己的工作时间表透明，多争取一些信任。</p>
<p>在这两篇文章中，作者给出了三个说「不」的话术，这三个话术我觉得每个职场人在上班前都应该知道。当被要求加班，或压缩工时的时候，可以这样说：我可以加班加点按时完成任务，但是不能保证质量，如果有了bug，概不负责，并且上线后我需要1个月的时间消化不良代码。一听有bug，对方多半都不同意，这时候还可以说：我可以保质保量地完成，但是做不了这么多需求，有些需求必须砍掉。一听砍需求，对方可能也不会同意，这时候就可以说：我还可以保质保量地完成所有需求，但是时间必须延长二周。</p>
<p>你看，「诡」吧，我读到这里的时候，我都觉得做程序员太难了。当然了，上面这个话术是理想情况，有时候你应用了这个话术，也并必能得到自己想要的。起决定性作用的，往往还是文化。</p>
<p>接下来再说一下开会、会谈和通电话。这三者本质上是一样的。如果我们没有目的，这三个活动都可能失控，会浪费我们不少时间。</p>
<p>关于开会，作者说的已经非常好了。开会之前就要准备好<strong>议题</strong>，12345，还有每个<strong>议题的方案</strong>，123。开会是为了同步和确认，同步所有人的认知，立个Flag；确认所有人的责任，和关键的时间节点。大多数人开会没有效率，都是因为本来应该在会下完成的议题断定和方案筛选，都拿到了会上进行。有些产品经理将开会当成工作，但开会不是程序员的工作，所以没有几个程序员是喜欢开会的。</p>
<p>会谈和通电话是一样的，你想和对方聊什么，想交换什么单见，最好像购物一样列一个清单。当清单完成的时候，就可以中止这项活动了。</p>
<p><strong>3，管理自己</strong></p>
<p>如果说认识规律，和管理环境都是容易的，那么接下来对自己的管理却不那么容易了。管理自己主要是管理自己的目标，包括任务的优先级，还有管理好时间投资的方向。</p>
<p>一个人无论多么聪明，有两项能力不一定拥有：一是<strong>认清人生目标</strong>，二是<strong>断定路径价值</strong>。这两项对一个人的影响非常大，也和时间管理有关系，甚至需要半生甚至一生去学习。</p>
<p>我们相信每个人来到这个世界上，都有他独特的价值，大多数人普普通通，不是因为资质平平，只是因为选择太多；相反有些残疾人，资质弱于常人的人，反而取得了常人没有取得的成就，这是因为很多时候他们没有选择。他们不需要学习如何认清目标，以及如何选择路径，因为命运往往只抛给了他们一根稻草。</p>
<p>一个人觉得自己无所不能的时候，其实是什么也做不成的，只能做成一些小事，做不能大事；只有当一个人认识到他这也不能做，那也不能做的时候，他才有可能认清自己的人生目标。目标选定以后，接下来就是路径价值的判断。</p>
<p>通向罗马的路有千万条，但是当你的位置和罗马的位置确定以后，只有一条路是最近的。如何判定是哪条路呢？很多人都没有这个能力，特别是当做某件事没有经验时，我们很难判断接下来应该怎么做。当遇到困难的时候，我们应该坚持，在一个地方深耕呢？还是要学会变通，不要在一颗树上吊死呢？因人而异，而时而异，没有标准答案。这项<strong>路径价值判断</strong>的能力，只能独自练习。</p>
<p>在有了这两项能力以后，剩下的事情就好办了。制定一个需要经年累月才能完成的大目标，制度年度计划，季计划，月计划，为每周制定计划。每天早上起来刷牙的时候，可以想一下今天要做什么；每天晚上刷牙的时候，可以想一想今天做了什么，有什么事做的好，有什么事做得不好。这是目标管理。</p>
<p>在目标管理领域有一套SMART方法，是被广为接受的一个目标制定方法。</p>
<p><img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/2021040415210920210120111311.png" alt=""></p>
<ol>
<li>S代表明确。如果一个目标，连机器都能判定是否完成，那么它一定是明确的。</li>
<li>M代表工作量可衡量。如果连机器都能自动判定工作量完成了多少，那么M的标准就达到了。</li>
<li>A代表目标有没有可能达到。在判断一个目标有没有可能实现时，不能凭主观臆断，一般从三个方面判断：1）这件事别人有没有完成过；2）这件事以前咱们有没有人完成过，这是指经验；3）如果前两项判断都不成立，那么从逻辑上分析，这件事有没有可能完成。</li>
<li>R代表相关性。就是完成这件事，对完成大目标有什么增益价值。</li>
<li>T代表时限性。做任何计划都要有一个最终时间点。</li>
</ol>
<p>使用SMART方法，将大目标拆分为一个一个可执行的小目标后，接下来就是做事情的方法。最经济的方法，是<strong>把每一个事情都当成一项工程</strong>来做。所谓工程，每个节点都追求时间可控。</p>
<p>举个例子，一个婴儿的孕育需要十个月的时间，在这十个月里，无论营养是否充足，时间一到，都会分娩。这就是工程管理的艺术，在每个时间点，确定要做某个特定的事情，在单位时间段内，争取把任务完成得最好；如果没有100%完成，也不要影响下一个时间段工程的开始。这就是<strong>工程思维</strong>。要管理自己的时间，必须有这个思维。</p>
<p>有了以上能力和管理方法，剩下的就是关于时间的算术题了。</p>
<p>例如，花时间学基础知识，啃原始文档。建立全面的目标技术知识结构，在遇到问题的时候，知道要向哪里寻找答案。这是投资一次，避免多次浪费的时间投资。</p>
<p>例如，做一些软件自动化配置，或使用自动化工具。机器能干的活，就不要让人干。</p>
<p>例如，花钱节省时间。在信息的获取上，直接购买专栏，而不是到处搜索零散的内容。直接购买付费软件，而不是忍受盗版。付费软件可以自动更新，与时俱进使用最新功能，还没有广告。还有，花钱购买更高配置的电脑，让工作更高效。有时候付费就是节约。</p>
<p>这一点我做的就很不好，我凡事都想节约，在更新设备这件事上，我一直都是能用则用。拿我在充电平台录课这件事来说，由于我自己的电脑是8年前的旧款，不是高清屏，分辨率不够，所以每次录制都是借用充电公司的电脑，但如此一来，每次都要来回拷贝文件。如果我舍得花这一万块钱，就不用忍受179次的浪费了。</p>
<p>再如，关于目标的优先级，先完成优先级高的事情。那么哪些事情优先级高呢？这个主要看SMART中R，看与总目标的相关性。应该把精力最好的时段，留给最重要的任务；而一些非紧要任务，非困难任务，可以采用<strong>双工模式</strong>。</p>
<p>所谓<strong>双工模式</strong>是这样的，在工作的时候，主要在电脑上，用双手和眼睛工作，这时候耳朵是空闲的，所以一般情况下可以选择听书。听樊登读书，或听充电平台。这个时候听书是一种需要，而不是一种任务了。时间长了，如果工作的时候不听，还会觉得不习惯；而工作开始的时候，同时启动听书，也更容易进入工作状态。这种模式开始我也不习惯，但久了就离不开了。它可以让我们在一份时间内完成两份事情，这相当于我们每天比别人多出一倍的工作和学习时间。</p>
<p>除了双工模式，还有一种写作技巧，我觉得也很好，就是双写作模式。用手机和电脑同时打开一份共享文档（我一般使用石墨文档），在手机上用讯飞语音输入，在电脑上用五笔修改一些错字，以及处理一些表格、图片等信息。这种方式可以极大提高写作效率。使用这种方式的时候，一定要记得开启手机免锁屏，以及设置输入法最大时间的免跳转。</p>
<p>后来我发现PC版本的讯飞还有一种跨屏语音输入的能力，可以将手机用作PC语音识别的话筒，效率也不错；还有，现在PC版本的语音识别本身准确率也很高，可以直接在电脑上作语音输入。</p>
<pre><code>// 下面这首诗识别率就很高
床前明月光，疑是地上霜。
举头望明月，低头思故乡。
</code></pre>
<p>遗憾的是，讯飞一直不支持五笔输入，我使用讯飞语音识别的时候，还必须在它和一个五笔输入法之间做频繁切换，这一点很不爽。工具是不断变化的，相信以后会有更好的工具。</p>
<p>以上就是我学习这篇文章以后所有的感悟了，很多内容都是想到了，但是不一定能做到。关于时间管理，确实是一项值得我们不断修炼的技能。</p>
<p>==（第二段到这里结束）==</p>
<h2>| 故障处理最佳实践：应对故障 &amp; 18 | 故障处理最佳实践：故障改进⭐️</h2>
<p>《黄帝内经》中说：“上工治未病，不治已病”。这句话用在运维实践中也很实用，就是我们要努力去避免线上故障的发生，而不是在故障发生以后手忙脚乱地处理。</p>
<p><strong>自动化的运维工具</strong></p>
<p>我们需要根据用户功能，创建一张全站点的资源地图。在这张地图中，每个节点都必须有一个相对完善的运维工具，这个工具可以帮助我们检测这个节点有没有问题，帮助我们定位问题，以及有问题了怎么处理。是降低处理，还是回滚代码，还是紧急更新，都需要在这个运维工具中有自动化的支持。</p>
<p>有了这个工具还不够，我们还需要适当的采用一些灰度更新，和平时期的故障演练，来避免线上真实故障的发生。这就是内经里讲的治未病。此外，我们还要思考，我们的系统架构是否合理？团队的工程能力是否到位？以及在故障发生后，如何复盘（Ask 5 Whys），如何对待故障责任人。</p>
<p>对于一个经常发生线上故障的公司来讲，有三样东西是非常有价值的：</p>
<ul>
<li>
<p>第一，一套全自动运维工具，并且支持分布式；</p>
</li>
<li>
<p>第二，一个合理而富有弹性扩展能力的分布式系统架构；</p>
</li>
<li>
<p>第三，一个让团队不断学习，工程能力不断提升的技术管理规范。</p>
</li>
</ul>
<p><strong>如何处理故障责任人</strong></p>
<p>在文章中，作者提到了关于如何处理故障责任人。有的公司主张采用罚的方式，罚钱或降级。这是惩罚措施，其实只适用于非创造性岗位；对于研发岗位其实是不适合的。惩罚会在文化层面上起副作用，它会让大家以后做事情畏手畏脚，不敢放手尝试。多做不如少做，少做不如不做。原理上讲所有创新都是有风险的，创新产生故障的机率都很大。你要鼓励创新，就要容忍犯错。</p>
<p>我想从另外一个层面说一下这个问题。其实每一个有追求的程序员，他都希望自己写的代码很漂亮，架构很合理，软件很稳定，这是他的技术追求，是人性中向上的一面。所以我的想法是，对于线上故障，我们应该更多的去挖掘人性中积极向上的一面，而不应该去处理导致故障的直接负责人。说实话发生一次线上故障，给直接责任人定责很容易，但故障背后可能是一个工程问题，是一个团队管理问题，甚至是一个公司文化问题。这时候你怎么好意思只处理直接负责人呢，对吧。</p>
<p>最好的方式还是惩前毖后，治病防病。分享一个在公司中亲身经历的见闻，有一次团队组织大家学习一个技术，而这个技术让某个后端兄弟主讲。这个兄弟新来不久，为啥让他分享呢？后来才知道，由于他对这项技术使用不当，导致了线上一次故障，所以公司安排他主动学习并做会议分享。</p>
<h2>| 答疑解惑：我们应该能够识别的表象和本质</h2>
<p>这篇文章是教我们如何进行深度思考的，如何透过表象看清问题的本质。</p>
<p>首先第一点，如何看待兴趣？一般常识告诉我们，兴趣是最好的老师。但是兴趣这个东西，如果说长期坚持，不能给我们带来正反馈和成就感的话，那么我们可能很难坚持下去，这个时候兴趣可能就会变成一种压力了，那这种现象其实在家长给孩子报兴趣这件事情上就可以很好的体现出来。</p>
<p>关于这一点，我其实有那么一点不是很一样的看法。我自己有一个很小的兴趣爱好，已经陆续坚持十几年了，就是吹管弦乐，我喜欢吹笛子、箫这些乐器。但是我在音乐上天赋真的又非常差，我都难认准确识别音高，每次练习，我都是练得完全没有兴趣，然后就不练了。过了一段时间，工作累了，又拿起来吹一下。我从这件事里得到的正反馈和成就感非常少，但是也从来没有放弃过，我一直视其为我的灵魂爱好。</p>
<p>在上一篇里面，我们聊到了<strong>认定人生目标</strong>，还有<strong>判定路径价值</strong>。这两点能力其实对每个人来讲，都非常难。有的人可能一生都找不到一个明确的目标，就是觉得好像对什么东西都感兴趣，又好像对什么东西都不感兴趣一样，很难找到某一个兴趣点持续坚持下去，很难找到一个能够持续收获成就感的目标。我觉得这也是很正常的，因为大多数人就是做不到。</p>
<p>另外还有一点，就是关于学习，我们一向以为在工作中学习得更快。其实这个问题的本质，在于我们在工作中，有实际要解决的问题，有更为紧迫的时间，当然还可能有高手可以切磋。在实践中学习，在任何时候效率都是最高的，无论是在什么样的一个场景中，是在工作中，还是在开源软件的开发中，还是在一个PBL教学实例中。</p>
<p>现在开源社区发展的很好，加入开源软件的贡献者队伍，同样可以学到很多东西。门槛更低，要求更少，很多开源大神也非常nice。这两年开源软件发展得很不错，有些国外的孵化器投资国内一些云原生公司的要求之一，就是看软件是否完全开源。</p>
<p>文章中还提到了什么技术是未来的趋势。有一种观点说，看未来社会中的痛点在哪里，痛点在哪里趋势就在哪里。还有一种观点说，看大企业和国家把资源投向哪里。很多时候这两者是重合的，那些大企业他们也特别注重解决未来的社会痛点，这是企业赖以长久生存的基础嘛。比如说人工智能，像谷歌、Facebook这些大厂都在大力度投入。咱们国家更是将人工智能的世界领先，列为了2035年的科技目标之一。</p>
<p>说到人工智能，现在的人工智能一直都是弱人工智能，有多少人工，才有多少智能。未来如果这一块有所冲突了，可以将类似于人类意识的某种东西，通过量子纠缠或其它形式，注入到计算机的CPU当中，那个时候上面的很多行业都会发生翻天覆地的变化。这个基础技术的创新，就是在一个很大的范围上，在科技杠杆的支点上，发挥了巨大了的作用。这样的技术就是牛x的技术，但是对于我们大多数程序员来讲，是触碰不到的。我们能触碰到的，反而是视频号、小程序这样的技术机会。这些技术虽然含金量不高，但却影响了几亿人，甚至以后还会影响十亿人。</p>
<p>不知道你读了是什么感觉，总结一下就是四个字：深度思考，从动力因、目标因、质料因和形式因各种因果关系中，找出动力因，这是因果关系里面的主要方面。</p>
<h2>| Git协同工作流，你该怎么选？</h2>
<p>什么叫工作流？Git工作流什么意思？这来源于英文翻译，英文叫Git workflow，翻译成中文就是Git工作流。从workflow这个单词的字面来理解，它是一个让工作流畅、不发生阻滞的一个规范。再说得直白一点，就是git仓库的使用规范，告诉我们在开发中应该如何使用git仓库。</p>
<p><strong>git工作流</strong></p>
<p>如何使用git仓库，看git操作文档不就可以了吗？我们看一张图，看完这张图就明白了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/20210405104058image-20210405104051925.png" alt="image-20210405104051925"></p>
<p>（图片转自专栏原文）</p>
<p>这个图里的规范，被称为GitFlow，最早是由一个老外文森特·德里森（Vincent·Driessen）在2010年发明的。它是一个方法论，它将一个git仓库强制分为两个主要分支，一个是master或main线上分支，另一个是developer研发分支。</p>
<p>当线上有bug时，新增一个hotfix分支，bug解决后同时将这个临时分支的代码，同步至两个主要分支内。这一点也很好理解，如果只同步到了线上分支，或忘记往开发分支同步了，那么下次版本上线老bug又出现了。工程管理问题就出现了。</p>
<p>常规的开发，分小组（或个人）进行，每组一个feature分支，本地开发完了，往developer分支合并，在测试环境测试。测试环境没有问题，将所有待发布的功能点对齐，创建一个临时release分支，部署到预发环境。预发环境测试没有问题，再推到线上。</p>
<img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/20210405105708image-20210405105706216.png" alt="image-20210405105706216" style="zoom: 67%;" />
<p>现在明白了吧，因为在研发过程中，我们需要不同的软件环境，每个环境要对应不同的仓库代码，而我们的开发又不能停止，还需要实现CI/CD，也就是持续集成（Continuous Integration）与持续发布（Continuous Delivery），这个时候Git协作工作流规范就应运而生了。</p>
<p>那有人可能会问，为什么要搞多个环境呢？这不是为了控制版本更新的风险吗，线上有百万用户正在使用产品呢，发版如果有问题，影响了用户怎么办？事实上在中国确实到今天都有许多公司小团队，是不使用Git工作流的，版本更新都是直接从程序员的开发机怼到线上去，这时候什么测试用例覆盖率、上预发、回归测试都是浮云。</p>
<p>用过一段时间的GitFlow你会发现它有可能，虽然很严谨，但是有点麻烦，不适合小步快跑。于是后来就有了改进版的Github Flow，</p>
<p><img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/20210405111729image-20210405111230244.png" alt="image-20210405111230244"></p>
<p>（图片转自<a href="http://www.ruanyifeng.com/blog/2015/12/git-workflow.html">阮一峰博客</a>）</p>
<p>在这个规范中，两个主分支变成了一个，只有一个Master或main分支。当线上有bug或开发新功能时，从主分支拉出一个补丁分支，开发完成后，向主分支发起PR，也就是Pull Request。处理PR的过程，就是一个讨论、决策和优化的过程，最后没有问题，就把补丁合并到主分支上，同时临时的补丁分支被删除。</p>
<p>虽然这个协作规范简化了，但是在企业团队中它也有问题，它影响团队的持续交付。企业要求发版不能影响开发，不能因为有一个小组要发版，其它小组都要被阻塞。于是更一步改进的Gitlab Flow。</p>
<img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/20210405112057image-20210405112055833.png" alt="image-20210405112055833" style="zoom:67%;" />
<p>（图片转自<a href="http://www.ruanyifeng.com/blog/2015/12/git-workflow.html">阮一峰博客</a>）</p>
<p>这个规范在Github Flowr基础上，增加了两个分支，一个是pre-pro分支，用预发测试，另一个是pro分支，用于线上生产。Gitlab规范是前面两种规范在企业开发中妥协的结果。事实上仍然有人使用GitFlow规范，因为它足够严谨；Github Flow也有许多人使用，Github 开源网站本身用的就是这个协议。</p>
<p>Gitlab Flow规范除了企业版本，还有一个开源版本：</p>
<img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/20210405112510image-20210405112509117.png" alt="image-20210405112509117" style="zoom: 67%;" />
<p>（图片转自<a href="http://www.ruanyifeng.com/blog/2015/12/git-workflow.html">阮一峰博客</a>）</p>
<p>这个版本适合开源软件的研发，它将每个稳定的发行版都固定为一个分支。</p>
<p><strong>git使用技巧</strong></p>
<p>在使用Gitlab Flow或Github Flow时，有一些git技巧是必须要掌握的。</p>
<img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/20210405114025image-20210405114023413.png" alt="image-20210405114023413" style="zoom: 67%;" />
<pre><code class="language-bash">git clone git@gitee.com:rxyk/git-test.git --depth=1
</code></pre>
<p>git clone将远程仓库代码拉取本地。depth参数用于控制拉取层次，在拉取一些历史悠久的老仓库时很有用。</p>
<pre><code class="language-bash">git add .
git stash
// output: Saved working directory and index state WIP on master: 040d83b Initial commit
</code></pre>
<p>当我们在本地写代码的时候，如果线上有个问题必须马上处理一下，而本地的代码还没有写完，还不能提交，这时候应该怎么办呢？git stash指令可以帮助我们将本地的修改，暂时藏匿至一个看不见的区域。</p>
<pre><code class="language-bash">git checkout -b hotfix-0404
...
git add . // 添加所有新增或修改文件
git commit -m '...' // 指定提交消息，描述本次修改
git push origin hotfix-0404 // 推送
git pull origin master --rebase // 
// output: CONFLICT (add/add): Merge conflict in c.txt
</code></pre>
<p>在处理线上问题时，我们需要先迁出一个临时分支，例如叫hotfix-0404。</p>
<p>在合并代码之前，最好先在临时分支里使用rebase指令，尝试合一下主干代码。在合并代码时，如果别人提交过代码，这时候是可能出现冲突的：</p>
<img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/20210405122630image-20210405122628337.png" alt="image-20210405122628337" style="zoom: 67%;" />
<p>我们需要手动编辑冲突，将所有冲突fix掉，然后继续执行指令：</p>
<pre><code class="language-bash">git add c.txt // 还可能有其它文件
git rebase --continue // 最后修改提交消息
git push origin hotfix-0404 // 推送
</code></pre>
<p>rebase操作也可以用于在小组内同步代码。时不时同步一下代码，可以避免代码积攒太多不好处理。如果你对项目做了不小的重构修改，最好也及时通知其它组员更新。</p>
<p>分支代码处理完以后，接下来到主分支，开始合并分支代码：</p>
<pre><code class="language-bash">git checkout master
git pull origin master --rebase
git merge hotfix-0404 --no-ff
</code></pre>
<p>在合并分支的时候，仍然有可能出现冲突。这时候也需要手动编辑所有冲突，完成后再执行：</p>
<pre><code class="language-bash">git add c.txt // or others
git merge --continue // 
git push origin master
</code></pre>
<p>在这个地方，使用merge指令的时候使用了一个参数<code>--no-ff</code>。如下图所示，使用这个参数的好处，在于主分支提交历史更加清爽，这有利于线上代码的回滚。</p>
<img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/20210405135949image-20210405135942552.png" alt="image-20210405135942552" style="zoom: 80%;" />
<p>经过这一番折腾，线上bug终于解决了。接下来我们可以继续编写我们本地暂存的代码了：</p>
<pre><code class="language-bash">git stash pop
</code></pre>
<p>使用stash指令将代码取出来继续编辑。有时候我们一不小心写错了分支，也可以使用stash指令将新增的代码暂存起来，然后新增一个分支，再将暂时的代码恢复在新分支上，这样也是可以的。</p>
<p>以上就是我关于这篇文章所有的学习心得了。git操作是一个程序员的基础技能，git指令可以干很多事情，指令用得好，胜过IDE工具。</p>
<p>（暂时就这些）</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[Stay hungry, Stay foolish]]></title>
            <link>https://yishulun.com/./src/posts/2021/33.html</link>
            <guid>https://yishulun.com/./src/posts/2021/33.html</guid>
            <pubDate>Wed, 17 Mar 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>Stay hungry, Stay foolish</h1>
<p>这仅仅是一个谦虚的态度吗？不是的；或仅仅是一句伟大而著名的格言吗？更加不是的。它是一句充满智慧的话，它可以指导我们不断超越自己。</p>
<p>给大家分享一个我自己的小故事，就发生在昨天，我被这个现实世界一只看不见的手，狠狠的教育了一巴掌。我突然意识到，原来我一直都不会做事情。具体怎么被教育的，我就不说了，反正每个人一生总会有那么几个时刻，感觉自己内裤被现实他老人家扒掉了。</p>
<p>我相信很多人和我一样，你们觉得自己会写代码、会写文章、会做PPT、会录短视频，等等，这些就是会做事情吗？不是的，这些仅仅表示我们做为一个螺丝钉，在这个社会上是有使用价值的；但是我们无法在“做事情”的前面加上“独立”二字。也就是说，我们只是现实社会中一个“零件”，而并非“大脑”。</p>
<p>昨天我就被这样的一件事情给教育了。原来我有一些观念，这些观念主要来自一些媒体或书本。但其实它们不是真的（或者说不是100%真的），但我却以为它们是真的，并且一直指导我这样去实践，但现实却一直没有给我的努力颁发奖项。连勤劳奖都没有，现实他老人家从来不颁发这个奖。</p>
<p>其实现实早已经给我打了分，“No，Baby，这是不对的”。而我还一直认为“这就是对的，只是因为我的努力还不够”。这就是固执，有时候固执和坚韧没有区别。内省一定要注意这一点，如果现实一直说No，我们就要反思是不是自己错了。</p>
<p>所以有时候，我们最大的囚笼，禁锢我们思想，和阻碍我们前进的，是我们脑海中的，那些自以为已知的观念和知识。</p>
<p>所以读到现在你明白我的意思了吧？为什么我说“Stay hungry，Stay foolish”这句话非常智慧。如果我们不当自己是傻子，那么现实就会把我们当傻子，那样我们才成了真傻子。</p>
<p>只有我们自己是foolish状态的时候，我们才有可能发现自己被自己禁锢了，我们才有可能不断突破昨天的自己。这是内省复盘最大的作用。</p>
<p>这应该是我几年来最大的一个感悟了。Stay hungry，Stay foolish！信仰它，不是因为它来自某位名人，而仅仅是因为它内含乾坤。并且这种智慧不是说出来的，而是需要靠悟靠实践，不断积累的。悟到，只是一个起点，它是一生的修行。</p>
<p>苏格拉底说，未经省察的人生没有意义，陷我们于无知的，恰是我们的已知。与君共勉。</p>
<p>最后提一句，没有人知道我为啥放这个计算器画面在这里，只有我自己知道。还有，以前我就发现在部落写长文字键盘会上下跳跃，很不舒服。今天就发现了一个小技巧可以解决这个问题，就是在下面多打几行空白。</p>
<p>幸好我是搞技术的，我知道这个方法只是歪打正着。这就像我们的人生，有时候我们得到了一点现实他老人家奖励的糖果，就以为我们活到了人生的真谛，其实不是的。可能只是凑巧他老人家心情高兴而已，我们千万不要将这些偶然所得奉为圭臬，而成为我们前进道路上的脚镣。</p>
<p>包括以上所有文字以及“Stay hungry，Stay foolish”，都应作如是观。</p>
<p>2021年3月17日</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[在生产中寻找艺术痛点]]></title>
            <link>https://yishulun.com/./src/posts/2021/8.html</link>
            <guid>https://yishulun.com/./src/posts/2021/8.html</guid>
            <pubDate>Mon, 01 Mar 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>在生产中寻找艺术痛点</h1>
<p>文艺要从生产中来，而不能凭空捏造。</p>
<p>这个想法是在听樊登读书时产生的（当时樊登在讲《论语》），但这个想法与其没有关系。我在想，像脱口秀大会、吐槽大会这样的综艺节目，它们的笑点其实都来源于生活。它们有多好笑，就说明这个世界有多荒唐。</p>
<p>所以，文艺创作，包括技术科普，从哪里寻找传播的点呢，必须从生活中、从生产中。但是这个寻找又不能因为要寻找而失了本心，还必须有一个”本心“的坚持。</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[如何管理好时间]]></title>
            <link>https://yishulun.com/./src/posts/2021/24.html</link>
            <guid>https://yishulun.com/./src/posts/2021/24.html</guid>
            <pubDate>Wed, 20 Jan 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>如何管理好时间</h1>
<p>首先亮出我的观点：意志力不是坚持做事的因，而是我们拥有良好自控力之后的一种体现。只有把自己当作一个对象作管理的时候，才可能真正管理好时间。</p>
<!-- more -->
<p>在你工作的时候，尤其是做自由工作、无人监督的时候，你是不是时常拖延？有时候还戏称自己有严重的拖延症？仿佛这么自嘲一下，病状就会消失，心里压力就会减少似的。</p>
<p>当松弛了一段时间，看到某一段励志视频，或某篇鸡汤文，或想到某段往事，或见到某个人听了什么励志演讲之后，又热血沸腾、干劲十足了。但过不了三五天，又开始自嘲自怨自艾了。周而复始，三天打鱼两天晒网，间歇性踌躇满志，经常性歇火重整。尤其在家办公的能人志士，对此体会可能更为强烈。</p>
<p>而我们如果在公司做事，身处一个集中式办公环境中，周围有同事兄弟，效率反而比一个人在家办公效率要高，尽管有时候这工作可能并不是我们真正想做的，而只是一份糊口的差事而已，效率也比一个人独立行事高，这又是为什么呢？</p>
<p>上述症状我基本都有，也因此感到苦恼。我查阅了一下相关的书籍、文章和评论，发现这是一个普遍性问题，并且是成功人士区别于普通人的一个很重要的指标。</p>
<p>那些历史上有成就的人，成就一番事业，或开辟新天地的人，或者发现新理论的科学巨擘，无一不是意志力坚持的人、自律的人。但是经过研究发现，这些人拥有超出常人的自制力，并非是他们成功的“因”，而是他们行动中体现的“果”。他们并非因拥有那样的自制力而获得成功，而是他们身上有一些其它的东西，这些东西在驱使他们操持前进，而“自律、自制力强”仅是在他们身上表现出来一个外象。</p>
<p>这篇文章就是想和你探讨一下，那些驱动成功人士持续努力的内因是什么。</p>
<p>自律，本质上是管理自己的每天24小时时间。而要管理好自己，就必须把自己当作一个对象来管理，管理之前还要先分析这个对象的运行特征和规律。甚至要把人当作动物那样去对待，因为人本质上人是一种高级智慧动物。只是比普通动物更智慧罢了，但某些方面仍然摆脱不了动物基因的控制。在人的身上有98%的基因和黑猩猩是相同的，只有2%的基因是不同的。按照唯物主义的观点，基因决定生物的生命特征和生活特点，只有2%的差异，人何德何能，能相去黑猩猩多远呢？</p>
<h2>一、了解人这个时间管理对象的客观规律</h2>
<p>接下来我们历数一下，在人的身上有哪些特征和规律是和自律相关的，哪些会影响我们管理时间。</p>
<h3>1.1，蜥蜴脑</h3>
<p>《蜥蜴脑法则》这本书提到，在我们每个人体内，在理智的大脑之下，都有一个原始的蜥蜴脑存在。这个蜥蜴脑总想贪图享乐，好逸恶劳。当我们工作了一段时间以后，它会说，“休息一下吧，已经工作很长时间了，总该休息一下啦”。</p>
<p>人的自制力在长期自律行动中加强的过程，就是不断和自己的这个蜥蜴脑作斗争的过程。但战胜这个原始的蜥蜴脑，靠的并不是口号，和坚定的意志（在开始的时候人是还没有坚定意志的），靠的是智慧，具体技巧后面会讲到。</p>
<h3>1.2，睡眠与食物</h3>
<p>人需要吃饭睡眠，这是由人的基因决定的，谁也改变不了。</p>
<p>人本身并不能像小草大树一样通过光合作用生产养分给养自身。人除了需要定期进食以外，还需要充足的睡眠。据有关研究发现，当人处于饥饿状态下，血液中的血糖过低，自控力会大大降低。</p>
<p>有人减肥喜欢节食，但往往节食又容易失败。减肥需要一定的意志力控制，但节食后血糖降低，自控力下降。饿得头晕眼花的时候，这时候蜥蜴脑就出来了，“工作这么辛苦，学习这么累，该吃就吃点吧”。结果节省减肥，反而更容易暴饮暴食。</p>
<h3>1.3，二十英里法则</h3>
<p>这个法则是著名的心理学家吉姆 · 柯林斯提出的。美国西海岸圣地亚哥距离某地3000英里。柯林斯发现，徒步前往该地的游客有三种人：</p>
<ol>
<li>
<p>第一类人在天气好、路况佳的时候就全速行军，天气差的时候就躲进帐篷里睡觉、抱怨。</p>
</li>
<li>
<p>第二类人不太会受天气、环境以及周围人的影响，无论什么天气都能出发。但他们没有常性，开始的时候每天能前进40~50英里，后期就慢慢懈怠了下来。</p>
</li>
<li>
<p>第三人是不管什么天气，环境路况如何，别人怎么样，每天雷打不动行进20英里，并且只行进20英里。</p>
</li>
</ol>
<p>那么问题来了，哪类人会最先到达终点呢？柯林斯说，答案是第三类人。这就是二十英里法则。走的最远的，并不是走的最快的。意志在量使用之后人会觉得意志疲劳，只有那些不靠意志力行进的人，才能坚持更久。如果行路做事就像每日三餐一样，平淡而自然，还需要什么意志力控制呢？</p>
<h3>1.4，人在环境下的自然条件反射</h3>
<p>很少有人会在肯德基、麦当劳，或星巴克这样的窗几明净的地方吐痰，为什么呢？即使一个不那么爱干净的人，到了这样的环境，也自然而然会抑制自己吐痰的冲动。</p>
<p>还有，一个性格不怎么沉静的人，到了图书馆，大家都在看书，他是不好意思大声喧哗的。而在闹哄哄的公交或地铁上，人却可以肆无忌惮地大声打电话或聊天。这又是为什么？</p>
<p>那些餐厅的服务员，为什么在一天里总是不停里扫地、拖地、收餐盘？</p>
<p>还有，同时在公司上过班并尝试过自由职业的人，可能都会明白，在家里是无法办公的。在家里办公，效率总是很低；而在公司里，在一个集中式的办公环境里，虽然有很多杂事打扰，但效率在多数情况下对大多数人来讲，反而更高，为什么？</p>
<p>这一切都缘于这小节的标题。人既是社会关系的总和，也是特定环境下的综合生命体。就像变色龙会随着环境改变体色一样，人虽然不会变色，但心里状态会随着环境发生变化。在这里主要有两个方面的考查因素：</p>
<ol>
<li>环境反馈</li>
<li>承诺一致原则</li>
</ol>
<p>先说第一点，<strong>环境反馈</strong>。如果环境能给人及时反馈，或者人能预知到这种及时反馈，这时候人的言行就会受到影响，蜥蜴脑就到得到一定的抑制。举个例子，还拿在星巴克吐痰来说，周围都是人，大家都显得彬彬有礼、很有教养，如果你豪爽地在地上吐了一口，大家将怎么看你？不了解的读者，可以前往星巴克实践一下。</p>
<p>有鸡汤总是说，人活着不要太在意他人的目光。但很多时候，城市文明的自觉就是靠这种“在意”、“要面子”维持的。</p>
<p>再说第二点，<strong>承诺一致原则</strong>。人总是希望自己在别人眼里是一个一言九鼎、说数算数的人。当一个人向别人公开做出承诺的时候，他就倾向于让言行与承诺保持一致。承诺的形式是多种多样的，举几个例子：</p>
<ul>
<li>罗辑思维的罗胖发愿做20年的《时间的朋友》演讲，还有每天录一段60秒的语音，这是公开承诺。</li>
<li>你在公司，当你和HR签订人事合同的时候，也是在做出承诺。承诺自己会按时上下班，会努力遵守公司规章制度，会尽力把工作做好。而如果你做不好这些，你心里很明白，公司会给你“扣奖金、批评、甚至炒鱿鱼”等等类似的负面反馈。</li>
<li>你在某次电梯间和同事聊天时，表达了对同事迟到的不屑；你在某次团队例会或年会上，夸口说过自己从来不请病例，常年都不迟到，而当你某次真正要迟到正全力往公司赶时，你的内心是非常紧张的。当时旁边没有人监督你，甚至公司也没有严格的打卡制度，或许没有人会知道你迟到了，但你内心还是会莫名的紧张。但如果你是在家办公，你自己规定了每天9点开始工作，但往往过了9点半，你都不会感到有一丝不安。</li>
</ul>
<p>大概就以上四点吧，这四点特征规律适用于所有人，不论是凡夫俗人，还是旷世伟人，都受这些客观规律的支配。接下来我们探讨一下，如果基于对这些规律的认知，做好时间的管理。</p>
<h2>二、分享两个与时间管理、意志力相关的TED视频</h2>
<p>在抛出正式的技巧之前，为了增加说服力，再分享两个TED视频。这两个视频都是与时间管理，与自控力相关的。</p>
<h3>2.1，第一个视频：如何掌控自己的时间？</h3>
<p><img src="https://gitee.com/rxyk/my-images/raw/master/2020/20210120110953.png" alt="image-20210120104709357"></p>
<blockquote>
<p>视频链接见：<a href="https://video.zhihu.com/video/1045382423000481792?autoplay=false&amp;useMSE=">https://video.zhihu.com/video/1045382423000481792?autoplay=false&amp;useMSE=</a></p>
</blockquote>
<p>这条视频给我带来两点启示：</p>
<ol>
<li>第一点，人必要要做自己真正想做的事。这条原则并不是因为逻辑上人应该这样做，而是没有办法，人只有在做自己内心真正想做的事情时，内心才不会抵触，才能持续不断地迸发热情。换句话说，只有在做自己真心想做的事情时，那个蜥蜴脑才不会时不时的出来捣乱，才有可能被压制。否则，人就会觉得浪费时间。</li>
</ol>
<p>多数人很多时候都不是在做自己喜欢的事，都是在做父母想让做的事，在做领导让做的事，在做为了生存、为了赚取生活资料而不得不做的事。80%的打工人，都是在做着自己并不喜欢的工作，一个突出的表现就是，一到下班时间他们就归心似箭了。家才是他们真正想一起呆着的地方，而公司就像牢笼一样。这也是聪明或者说狡诈的HRP，为什么要在牢笼里营造家的氛围的原因。</p>
<ol start="2">
<li>第二点，人要面对未来做展望。我们在某个时间点想取得什么成就，想遇见什么事情，想成为别人心目中什么样的人，要做这样的未来展望。每当我们懈怠的时候，但凡这样一想，动力立马又恢复了。</li>
</ol>
<h3>2.2，第二条视频：成功的要诀是意志力</h3>
<p><img src="https://gitee.com/rxyk/my-images/raw/master/2020/20210120105755.png" alt="image-20210120105755068"></p>
<blockquote>
<p>视频链接见：<a href="https://www.zhihu.com/question/27484486/answer/530051653">https://www.zhihu.com/question/27484486/answer/530051653</a></p>
</blockquote>
<p>这条视频也给我两点启示：</p>
<ol>
<li>
<p>第一点，人的成功主要不取决于智商，甚至也不取决于情商。大多数差异源于人的意志力不同。那些有大成就的人，都具有非凡的专注力，他们可以数小时、甚至一整天坚持做某件事，而感觉不到饥饿。他们可以数年如一日坚持向某个目标迈进，并持续保持初心和热情。</p>
</li>
<li>
<p>第二点，人的意志力并不是一成不变的。或许由于基因差异，不同孩子天生的专注力有所不同。但由于家庭环境、学校环境、社会环境、成长经历的不同，意志力在后天培养中也会有很大、甚至决定性的改变。</p>
<p>这是成长型思维，就是说，人的成功很大一部分取决于专注力。而专注力这种东西，不是口号喊出来的，更不是喝鸡汤喝出来的，而是通过行动，长期培养出来的。</p>
</li>
</ol>
<p>现在答案基本已经很明确了，成功不是高智商、高情商人的专利，如我等天资愚钝的人，通过持续不断的，有意识的，对意志力的培养，并通过意志力长期坚持做好自己内心真正想做的事，和时间做朋友，也是可能获得成功的。</p>
<h2>三、管理时间的具体技巧</h2>
<p>接下来我们就谈一下具体的培养意志力、管理时间方面的实用技巧。这些技巧并非我的发明创造，它们来源于我看的书、文章和评论，我只是做一个总结。</p>
<h3>3.1，使用SMART原则</h3>
<p><img src="https://gitee.com/rxyk/my-images/raw/master/2020/20210120111311.png" alt="image-20210120111311242"></p>
<blockquote>
<p>图引自第一链接</p>
</blockquote>
<p>当我们展望未来，在三秒钟就确立了一个伟大目录后，这个时候的目标往往都是无法执行的。盲目地执行一个看起来很遥远的目标，开始时可能斗志高扬，过了两三天可能就沦为了蜥蜴脑的奴隶了。这就是“失败的人常立志”。</p>
<p>解决这样的困境，在于将大目标成功地拆分为小目标。一个公司好的领导，最重要的能力就是拆分任务的能力，将一个大任务拆分为一个个可以执行的小任务。任务拆分的好，项目已经成功了一半。</p>
<p>如何拆分目标？这方面前人已经总结出来了实用的技巧，就是SMART。</p>
<ul>
<li>
<p>S是Specific[spəˈsɪfɪk]，代表明确。目标是不是明确的，可以直接想一下这个目标机器能不能判定是否完成。如果机器都能判定，那目标才是明确的。举个例子，客服部门要“提高客户满意率，让客户对我们的工作达到基本满意”，这个目标就不明确。但如果修改为“提高客户满意率，让定单投诉率降到0.1%及以下”，这个目标机器就能判定，就是明确的目标了。</p>
</li>
<li>
<p>M是Measurable[ˈmeʒərəbl]，代表可测量。这就是在实现目录的过程中，我们的工作量能不能被客观地统计和计算，而不是凭主观臆断工作完成的怎么样了。举个例子，还是上面的“提高客户满意率，让定单投诉率降到0.1%及以下”，这个目标就是可测量的。系统数据库里有定单总数，有时间，有投诉次数，一算就知道是多少了。</p>
</li>
<li>
<p>A是Attainable[əˈteɪnəbl]，代表可达到。这一点的判定有点难度，一般我们基于三点去判定。一，我们做的这件事别人有没有做成过；二，我们执行这个任务的人有没有相关经验；三，如果前两条都不具备，就要从逻辑上分析，拿出像“第一颗原子弹发射弹舱在被压扁的情况下还能不能成功引爆的具体计算数据“出来。用事实和数据说话，是判断的基本原则，而不是基于我们主观判断。</p>
</li>
<li>
<p>R是Relevant[ˈreləvənt]，代表相关性。这是在对目录做价值判断，假如这个目标完成了，对我们的目标有几分加成。一个显而易见的基本原则是，我们要优先完成那些对总目标加成最大的目标。</p>
</li>
<li>
<p>T是Time-bound[taɪm baʊnd]，代表时限性。在什么时间内完成，以什么样的频率去做某件事。这个要求对目标制定的重要性也是显而易见的，子任务不能容忍无休止地执行下去。即使做到了符合SMART原则的拆分，任务也不一定总是能执行完成的。在某个子目标完成不了的情况下，我们还可以根据经验及时调整方案或实现路径，因此时限是必不可少的。</p>
</li>
</ul>
<p>很多项目经理在划定任务时，喜欢让工程师自己说出任务的deadline时间。这种做法其实是不太负责任的。工程师如果比较自信或自负，会给出一个相对乐观的时间，但多数情况下都会延时；工程师如果恰恰相反，缺少一点点英雄主义，就想着上班怎么摸鱼，给出的时间又相对宽松许多，这时候项目经理如果准了，就是对公司、对项目的不负责任。</p>
<p>一个较为合理的估时办法，是依据历史经验评估，依据同等能力的人的经验评估。做同样一件事，譬如写一篇2000字以上的公众号推文，昨天用了多久，历史上平均用了多久，这个时间可以参考。如果执行人没有做过，是第一次做，就参考同岗位，或同行业其它人的平均时间制定。万不可拍脑袋。在执行了几次以后，时间还可以根据依据情况调整，时间并不是一成不变的。</p>
<h3>3.2，做自己内心真正想做的事</h3>
<p>一个人能做自己真正内心想做的事，这是一种莫大的幸福。并不是每个人都有能力选择自己的人生道路。大多数人从跨进小学学校门槛的那一刻，就开始了人生长跑。一年一年学习，高考，毕业找工作，结婚生子，为子女操心工作，操办子女婚姻大事等等，大多数人都在“想做”和“该做”的事情中间纠结。</p>
<p>但就像第一条TED视频给我们的启示一样，我们只有做自己真正想做的事情时，我们只有先过上我们想过的生活，我们才真的不会觉得在浪费时间。</p>
<h3>3.3，将要做的事情项目化，立Flag，按部就班完成</h3>
<p>又到了年底了，很多人开始写年终总结，以及立新一年的Flag了。立Flag就是公开承诺，它和我们在公司里签订合同一样，对我们的自控力都会起到加持作用。但立了flag总是实现不了，又会极大伤害我们的自控力自信，狂喜的只有蜥蜴脑小人。</p>
<p>一种比较合理的做法是这样的，将要做的事情，当成项目去做，制定计划，并公开承诺。举个例子，譬如我去极客时间录课，基本上是每周录一次，每次录5节。这样坚持了半年时间，终于录完了179节课。我们自己做事情，尤其是自由职业者，也可以这样规划。给自己立一个项目，譬如录腾讯课堂的网课，要录多少期，大纲是什么先制定出来，然后每次录课的时候，就是一个纯粹执行的过程了。</p>
<p>再举个例子，写网文小说也是一样的道理。先把大纲码出来，根据大纲再把情节脉路码出来。最后就是根据情节，每天坚持填满4000字或8000字就可以了。当然了，码大纲也不是一件容易的事情，闷在屋里瞎想一般也想不出来，具体也有技巧和办法，这里就不展开了。</p>
<p>做自由职业，尤其要和读者一同成长。有一种说法是这样的，<strong>并不是我们从逻辑上应该和读者一起成长，而是我们必须这样做、只能这样做</strong>。因为只有这样做，我们才能及时得到读者的反馈，才能更长久地坚持下去。譬如罗胖每天60秒语音这个项目，他如果先坚持自己录30年，等30年后再将音频放出来，这个事多半就完成不了。而录完一节，就放出来一节，读者马上就能看到就能评论，罗胖马上就能得到反馈，这样才能走得更远。</p>
<h3>3.4，搞一些形式，记录自己的汗水</h3>
<p><img src="https://yishulun.com/post-images/1611125365876.png" alt=""></p>
<blockquote>
<p>图引自第一链接</p>
</blockquote>
<p>这样的一个绿色马赛克截图，可能不是程序员就不理解。这是仓库代码提交统计图。绿色越多、越深，代表作者越勤奋。当我们看到这样的统计图时，大多数情况都想发一下朋友圈。多数时候我都喜欢给这样的朋友圈消息点赞，因为我明白朋友此时希望得到反馈，而我的点赞，只是举手之劳，就可能让他坚持下去。我知道，凡是经常发朋友圈秀某项内容的人，多半并不是因为TA拥有，而恰恰是因为TA想继续坚持。</p>
<p>这里还有一些小技巧，譬如在自媒体创作方面，如果写了原创文章，可以在篇首挂上“本文乃本号第xxx篇原创”。如果写的是某个系列的文章，可以挂上“本文系某系列第几篇内容”，等等这些都是一些创建形式价值的小技巧。</p>
<p>软件的设计者应多考虑一些创作者这方面的心理诉求，特别是当软件想让用户做的事是和学习、工作一样是反人性的时候。</p>
<h3>3.5，展望未来，在周五下午做下周计划</h3>
<p>第一条TED视频给了我们一个具体的制定计划的建议，周五下午做下周计划。或许我们应该在年、月、周这样的时间末尾，做下一段时间的未来展望，想一想在接下来的这段时间里，我们想得到什么，不想失去什么，这样我们的目标和计划自然就出来了。按照从年、到月、到周这样的次序展望，有利于我们将大目标划分为切实可行的小目标。</p>
<h3>3.6，在特定的环境下培养良好的作息习惯</h3>
<p>如果是在家办公，最好有一个自己的书房。每天早上9点钟，准时给自己沏一杯茶，或冲一杯咖啡，开始一个上午的工作。中午也要像公司那样按时吃饭。低血糖并不利于自控力的保持。还有作息，按时睡觉，保证充足睡眠也至关重要。</p>
<p>对于不坐班的人，坚持早睡早起是一项挑战，这和上班的人周未早起是一样困难的。这方面我没有查到好办法。但如果总体上事情进展比较顺利，自控力得到增加，晚睡随着时间推进也是可以克服的。人一天的时间只有那么多，早晨很早就开始工作，白天不安排过多时间休息，加上项目进展顺利，意志力加强，晚上自然就能早睡。多数人晚睡不是因为娱乐，而是因为焦虑，就好像今天睡下去，明天就不会醒来一样。</p>
<h3>3.7，备好自己的激励之物</h3>
<p>人是一种高级动物，受基因的控制和支配，蜥蜴脑又好逸恶劳，但我们还有另外一个理智的上层精神脑，会受到美好的有希望的事物的鼓励。我们可以准备一些专门激励自己的内容，放在我们经常可以看到的地方，可以是一句话、一张图、一张照片，还是一个视频，一个电影。</p>
<p>当你懈怠的时候，当你因为懈怠又悔恨自己不自律的时候，不妨看一看这些内容。越王勾贱，正是三年卧薪尝胆，使用这招不断激励自己，最终复仇打败了吴国。</p>
<p><img src="https://yishulun.com/post-images/1611125210962.jpeg" alt=""></p>
<blockquote>
<p>TVP IPLUSO</p>
</blockquote>
<p>每个人经历不同，所以可以激励自己的事物也是不同的。这事情，可以是别人送的一支钢笔，或者只是一句话，一段回忆。例如，对我来讲，我每天写字就用TVP组织送的钢笔，那是一支群友戏言将来签百万合同的专用钢笔。每当看见它，我就想起绝不能辜负年华时光，一定要有所作为。</p>
<p><img src="https://gitee.com/rxyk/my-images/raw/master/2020/20210120143655.png" alt=""></p>
<blockquote>
<p>腾讯QQ音乐出道链接：<a href="https://y.qq.com/n/yqq/mv/v/s00359gyycg.html">https://y.qq.com/n/yqq/mv/v/s00359gyycg.html</a></p>
</blockquote>
<p>还有《未来可见》歌曲也是，歌词写的很好，写出了技术人的心声。反思诸己，要努力对得住这份承定和荣耀。</p>
<p>还有我填写的诗词《声声慢·记 LeaTech 全球 CTO 领导力峰会暨 TVP 二周年庆典》，“待东风与便，再造辉煌”。如果不努力，怎么创造辉煌？</p>
<p>回想我高中化学老师有一天在我的作业本里夹了一个纸条：“你有清晰的逻辑和聪明的头脑，你缺乏的是持之以恒的坚持”。我永远都忘不了这位老师了。他给我的鼓励，犹如黑夜海上的灯塔，驱散了一个学生心中的自卑。在我工作后当了老师，我从来也不吝啬抓住一切时机，给予学生真诚的赞美。</p>
<p>在格式上，小视频、电影也可以。印度有一个神片叫《三傻大闹宝莱坞》，我每次重看都倍受鼓舞。还有王霙主演的《井冈山》，每次重看都被革命先烈实事求是的精神再次感染。</p>
<p>不仅正向的事物可以激励，反向的也可以，每个人都可以准备一些，放在自己经常可以看得见的地方。不仅在意志消沉的时候看，在平时就要保持它们不离开自己的视线，防患于未然。</p>
<h3>3.8，劳逸结合</h3>
<p>列宁说，不会休息的人就不会工作。长时间使用自制力，精神会疲劳，下一次再遇到同样的事情时，蜥蜴脑就会促使自己向容易的方向决策。保持充足的睡眠、全面的营养，有助于保持旺盛的精力和稳定的自控力。一线大厂互联网公司都喜欢把员工食堂搞得有声有色，这是因为食物成本现在变得相对低廉了，人力成本反而是最高的。保证员工的营养，总体上是有助于员工产出的。</p>
<p>最后和你分享一下我看到的一段话，有人说一个努力和成功的人是这个样子：</p>
<p><strong>他们在集中心智工作和学习的时候，几乎可以忽略全世界，全身心投入。更可怕的是，只要需要，他们可以一天十几个小时持续如此，经年累月，从不懈怠。他们经过长期的言行实践，在他们身上体现出一般人没有的高贵品质，专注。</strong></p>
<p>欢迎留言。实践是检验真理的唯一标准，欢迎就以上时间管理技巧讨论。</p>
<p>2021年1月20日</p>
<p><strong>参考链接</strong></p>
<ul>
<li><a href="https://www.zhihu.com/question/27484486/answer/530051653">https://www.zhihu.com/question/27484486/answer/530051653</a></li>
<li><a href="https://jingyan.baidu.com/article/5552ef47b2ee7a518efbc958.html">https://jingyan.baidu.com/article/5552ef47b2ee7a518efbc958.html</a></li>
<li><a href="https://www.zhihu.com/question/27484486/answer/941818438">https://www.zhihu.com/question/27484486/answer/941818438</a></li>
<li><a href="https://www.zhihu.com/question/27484486/answer/530871841">https://www.zhihu.com/question/27484486/answer/530871841</a></li>
</ul>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[如何使用开源协议？]]></title>
            <link>https://yishulun.com/./src/posts/2021/25.html</link>
            <guid>https://yishulun.com/./src/posts/2021/25.html</guid>
            <pubDate>Sun, 17 Jan 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>如何使用开源协议？</h1>
<p>今天群内发生了一件事，某大厂工程师使用了一个开源软件，但是并没有遵守开源协议。开源项目的开发者找上门来了，工程师解释说，因为只使用了一部分，系统中还有其它代码，所以没有公开声明。</p>
<!-- more -->
<p>我查了一下，在知乎上有人暴露过另外一则类似的事情。也是使用者没有公开声明，开发者找上门来，大厂负责人死不认帐，两人在IM软件上互喷。就是两人扯皮的时候，工程师还在加班修改变量，擦除抄袭证据。因为无法确认真假，就不在这里附链接了，感兴趣可以前往知乎搜索。</p>
<p>在中国程序员真是悲哀！写个收费软件吧，没有人付钱。写开源软件吧，别人抄袭你。就是大厂该有的雅量和气度有时候也没有，用了开源软件，不仅不公开致谢，还不认账。大概是因为利益出发点不同吧，同是程序员，厂外厂内竟是两种不同态度。</p>
<h2>开源协议</h2>
<p>接下来我们看看，当我们使用开源软件时，如何做一名有雅量和气度的人。全世界的开源协议大概有100多种，但常见和常用的并不多。使用哪种协议，看这张图就明白了：</p>
<p><img src="https://yishulun.com/post-images/1610984500543.jpeg" alt=""></p>
<p>图：引自 <a href="https://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html">https://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html</a></p>
<p>说明：</p>
<ul>
<li>在上图中，闭源指不再公开源码，变成使用者自己的软件。</li>
<li>在每一个修改过的文件，旋转版权说明。这指的是Apache协议，它要求“<strong>在延伸的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明</strong>”，具体做法一般就是在页面头部注释中包含。</li>
<li>关于对源码的修改之处，提供说明文档，一般做法是，拿一个专门的文件对源代码修改的时间和方式作统一描述。</li>
</ul>
<p>使用别人的开源软件时，我们先看一下它用的是什么协议。如果是MIT协议就好办了。<strong>最宽松的协议就是MIT协议</strong>，这种协议对使用者几乎没有任何限制，使用时只要保留版权声明和许可声明就可以了。</p>
<p>当开源自己的软件时，我一般选择的就是MIT协议。对于遵守规则的人，他自会遵守；对于不愿意遵守的人，即使是采用Mozilla许可证或GPL许可证，仍然是限制不了他的。</p>
<h2>CC协议</h2>
<p>开源协议是针对源码的，如果是文章，需要考虑使用创作共用协议（Creative Commons ），一般也称CC协议。</p>
<p>CC协议比较简单，主要有四项限制：</p>
<ul>
<li>1.署名（BY）：作品上必须附有原作者和出处</li>
<li>2.非商业性使用（NC）：不能用于商业目的</li>
<li>3.禁止演绎（ND）：不能修改，或二次创作</li>
<li>4.相同方式共享（SA）：使用同样的 CC 协议</li>
</ul>
<p>例如，本文版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>），这样就可以了。至于别人遵守不遵守，先抱着别人不遵守的打算去创作。</p>
<p>2021年1月18日</p>
<p>图片转自阮一峰的博客，见：<a href="https://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html">https://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html</a></p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[在极客时间录课的总结]]></title>
            <link>https://yishulun.com/./src/posts/2021/26.html</link>
            <guid>https://yishulun.com/./src/posts/2021/26.html</guid>
            <pubDate>Fri, 15 Jan 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>在极客时间录课的总结</h1>
<h2>（一）</h2>
<p>昨天晚上忙了2个小时，不对，确切地讲，是今天凌晨忙活了2个小时，终于将《微信小程序全栈开发实战》所有已发布的源码链接，都在评论区发布了。今天早上起来，我看到大约165条评论被纳为精选。</p>
<p>现在读者看到的源码链接，是这样的：</p>
<p><img src="https://static001.geekbang.org/infoq/90/90337b66449c315b07267902d4313cba.png" alt=""></p>
<!-- more -->
<p>每节课下面都有一个源码下载链接，如果想了解某节课对应的源码，直接从这个精选留言下载就可以了。</p>
<h3>自己制定的计划自己买单</h3>
<p>昨天从零点到凌晨1点半，我干到了97课，评了93节，我是从171课倒数往前评的。有点困，就想去睡觉，刚和衣躺下，一想不对。现在这个点正是程序员们学习的时候，想我20多岁的时候，不都是这个时间点披星戴月写代码吗？倘若有人此时学习，因为我未及时置评放链接而抓耳挠腮，我罪过不是大了。</p>
<p>于是我又爬起来，从凌晨1点半干到2点半，终于将所有课程的源码链接都评上去了。这样一来，每节课读者只要看一眼评论区第一条置顶的评论，就知道这节课对应的阶段是哪个，不必再去仓库里费心查找了。</p>
<h3>在源码管理上的经验总结</h3>
<p>如果你问我为什么对这件事这么上心，是因为源码没有贴上去吗？</p>
<p>不是。源码都在仓库里。因为我第一次录课，经验不足，在源码管理这件事上几番周折，走了不少弯路。</p>
<img src="https://static001.geekbang.org/infoq/63/63e3d1faab3c9f56fcf403b7d0c04287.png" style="zoom:50%;" />
<p>最早的时候在第2章，我用git.weixin.qq.com管理源码，这是微信团队整的git仓库。使用它每次下载源码都要扫码登录。就是下载一个源码，你让我登录干啥？github、gitee什么时候干过这事啊？</p>
<img src="https://static001.geekbang.org/infoq/93/93db6a03ac7a489baedc0782ad3bb0e2.png" style="zoom: 50%;" />
<p>体验很不友好。很快，第2章没录完，就就把源码切到了gitee上。开始了章节号码+标签说明+课程名称的时代。</p>
<img src="https://static001.geekbang.org/infoq/7f/7f60567d31edfc03312d09cfeb39b8af.png" style="zoom: 50%;" />
<p>这个时期录了十几课，后来考虑到在已发布课程的目录上，有3.1、4.2这样的章节编号，于是到了第3章，标签说明与课程说明我犯懒就去掉了。我心想，既然每节课都有编号，那直接读者带着课程编号找源码就好了。</p>
<p>但是事情不久就发生了变化，因为读者感觉3.1、4.2这样的章节编号混乱等原因，课程上只保留了一个从1开始开始统一编号和名称，不再有章节编号了。</p>
<img src="https://static001.geekbang.org/infoq/67/6787716a9e40b490a41e9d59bbf50284.png" style="zoom:33%;" />
<p>而我后知后觉意识到这个问题的时候，源码标签当时已经变成了这个样子：</p>
<p><img src="https://static001.geekbang.org/infoq/86/86d65d9714d3ba9a90aeb4282c22e5d3.png" alt=""></p>
<p>标签上什么都没有了，除了课程章节编号。这个章节编号在课程目录上还是不显示的。在这种情况下，读者怎么查找课程对应的源码呢？</p>
<p>所以，看到这个问题后我就睡不着觉了。有人可能会说，把源码标签修改一下，加上那个从1开始的序号数字不就可以了吗？</p>
<p>但是标签打上去就是历史了，是不能修改的。这也是使用标签的限制。还有人可能会质疑，为什么要让章节编号去掉呢？这个可以保留，但同时统一编号数字也应该保留，可能这样更好一点。但平台有平台统一的规范，所有课程只能用一个软件架构，不可能为某节课做定制功能的。所以这条路也是不通的。</p>
<p><img src="https://static001.geekbang.org/infoq/3d/3db871d88afc5a2910be1311576dc2bd.png" alt=""></p>
<p>再到后期，为了读者查找源码方便，也为我自己查找方便，我重新又严格要求自己，在打源码标签时，将对应的课程名称也打了上去。有了这个名称，即使章节编号对不上，依赖名称也能对上。</p>
<p>昨天晚上我自己过课，就是把课程自己听一遍，看看有没有问题，有什么需要改进的。能改进的点还是挺多的，最大的一点，我总觉得自己该减肥了。大脸把整个视频都盖上了，感觉学员看了都可能觉得我累。还有最重要的一点，就是源码。</p>
<p>我尝试做为一个读者，下载某节课对应的源码，从源码仓库链接点进去，切到tags标签下，150多个标签真让人眼光缭乱。基于上面我们已经聊到的原因，想依赖一个从1开始的10、30这样的统一数字编号，和一个课程标题名称，想从源码堆里翻出它的源码，真的不容易。</p>
<p>因为标签命名规则不统一，因为有的课程有源码标签、有的还没有，因为有的有标题描述、有的还没有，等等，想找一个源码真不容易。想到这里，所以我才睡不着了，即使已经很累了，1点半了又爬来了，把所有源码链接都评上去了。现在读者看到的源码链接，是这样的：</p>
<img src="https://static001.geekbang.org/infoq/90/90337b66449c315b07267902d4313cba.png" style="zoom: 67%;" />
<p>每节课下面都有一个源码下载链接，如果想了解某节课对应的源码，直接从这个精选留言下载就可以了。</p>
<h3>学习是一个不断自我否定的过程</h3>
<p>有人可能会讲，为什么每节课都要有一个源码链接呢？</p>
<p>这源于我自己的坚持。我觉得咱们人的学习，认识过程都是螺旋上升的，是像绕山公路一样盘旋而上的，并不是像电梯一样直入云霄的。基于这个认识，我认为在一个阶段，对应每节课，都应该有它的阶段性源码。</p>
<p>在《微信小程序全栈开发实战》这个课程里面，有明显的好几个地方是这样的：前面课程里面在讲另一个主题时，将一部分代码实现的并不完善，是有缺陷的，这个缺陷是在后面课程里面发现并完善起来的。我很高兴看到很多读者，纷纷在留言时留言，说某课某代码有问题，这说明他思考了，在真正的学习。</p>
<p>学习的过程，就是一个不断推翻旧认知、建立新认识的过程，这肯定是一个螺旋上升的过程，是一个包括了自我否定的过程。基于这一点考虑，所以课程里面的源码，一定要与课程对应，是阶段性的阶段。</p>
<p>并且我也鼓励读者在学习者，看当课对应的阶段源码，而不是git仓库里的最终源码。而当我发现，读者在学习时，不能很快找到阶段源码时，我就很着急了。</p>
<h3>一体化的Electron学习环境</h3>
<p>上面讲的是我在录课过程中，在源码管理方面犯的错误，接下来我想分享一下，如果我重头开始录课，我会如何管理源码。</p>
<p>可以使用分支，分支名称对应着从1开始的课程编号，在分支的仓库描述里面，直接放上课程名称。这样读者在学习的时候，基本只要用一个git指令就可以了：</p>
<p><code>git checkout $num</code></p>
<p>学习哪一课，就check哪一课的源码。这样多简单。</p>
<p>这样还有一个附加好处，分支是可以修改的，分支名称、分支描述都是可以修改的。即使课程编号有变化，也有补救的措施。不像源码标签，打了以后就不好修改了。打源码标签这种方式，适合大佬，非常有经验的大佬，十拿十稳的那种；像我等，适用使用分支。</p>
<p>此外，我还有一个“大胆”的想法。因为小程序与web都是在可以直接在页面上展示运行结果的，我们看一下微信的官方文档就知道了，我们可以将课程与源码，在网站上直接做一个对应，也就是说，我学到某课的时候，比如第100课，旁边自动就出来第100课的源码，并且直接就可以在线预览效果。如果读者愿意，还可以直接启动微信开发者工具，在本地进行修改。</p>
<p>怎么实现这个功能呢？做一个Electron客户端软件，既可以展示web页面，又能呼起本地软件，还跨平台，上面提供的功能大体都是可以实现的。这是一个立体的、一体化的学习环境。</p>
<p>唯一美中不足的是，Electron的编译简直就是一个噩梦，不然我真想业务找点时间写写这个软件。</p>
<p>欢迎留言。</p>
<p>（2021年01月15）</p>
<p>后记：</p>
<blockquote>
<p>昨天只算小忙。我有一次周未录课，因为那一周特别忙，白天一直给学生上课，根本没时间备课，周五晚上备课到第二天早上5点多，简单吃个早点，就打车去录音棚了。<br>
不是我不想休息，也不是我贪财，是责任，答应的事，对读者做出的承诺，就要尽力做。<br>
人都说老一辈人傻，有的人堵枪眼，有的人身体被火烧着了都一声不吭，有的人不怕疼用身体顶着炸药包炸桥梁。他们根本不是傻，是因为他们心里有信念，那信念像磐石一样不可动摇，为了维护信念，甚至不惜损害自己的健康，甚至牺牲生命。<br>
我当然没有达到这种高度，但是如果我在那个年代，我很有可能就是那样的人。<br>
包括疫情期间去武汉逆风支援的医生也是，我不是医生，我是医生我也会那样做。从这些年我干过的傻事来看，我肯定有这种傻劲。</p>
</blockquote>
<h2>（二）</h2>
<p>竭尽所能，这既不是一句口号，更不是感动自己的鸡汤。所有努力都必须是真实的，脚踏实地的努力，因为结局不会陪我们演戏。</p>
<p>昨天我听樊登讲《准备》，特别有感触。很少见樊老师将某本书讲了45分钟以上，这本书讲了78分钟。在讲解视频开始的时候，樊老师介绍说，美国教育工作者黛安娜·塔文纳的这本书有国内人大附中校长等校内教育大伽的推荐，听了之后，果然名符其实，非常值得推荐。这本书的内容很丰富，在此仅列举与本文有关的两点：</p>
<ul>
<li>竭尽所能</li>
<li>PBL</li>
</ul>
<h3>竭尽所能</h3>
<p>先说第一点，竭尽所能。塔文纳说：</p>
<p>竭尽所能不仅是一句口号，它是我们的文化，是我们做事的一种思维方式和行为准则，是驱动我们前进的力量。我们要始终坚信，总有办法打开一扇锁着的门。</p>
<p>因为她坚持不放弃任何一个孩子，有一次她为了让一个孩子回学校上学，拿到一把改锥跑到孩子家里要撬锁，“总有办法打开一扇锁着的门”就是从里来的。塔文纳自己童年非常不幸，有几次都差点被动辍学，她有这个坚定的信念，与她的童年不幸遭遇是分不开的。</p>
<p>竭尽所能是一种执念，是一种内心坚信必然如此的源动力。我在极客时间录课，是从每日一课开始的，当时小楠是我的责任编辑，负责和我对接。自从开始和小楠合作后，我发现我的内心就一直在受打击。为什么？</p>
<p>因为我的稿件递交上去，不行，打回来修改；修改了又递交上去，还不行，又打回来修改。前后我记得我和小楠在电话里沟通过数次，每次都至少有半个小时以上。做为一个出版过计算机图书，有十几年博客写作经验的作者，我感到的并不是生气，而是惭愧，因为每次修改的理由都很充分。</p>
<p>虽然一件事情站在不同角度，得出的结果是同的，甚至有可能是截然相反的评价。但在稿件修改和视频录制这件事上，我是新手，并且编辑代表的不是她个人，她代表是极客时间整个团队，她给我的建议是经过N多编辑实践之后得出的智慧。有些事我们不懂并不可怕，但如果我们不知道自己不懂更不怕。我们要感谢指出我们不足的人。所以，在改稿这件事上，我从来没有任何怨言。每次来活了，我都是挤出时间，尽快完成，马上完成，马上反馈。</p>
<p>我们今天有微信、邮箱等各种及时沟通工具，相比邮局时代，效率不知道快了多少倍。如果编辑和作者通过信封反馈与改稿，可能半年甚至一年才能完成这个过程。</p>
<p>我到现在还清楚地记得，在每日一课录制结束时，小楠送我下楼问我的一句话，她说：“老师，你的一丝不苟真的让人佩服！”</p>
<p>听到这样的肯定我有点不好意思。由于自己经验缺乏，让对方付出了更多的工作时间和精力，怎么好意思再得到赞美。我说：“我觉得做什么事情，要么不做，要做就要竭尽所能，把事情做好！”</p>
<p>其实小楠不知道，在录课这件事上我特别害怕失败，因为我失败过一次。大概在2018年，我受某个机构邀请，去一个录音棚录课。当时这个机构为了录这个课，租了一天的场地，花了不少钱。当时我没有经验，我以为我到了录音棚，打开电脑自然就能录好。结果那次我搞砸了。真真正正的搞砸了。录制这个事情，就像即兴演讲一样，真的是要准备的。</p>
<p>在极客时间录制《微信小程序全栈开发实战》的时候，计划是每周更新五节，因为开录后我的时间一直都很紧张，白天要在学校讲课，晚上还要备课，只能周末去叶青北园大厦录制。有一次周五晚上我记得很清楚，按计划第二天周六要录制了，我一点还没有备课呢！</p>
<p>怎么办？</p>
<p>所以那天晚上一宿没睡，第二天早上5点的时候把稿子发给了主编。因为我的拖延，编辑只有两个小时的审查、修改时间。</p>
<p>这就是竭尽所能，不做就不做，要做就做好。所以当我听樊登老师讲到塔文纳竭尽所能要让每个学生都考上大学时，我特别有感触。那是她的执念。</p>
<h3>什么是PBL？</h3>
<p>再说第二点，PBL。什么是PBL，它是Project-based learning的简写。这个词我也是听《准备》学来的。我原来没有听这本书之前，我写过一篇文章叫《关于知行合一的人工案例实践技术学习理论》，当时我还不知道PBL，如果我知道的话，我就不会大言不惭地涂这篇文章了。原来我想到的内容，这个世界上早有人想过并付诸实践了。读书很重要，这也是领读人的价值所在。</p>
<p>我在罗胖2020-2021跨年演讲中，听到了北京九渡河小学的案例。这个小学很成功，这个小学的学生不上课，上学就是学习磨豆腐、剪纸、制灯笼，这些都是一个个与身边生活结合紧密的实际项目。以磨豆腐为例，学生不仅要拜村里农民伯伯为师把豆腐学会，还要自己写宣传文案，把豆腐卖到村子里。老师则是负责把小学里的知识点，掰开了揉碎了，放在项目里。</p>
<p>九渡河小学的案例，与塔文纳的PBL理念大概是一个意思。</p>
<p>去年年底我去东北一汽大众企业做过短期的企业内训，既讲师，又带学员做项目。短短5天，学员既学习了新语言新技能，又将项目落地了。我回来以后，我自己都惊诧自己居然坚持下来了。有两点困难：一，我事先没有任何准备，现场了解需求现场开发，一边开发一边给学员讲解；二，学员是零基础或完全接近于零基础的，我不但要讲明白，而且更重要的时刻还要考虑学员是不是听明白了。压力特别大。</p>
<p>但是这种培训形式我特别认可，它是一种「软件定制+课程培训」的模式，既培训了学员，学以致用；又开发了项目，后续需求学员自己就可以维护了。我特别推崇这种模式。我觉得这就是PBL理念在程序员编程领域的具体实践。如果你这个需求，欢迎与我联系。</p>
<h3>致良知</h3>
<p>最后我想和你再聊一聊「致良知」。这个词语出自二个半完人之一王阳明。之前我对这个词语的理解有些偏差，我觉得良知指的是一种东西，是一种观念，或一种智慧。其实不是的，今天我听完《王阳明大传》三卷，我觉得这个词指的是一种状态，是人处于一种「良知」的状态，而「致良知」就是达到这样一种状态。这是什么状态呢？什么是「良知」状态呢？</p>
<p>其实这种状态每个人都有，或每个人都曾经有过。王阳明龙场悟道，有一天晚上突然从石头上跳起来，说「圣人处此，更有何道」。禅宗六祖慧能在悟道时说「何期自性，本自具足」。这两句话是一个意思，都指内心达到了一种「良知」的状态。而这种状态每个人生来都是具有的，只因后来我们因为欲望、因为执念蒙蔽了双眼，迷失了。而参悟，是消除世俗迷障的过程。</p>
<p>那么我们为什么要说致良知呢？这和本文有什么关系呢？</p>
<p>我们未致良知的时候，是为欲世迷眼、为执念迷路；而当我们致了良知的时候，我们便是竭尽所能。竭尽所能既是致良知的一种附加状态，也可以帮助我们致良知。良知这种状态，不是一旦致过就永远不变的；确实是需要「时时勤拂拭，勿使惹尘埃」的。</p>
<p>欢迎留言讨论。</p>
<p>（2021年02月09日）</p>
<h2>（三）</h2>
<p>曾几何时我也认为，课程录完了就万事大吉了，直到有一天我自己把课程看完了，看到最终的结课数字，我明白了：课程虽然录完了，服务才刚刚开始。</p>
<p>由于课程时长比一般课程要长，一般课程都是20~30个小时，这个《微信小程序全栈开发实战》竟然有48个小时。一个人不喝不吃不睡，也要两天两夜才能看完。再加上每个人有各自的工作、学习生活，学习时间并不是固定且充裕的，因此课程学习跨度长，往往学完后面的，前面的又忘掉了。</p>
<p>还有一点，就是由于我录课经验不足，我并未能将技术内容讲得像我预想的那样，具有脱口秀式的有趣特征（事实上谦虚地说，应该是一点没有），因此学习完这48个小时的内容，并不是一件轻松的事。再加上我们知道，人都是有惰性的，如果没有人督促，读者很难自律完成课程。</p>
<p>基于以上考虑，我决定在读者中发起一项活动。即日起，凡是完成课程，并主动在部落中晒出完课证书的读者，由我审核，赠送一本js零基础入门教材。图书封面是这样的：</p>
<img src="https://cdn.jsdelivr.net/gh/rixingyike/images/202120210316143815.png" alt="img" style="zoom:50%;" />
<p>这本书是完全面向零基础读者，适合新手学习。如果对这本书不感兴趣，可以商量换另一个我的《小程序从0到1：微信全栈开发工程师一本通》。</p>
<p>很多读者都没有完课，都没有见过结课证书，给大家看一下，结课证书是这样的：</p>
<img src="https://cdn.jsdelivr.net/gh/rixingyike/images/202120210316143630.png" alt="img" style="zoom:33%;" />
<p>活动要求是，需要你将自己的结课证书分享到极客时间的部落中，并艾特我知道。这一期活动数量有限，只有10本，先到先</p>
<p>发起这个活动，并不是单纯想促销，而是想帮助读者朋友们克服惰性，尽快结课。我甚至鼓励学习有进展的读者，在完全每一章，甚至每一课都可以在部落中分享一下自己进展；如果不好意思让别人看到，可以写在笔记里，私发给我其它任何一个朋友。</p>
<p>课程录完了，标志着服务刚刚开始。为了使读者们明确能得到具体什么样的服务内容，我将服务简单列举一下：</p>
<ol>
<li>所有购课学员，都可以<strong>免费使用我在课程中使用的企业开发者帐号</strong>。我们知道，只有企业开发者帐号，才可以体验Webview、Live直播、微信支付等这些功能。申请方法是私信我，告诉我微信，由我手动为你开通。注意每个帐号同时只能添加50个开发者帐号，所以前面申请的学员会优先被移除，拿到帐号要尽快学习。</li>
<li>所有购课学员，都可以<strong>免费使用我在课程中使用的小微商户帐号</strong>。申请一个小微商户并不像申请一个可以支付的企业帐号那样代价高，但也需要大约100块钱，这个价格已经比大部分读者的课单价都高了。小微商户申请略为麻烦，需要时间等等，如果仅是体验，不需要这么复杂，在课程源码中就可以看到我的小微商户帐号及密钥，可以直接测试使用。</li>
<li>可以随时在<strong>课程下方评论区提问互动</strong>。提问内容不限于本课课程中讲到的内容，但凡读者在学习过程中遇到的问题，有疑惑，都可以提问。有的读者腼腆一点，怕别人看到自己的提问，除了提问区提问，还可以与我联系，换一种相对私密的方式，都可以。</li>
<li>我准备做<strong>课程直播答疑</strong>。在一个固定的时间，例如晚上8~9点，每天拿出一个小时，读者在写代码的过程中，遇到什么调试不通的bug，都可以将代码上传到github上，将问题描述清楚，提交给我。所有读者将按照先后顺序，排队在直播间中解答。解答一个读者问题的时候，其它人也可以观看学习。我要挑战的是，读者遇到任何问题，我都能当场找出问题所在，并将之解决。当然我知道这个有难度，如果当时解决不了，下播后我研究一下，第二天再给出答案。具体在哪个平台直播，我还没有想好。可能在知乎。如果极客官方可以，我会优先选择极客时间。如果你有听直播的意见，请告诉我，等人数多了，我就着手开始。</li>
</ol>
<p>最后总结一下吧，线上技术网课培训，在我看来同线下是一样的，同样都是服务。区别在于，线下培训动辄学费就是3~5万起，而线上只需129元，线上价格更划算。有时间官方有活动做促销，最低可以降到19.9块钱。对我自己来讲，给每个线上学员像线下那样一对一辅导，这是不现实的；但我可以做到论坛区问答互动，及集中时间式单线程直播答疑。</p>
<p>我听闻国外SC课程的大学讲师，他们每周都有固定的线上、线下交流时间对外开放，在这些时间段学员可以找他们提问任何问题。我觉得这种模式非常好，有意在效仿他们；还有，我从塔文纳的《准备》这本书中学到PBL这个教育理念，我觉得它是最好的技能学习形式，编程语言包括在内。</p>
<p>单从收益来讲，这个课程并不值得我投入这么大的精力，提供上述四项服务，尤其是最后一项。但从我的志趣来讲，我希望将PBL这个理念在编程教育中发扬光大，同时也需要不断在实践中挑战自己用“有趣而不失严谨”的态度及方式传播技术内容，从这个意义上讲，我和我的读者都在修行，我的收获亦是满满。</p>
<p>最后声明一下，以上服务内容（除了提问区问答互动），特别是直播，并非官方承诺，有任何问题请联系我，客服小姐姐是不管这些事的。</p>
<p>欢迎留言讨论。</p>
<p>（2021年2月14日）</p>
<h2>（四）</h2>
<p>「持之以恒」看起来只是一句口号，因为我们都明白，做任何事情如果可以持之以恒的话，都可以成功。</p>
<p>难就难在一般人都难以持之以恒，而我们大多数人又都是普通人。不能坚持的原因，不一定就是意志和信念不坚定，可能还有客观上的原因，例如有本职工作要忙，遇到问题被卡住了很痛苦、无法继续等。</p>
<p>据教育心理学研究，我们人类在学习过程中，有两个困难：</p>
<ol>
<li>遇到困难无人解答、无法前进，这是外在的客观困难</li>
<li>不能得到及时反馈、热情难以为继，这里内在的主观困难</li>
</ol>
<h3>学习遇到困难怎么办？</h3>
<p>先说第一个问题，遇到困难了怎么办？问同学、问老师，讨论+请教就可以把困难拿下。因为这样的困难往往并不是真正的困难，有时候只是自己观念认知不到，眼睛被蒙蔽了，才没有看到解决方法。</p>
<p>具体到《<a href="https://time.geekbang.org/course/intro/100052401">微信小程序全栈开发实战</a>》这门课程，可以在课程的留言区问我；也可以把问题留下来，在我直播的代码直接把代码链接发给我，我在你的代码基础上查找问题，尝试将之解决。</p>
<p>为什么要提供第二种方法呢？因为有些问题就是工程实践性比较强的，读者难以描述，解答者也难以领会，代码最直接；此外，采用直播的方式，即惠及更多读者，又锻炼作者本人。</p>
<p>现场查找 Bug，解决疑难，这对作者来说是一个挑战，我想试一试。</p>
<h3>学习产生惰性是一种正常现象</h3>
<p>再说第二个问题，不能得到及时反馈怎么办。</p>
<p>现代教育心理学认为，学习是一个客观的过程，并不单纯是一个主观行为；教育工作者应该把学生产生惰性心理，看作是一种正常现象，而不应该简单归因于学生懒惰、不上进、意志不坚定等主观因素。</p>
<p>学习本来就是一件反人性的事情，如果不能得到及时反馈，学习者很容易迷失方向、丧失学习动力。所有编程初学者基本都有这样的困惑，下面是最近又接到的一位读者的提问，大意是这样的：</p>
<blockquote>
<p>学员没接触过编程，之前做的是编程以外的其它工作（与互联网或电脑有关，但不涉及编程），目前因工作需要，准备学习一下编程，学之前需要准备学习哪些内容呢？</p>
</blockquote>
<p>我的回答是：不要准备，在实践中学习，有问题就问。</p>
<p>从线下学校课堂的实践总结来看，从一门有及时反馈的、简单的、系统化的、相对独立的技术入门学习编程，会坚持得更久，更容易成功。这样的技术以前是 Flash，现在是微信小程序。</p>
<p>有人会说，对于新手来说，像计算机基础、数据结构、算法、设计模式等等，这些都需要准备。其实都可以先不准备。如果将这些东西都准备好了再去学习，学习的热情先被浇灭了。特别像算法这样的大部头，它的作用对新手来讲，要么扼杀学习热情，要么将学员推进培训机构。</p>
<p>这门《<a href="https://time.geekbang.org/course/intro/100052401">微信小程序全栈开发实战</a>》课程，因为当初定位在中级偏上程序员，所以对初级读者会有一些难度。但只要坚持把每节课作者敲过的代码都敲一遍，学过 179 节课，一定会大有收获。有时候有点困难，反而达成后更有成就感。</p>
<p>这门课最大的缺点就是我录的时间太长了，整整 48 小时，179 节课，比一般其它课程多了一倍。课程节数太多，需要长期坚持学习，这对学习者是一个挑战。如何坚持？就是上面我提到的，有问题就问+坚持在反馈中实践。</p>
<h3>具体反馈指什么呢？</h3>
<p>最后补充一下，上面提到的反馈指什么？</p>
<p>指我们能够看到的、听到的现实表象，例如在终端里敲一下指令，成功了，写一段新功能的代码，编译通过了等等，这些都是正向反馈。还有，同学学习遇到困难，找你请教或讨论，你帮他解决了，这种输出式巩固所学的副产品——来自同学的感谢，也是正向反馈。</p>
<p>编程大多数时间都是一个人做事情，微信小程序这门技术本身是相对独立的、语法简单的，更重要的是它还是个前端技术，它有丰富的表现力，一个按钮、一个图像、一段文本，这些都能给读者带来最直观的感受。而我们人类的大脑就需要这样接地气的反馈。如果学习一门语言，只能在终端里看到文本结果，有时候还只是黑白的，这会大大降低学员对反馈的满足感。</p>
<p>欢迎留言提问。</p>
<p>（2021年2月23日）</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[开课吧三次直播资料下载]]></title>
            <link>https://yishulun.com/./src/posts/2021/28.html</link>
            <guid>https://yishulun.com/./src/posts/2021/28.html</guid>
            <pubDate>Fri, 08 Jan 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>开课吧三次直播资料下载</h1>
<p>所有课件请在公众号「艺述论」回复数字100下载。三次直播的源码在课件里有，为方便读者，也列在下面：</p>
<ol>
<li><a href="https://github.com/rixingyike/wechat-operation-assistant">https://github.com/rixingyike/wechat-operation-assistant</a></li>
</ol>
<p>「2月23日」一个使用小微商户+微信聊天机器人构建的可付费私域运营助手</p>
<ol start="2">
<li><a href="https://github.com/rixingyike/cloud-markdown-editor">https://github.com/rixingyike/cloud-markdown-editor</a></li>
</ol>
<p>「3月6日」Markdown云编辑器主要实现的是一个以Markdown格式写作，保存在云端，同时在多个平台发布的功能。</p>
<ol start="3">
<li><a href="https://github.com/rixingyike/chrome-extension-assistant">https://github.com/rixingyike/chrome-extension-assistant</a></li>
</ol>
<p>「3月13日」一个浏览器插件助理</p>
<p>第二、三场直播的回放，请在开课吧官网-&gt;公开课-&gt;前端页面下，分别找3月6日和3月13日的链接。第一场关于私域运营机器人的直播，与官方确认，答案是这样的：</p>
<p>第一场直播是开课吧门徒计划的预热课，只有报了该计划的同学才能观看。并且门徒计划在网站上没有公开链接，它是一个社群式项目。目前如果想加入，可以咨询自己的销售顾问。</p>
<p>2021年3月16日</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[关于信念]]></title>
            <link>https://yishulun.com/./src/posts/2021/27.html</link>
            <guid>https://yishulun.com/./src/posts/2021/27.html</guid>
            <pubDate>Thu, 07 Jan 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>关于信念</h1>
<blockquote>
<p>“疯狂”那是别人的看法，在疯狂的人的眼里，只有“相信”</p>
</blockquote>
<p>以下内容是一觉醒来，早上不到五点钟爬起来写的。我一直觉得，人有时候在黑夜睡梦中思考的内容，比在白天正经的思考，更清醒、更有价值，接下来要说的便是。</p>
<!-- more -->
<p>程序，什么是程序？计算机按照一定指令和顺序，执行预先安排好的脚本，这就是程序。有人说电脑程序难，但程序是这个世界上最方便人类做培训的内容之一。为什么？</p>
<p>因为只要执行环境一致、输入条件一致，执行结果永远都是一样的。电脑就是一个傻瓜，人要它干什么它就干什么。</p>
<p>其它任何活动都不如程序这般诚实，艺术？艺术更不可能，同一个人、同一篇内容，两次创作，结果就不一样。小学我就听老师说过，天下第一行书《兰亭序》是王羲之在喝醉后写的，第二天酒醒后再写，已经写不出来了。</p>
<p>所以，程序是最方便做培训的内容，甚至没有之一。</p>
<p>在培训的时候，无论是录播还是直播，我们只要预先把环境准备好，把示例备好，演示的时候将代码拷贝进来执行，一般都不会有什么问题。就像预先挖好沟渠，将水引到渠里流淌一样，这是一个自然而然、水到渠成的过程。</p>
<p>在培训中，针对每节课要培训的主旨不同，还可以有针对性地安排不同的示例，将枝节略去，只保留关键内容，以此避免影响学员理解、避免他们建立主要的目标概念。</p>
<p>现在，我们换个角度，把我们人类自己当作程序中的代码，重新思考一下人类本身。</p>
<p>宇宙这么大，要么是我们目前观察手段不行，要么是被限制了，像鱼被限制在鱼缸里一样被限制了，不然的话，人类不太可能是唯一的智慧生命体。不然，人类在茫茫宇宙中就太孤独了。</p>
<p>爱因斯坦是一个决定论者，前天读他的传记，书中说他坚持人说什么话、做什么事其实都是由某种东西决定的，人在一定程度上是基因与所处环境的“奴隶”，言行并不是100%自由的。</p>
<p>如果将人的行为，与计算机世界程序的行为类比一下，不难想象，人类可能只是更高级文明编写的程序代码而已。</p>
<p>在我们的世界中，自然科学的火山喷发、地震、疫情疾病，还有社会学中的农民起义、战争、邦国外交等等，都是在一定“规律”支配之下的必然结果。</p>
<p>诚然，火山喷发的时候，岩浆在每个具体瞬间，有向左流淌或向右流淌的“自由”，但是它受重力影响及周围环境所限，必然向低洼处流淌，却是它不可更改的“宿命”。</p>
<p>如果一切皆有定数，那么是什么东西，在程序的必然之下，影响那些变化的内容的呢？</p>
<p>是信念，应该是信念。</p>
<p>马云当年创业，说他要创建一家存在102年的企业。阿里销售铁军放出去跑业务，一次次被厂家拒绝，被人放狗咬，没有关系，因为员工相信，阿里的企业服务费1万/年，绝对可以卖出去，厂家不卖，是他不识货；那些骂阿里是骗子的人，只是因为一叶障目，没有看到20年后的网商盛况。</p>
<p>这张图可能很多人都看过了。在阿里创业初期，马云在向“十八罗汉”做演讲。从马云的姿势和听众的眼神中，我们都不难想象，这个团队有着相同的信念。阿里的这个信念，是马云先生创建并给予团队的。</p>
<p>一时相信为信心，一直相信为信念。在团队中，维护信念的力量是意志。但因为人会思考，社会文明越进步，人越会思考，所以有时候我们在建立团队信念的时候，必须要使用思想来武装，要用科学的思想来武装。从武装这个意义上讲，2000多年前的《易经》和今天的《相对论》没有区别。</p>
<p>古之今来凡成大事者，信念都是必不可少的因素。当人多的时候，想把大多数人都团结起来，建立同一个信念，思想又是必不可少的。</p>
<p>宣传思想的方式有很多种，演讲是，办报纸杂志也是。蒋委员长40岁当选国民党中央委员，在此之前26岁就在日本创办了《军声杂志》。教员就更不用说了，26岁在湖南创办了《湘江评论》，后又有五卷遗世。</p>
<p>蒋委员长统辖国民党没有思想，他的思想便是国父孙中山的三民主义。但他有意志，他数十年坚持写日记，这中间的意志便可见一斑。若不是坚信自己能成熟一番千秋伟业，谁能数十年如一日坚持做一件事情。</p>
<p>教员是既有思想，又有意志。教员的意志在神州大地从来没有动摇过，在996和年轻人猝死风行的年代，“今日欢呼孙大圣，只缘妖雾又重来”。</p>
<p>思想有没有可能是错的？</p>
<p>有可能。限于当时环境和认知条件，团队在一定时期的思想可能是不完善的，甚至是错误的。但这没有关系，只要当时能够以此建立和维持团队的信念，就足够了。所谓思想，就是让大多数相信可以干好某件事的逻辑。思想不怕错误、不怕不完善，思想是可以进化的，但是信念不容缺失。</p>
<p>乔布斯当年在重返苹果时，花了1亿巨资做了一个广告，就是上面这个“Think different”。</p>
<p>这个广告既不卖产品，也不夸耀自己，乔布斯在干什么？疯了？</p>
<p>他在重建苹果团队的信念。“只有那些疯狂到认为自己可以改变世界的人，才真的可以改变世界”，这句话太著名，我们必须引用一下它的英文原文：</p>
<p>“the people who are crazy enough to think they can change the world are the ones who do.”</p>
<p>俄国十月革命的领导人列宁，他也是既有强大意志，又有完备思想的人。他的思想继承和发扬自马克思主义。他的意志，当他在拉兹里夫湖边一边当割草工人一边写作的时候就已经显现无遗了。</p>
<p>还有马克思，他数十年如一日研究、撰写《资本论》，大英博物馆的地面都被他磨出一道凹进的脚印，那是大地向他的意志臣服的谦逊。</p>
<p>所以，综上所述，如果有什么东西，是在程序的必然之下，是影响变化的关键因素，那么这个因素应该是信念。</p>
<p>信念是真的相信，不是阿谀奉承，也不是虛情假意，更不是机关敲诈。只有内心真正相信自己可以成事的人，才真的可以成事；只有真正团结起来，相信一定能够干成某件事的团队，他们才真的可以干成。</p>
<p>如果人类之上真有更高一等的文明，他们在编写我们的时候，或许早已将“信念”注入到了程序当中。那些拥有强大信念的人，那些拥有坚定团队信念的团队，山川亦为之动容，魔鬼亦为之改道。</p>
<p>或更有甚者，那些历史上降临世间创建丰功伟绩的人，只因来的时候携带了强大的信念，这种信念有时候被传记作家称之为扭曲现实的强大磁场。这种夸张的描述，我在《毛泽东传》和《乔布斯传》中都曾看到。</p>
<p>只有那些疯狂到认为自己可以改变世界的人，才真的可以改变世界。“疯狂”那是别人的看法，在疯狂的人的眼里，只有“相信”。</p>
<p>欢迎留言。</p>
<p>2021年1月7日</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[声声慢·记 LeaTech 全球 CTO 领导力峰会暨 TVP 二周年庆典]]></title>
            <link>https://yishulun.com/./src/posts/2020/02.html</link>
            <guid>https://yishulun.com/./src/posts/2020/02.html</guid>
            <pubDate>Thu, 10 Dec 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>声声慢·记 LeaTech 全球 CTO 领导力峰会暨 TVP 二周年庆典</h1>
<blockquote>
<p>声声慢·记 LeaTech 全球 CTO 领导力峰会暨 TVP 二周年庆典</p>
</blockquote>
<blockquote>
<p>12月4日、5日前往深圳参加了一个技术活动，5日晚上喝了点酒，第二天早上填了这首词。深圳有一种小吃叫三及第汤很不错，老板说汤里面清新的绿叶子是枸杞叶。还有，深圳人说普通话，问你要不要加肠，其实是问你要不要加汤。</p>
</blockquote>
<!-- more -->
<p>深圳滨海，东海朗廷，节气大雪行将。</p>
<p>大伽千里云聚，把盏共襄。</p>
<p>圆桌讨论犹记，有趣哉，不越篱墙。</p>
<p>带团队，无招胜有式，平展影响。</p>
<p>以技术创企业，连元素，协同驱动成长。</p>
<p>更有求败绝艺，计算车厢。</p>
<p>喜看他人日上，挥挥手，心莫忧伤。</p>
<p>立风口，待东风与便，再造辉煌。</p>
<p>2020年12月10日</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[小程序从0到1：豆瓣接口替代网址可以在线访问了]]></title>
            <link>https://yishulun.com/./src/posts/2020/01.html</link>
            <guid>https://yishulun.com/./src/posts/2020/01.html</guid>
            <pubDate>Wed, 01 Jan 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>小程序从0到1：豆瓣接口替代网址可以在线访问了</h1>
<p>《小程序从0到1》这本书即将再版印刷了，趁此机会，作者必将豆瓣服务器地址从示例中拿去，原因大家都清楚。前几日，为了方便读者朋友在本地学习与测试，作者用 Go 语言写了一个替代小工具，如下文章所述：</p>
<p><a href="http://mp.weixin.qq.com/s/-6UYVXvTwxlz5poybBFHUg">还一个技术债：豆瓣接口代替小工具</a></p>
<p>现在，这个小工具也不需要了。为了进一步方便读者，作者已经将该程序部署在了作者的服务器上。购买服务器可是花了不少银子。</p>
<p>使用方法：</p>
<pre><code class="language-bash">将小程序源码中的 https://api.douban.com/v2 替换为 https://api.rixingyike.com/doubanapiv2
</code></pre>
<p>具体的新旧接口对应关系为：</p>
<pre><code class="language-bash">// https://api.douban.com/v2/movie/coming_soon?start=0&amp;count=3
// https://api.rixingyike.com/doubanapiv2/movie/coming_soon?start=0&amp;count=3

// https://api.douban.com/v2/movie/search?q=${this.data.searchWords}&amp;start=${start}&amp;count=${this.data.size}
// https://api.rixingyike.com/doubanapiv2/movie/search?q=和平&amp;start=0&amp;count=10

// https://api.douban.com/v2/movie/${this.data.type}?start=${start}&amp;count= ${this.data.size}
// https://api.rixingyike.com/doubanapiv2/movie/in_theaters?start=0&amp;count=10

// https://api.douban.com/v2/movie/subject/${options.id}
// https://api.rixingyike.com/doubanapiv2/movie/subject/3267549

// https://api.douban.com/v2/movie/bang/${board.key}?start=0&amp;count=10
// https://api.rixingyike.com/doubanapiv2/movie/top250?start=0&amp;count=10
</code></pre>
<p>2020年1月1日</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[清平乐·贺TVP周年]]></title>
            <link>https://yishulun.com/./src/posts/2019/01.html</link>
            <guid>https://yishulun.com/./src/posts/2019/01.html</guid>
            <pubDate>Sun, 22 Dec 2019 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>清平乐·贺TVP周年</h1>
<blockquote>
<p>这是在腾讯云TVP一周年时填写的一首词。</p>
</blockquote>
<p><strong>清平乐·贺TVP周年</strong></p>
<p>腾讯云加，聚八方好汉。如战神般自由勇敢，不畏险阻艰难。</p>
<p>勇攀科技巅峰，谱写战绩云风。今日长剑在手，何惧四海青龙？</p>
<p><code>注：剑者，腾讯云也。青龙，上古四大神兽之首。</code></p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[小程序从0到1：MXML基础语法与错误信息]]></title>
            <link>https://yishulun.com/./src/posts/2018/05.html</link>
            <guid>https://yishulun.com/./src/posts/2018/05.html</guid>
            <pubDate>Fri, 26 Jan 2018 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>小程序从0到1：MXML基础语法与错误信息</h1>
<h2>1、理解标签与属性</h2>
<p>在MXML标签中，尖括号都是成对出现的。像这样：</p>
<pre><code>&lt;..&gt;...
</code></pre>
<p>尖括号中间是标签名，例如swiper、swiper-item、image等，这些都是标签名。</p>
<p>每个标签默认都有一些属性，属性名与属性值以符号“=”连接，属性值用双引号引住。如下所示：</p>
<p>​    <img src="./assets/22027.png" alt="0"></p>
<p>还有，属性与属性之间，要有空格。属性值开始处不需要空格。</p>
<p>​    <img src="./assets/22001.png" alt="0"></p>
<p>如上所示，属性名“wx:key”、“style”之前缺少空格。属性&quot;style&quot;的值，开始处并不需要空格。</p>
<h2>2、仔细阅读错误信息</h2>
<p>如果MXML有错误，微信开发者工具会弹出错误信息，要仔细阅读错误发生在第几行、第几个字符、错误信息是什么。例如：</p>
<p>​    <img src="./assets/21993.jpeg" alt="0"></p>
<p>该错误信息讲，第3行第9个字符，出现了一个不应该出现的“&lt;”字符。</p>
<p>依照错误信息，去代码检查错误，才能做到按图索骥，事半功倍。</p>
<h2>3、注意单词拼写</h2>
<p>如下所示，只因“swiper-item”错拼为“swiper-itrm”，程序编不过。</p>
<p>​    <img src="./assets/22009.png" alt="0"></p>
<p>拼写单词一定要细心，错一个字符都编译不过。英语基础不好的读者，尤其要注意这点。在小程序中，用作标签名的单词，都是真实的有意义的单词，如果不认识，不妨查一下词典，将拼写识断清楚。</p>
<h2>4，基础库版本需要更改吗？</h2>
<p>有读者问这样的问题，编写书上的demo，需要指定基础库的版本吗？</p>
<p>​    <img src="./assets/22020.jpeg" alt="0"></p>
<p>答案是不需要。</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[小程序从0到1：1月25日群问题集锦]]></title>
            <link>https://yishulun.com/./src/posts/2018/03.html</link>
            <guid>https://yishulun.com/./src/posts/2018/03.html</guid>
            <pubDate>Thu, 25 Jan 2018 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>小程序从0到1：1月25日群问题集锦</h1>
<h2><strong>1，大家都是在第三方平台上做的小程序吗？</strong></h2>
<p>据作者观察，大家好像还是用微信开发者工具最多。</p>
<h2><strong>2，有没有朋友遇到过，for循环节点显示不出来的情况？</strong></h2>
<p>​    <img src="./assets/22288.jpeg" alt="0" style="zoom:50%;" /></p>
<p>这种情况，可以在Wxml面板中查看button节点有没有生成，如果有，再查看样式的设置是否正确。关于Wxml面板，如下所示。需要注意的是，在小游戏版本的微信开发者工具中，是没有Wxml面板的，虽然它们的名字一样。</p>
<p>​    <img src="./assets/22291.png" alt="0" style="zoom:33%;" /></p>
<h2><strong>3，一个帐号可以弄几个小程序啊？</strong></h2>
<p>企业、政府、媒体、其他组织主体可以注册50个小程序，个体户和个人类型主体可注册5个小程序。</p>
<h2><strong>4，这个是在什么地方设置呢？</strong></h2>
<p>​    <img src="./assets/22314.jpeg" alt="0" style="zoom:50%;" /></p>
<p>在项目“详情”中</p>
<img src="./assets/22317.png" alt="0" style="zoom: 33%;" />
<p>反选“不检验安全域名”：</p>
<p>​    <img src="./assets/22319.png" alt="0" style="zoom:50%;" /></p>
<p>拟增加进快速创建项目，或第一次调用接口一节中。</p>
<h2><strong>5，第7.1.4节，命令行工具是指？</strong></h2>
<p>​    <img src="./assets/22328.jpeg" alt="0" style="zoom: 33%;" /></p>
<p>在win上指命令行窗口（cmd），在mac和linux上指终端窗口。如果安装了git bash，在win上直接使用git bash就可以了。</p>
<h2><strong>6，建议群主搞个go和类库安装的详细说明，小白太多？</strong></h2>
<p>书第7.1.1节，即是“安装Golang语言包”。Go语言类库的安装，十分简单，一条指令：</p>
<pre><code>go get xx
</code></pre>
<p>后面跟类库的git网址，一般是github的项目主页地址。</p>
<h2><strong>7，我从内嵌的H5页面跳转回小程序页面，怎么跳转？</strong></h2>
<p>可以考虑 wx.miniProgram.navigateBack 接口。详见：</p>
<p><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/component/web-view.html">https://mp.weixin.qq.com/debug/wxadoc/dev/component/web-view.html</a></p>
<h2><strong>8，服务器空间需要买多大的？</strong></h2>
<p>如果选择了ubuntu系统，服务器主机默认一般有20G系统盘，足够了，程序基本不占空间。涉及的图像、视频的存储，建议用存储云；数据存储使用关系数据库，例如mysql。</p>
<h2><strong>9，关于js“js not defined”错误？</strong></h2>
<p>​    <img src="./assets/22346.jpeg" alt="0" style="zoom:33%;" /></p>
<p>这种错误一般是没有找到对应的文件，例如sim.js/index.js。请在资源管理器中查看一下文件是否存在，还有引入的路径有没有写错。</p>
<h2><strong>10，请问这种框是什么组件？电影选座页面</strong></h2>
<p>​    <img src="./assets/22353.jpeg" alt="0" style="zoom: 25%;" /></p>
<p>这种功能复杂的页面，都是自定义实现的。小程序自带的组件，大多数都极简单，像DataPicker已经算是复杂的组件了。</p>
<h2><strong>11，AppID不够用了</strong></h2>
<p>现在练习前后端，要输入小程序 的Appid，一个手机号只能注册5个小程序，那我现在练习这个是不是就占了一个？每练习一个就占一个名额？</p>
<p>重复使用一个就可以了。</p>
<h2><strong>12，请问老师第7章的服务器可以直接放在我的腾讯云服务器上运行，然后我通过服务器的ip地址访问吗？</strong></h2>
<p>完全可以，作者授权所有读者免费使用。上线后，可以通过IP访问。</p>
<h2><strong>13，笑林百家的图书存储，如果不用七牛空间怎么弄？</strong></h2>
<p>​    <img src="./assets/22362.jpeg" alt="0" style="zoom:50%;" /></p>
<p>可以尝试自己写一个直接存于硬盘，或者用腾讯的云存储。但这样的话，和上面的配置就没有任何关系了，它仅适用于qiniu的云存储。</p>
<p>话又说回来，为啥不用呢？许式伟还没有给我广告费，推荐读者用它，仅是因它免费易用。</p>
<h2><strong>14，控制台在那里？</strong></h2>
<p>微信开发者工具的console面板。同学，请注意看书，不要开小差。</p>
<h2><strong>15，浏览器访问接口没有正常输出？</strong></h2>
<p>​    <img src="https://note.youdao.com/yws/public/resource/b4464d346a4b64288ac091aa86b09291/xmlnote/4CBA46764F36457190BDDB3815A40247/22371" alt="0" style="zoom:50%;" /></p>
<p>这里的地址，不用加s，使用http即可。另外，在启动debug.sh脚本后，出现如下的阻塞状态，这是正常的。</p>
<p>​    <img src="./assets/22376.jpeg" alt="0"></p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[小程序从0到1：第一次在windows机器上使用sim.go需要注意的问题总结]]></title>
            <link>https://yishulun.com/./src/posts/2018/04.html</link>
            <guid>https://yishulun.com/./src/posts/2018/04.html</guid>
            <pubDate>Thu, 25 Jan 2018 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>小程序从0到1：第一次在windows机器上使用sim.go需要注意的问题总结</h1>
<p>在win系统上安装gcc分两种情况，一种系统是win10，另一种是win7。如果是后者，请跳到子目录7查看。</p>
<p>作者在写书的过程中，所有demo均是基于mac系统构建。使用mac电脑学习的读者，不存在以下问题，可以略过了。</p>
<p>因为windows系统默认不安装gcc，而在sim.go中使用了sqlite3类库，该类库间接使用了cgo，在编译的过程中需要gcc编译器，因此有了这篇教程。</p>
<h2><strong>1，使用git bash代替cmd</strong></h2>
<p>windows读者按照书上第96页，第7.1.2小节“安装仓库管理工具git”的说明，完成了git的安装之后，就不要再使用系统自带的终端工具cmd了，要使用git bash。在任何目录空白处，右键单击，就可以看到“Git Bash Here”的菜单。</p>
<p>使用git bash代替cmd有哪些好处呢？</p>
<p>1）首先，cd更加方面</p>
<p>如果在当前的项目目录打开git bash，会直接定位到当前目录，免去了cd的麻烦。在git bash中，/c/代表c:/，/d/代替d:/，使用习惯是类linux的。</p>
<p>2）其次，避免将sim.go误判为文件</p>
<h2><strong>2，<a href="http://golang.org/x%E7%B1%BB%E5%BA%93%E6%97%A0%E6%B3%95%E4%B8%8B%E8%BD%BD%E7%9A%84%E9%97%AE%E9%A2%98">golang.org/x类库无法下载的问题</a></strong></h2>
<p>这是一个读者遇到的问题：</p>
<blockquote>
<p>C:\Users\Administrator&gt;go get <a href="http://github.com/rixingyike/sim.go">github.com/rixingyike/sim.go</a> package <a href="http://golang.org/x/net/context:">golang.org/x/net/context:</a> unrecognized import path &quot;<a href="http://golang.org/x/net/context">golang.org/x/net/context</a>&quot; (https fetch: Get <a href="https://golang.org/x/net/context?go-get=1:">https://golang.org/x/net/context?go-get=1:</a> dial tcp 216.239.37.1:443: connectex: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond.)</p>
</blockquote>
<p>因为被墙，国内没有办法直接下载这个Google官方的类库。解决方法：</p>
<p>1）手动下载x类库</p>
<pre><code>git clone https://github.com/rixingyike/golang.org-x
</code></pre>
<p>2）将clone下来的x目录放至$GOPATH/src/golang.org目录下</p>
<p>解决了上述问题之后，别忘记再次运行“go get <a href="http://github.com/rixingyike/sim.go%E2%80%9D">github.com/rixingyike/sim.go”</a></p>
<h2><strong>3，如何找到$GOPATH/src/golang.org目录？</strong></h2>
<p>在终端中执行：</p>
<pre><code>go env
</code></pre>
<p>查看GOPATH所在的目录</p>
<p><img src="./assets/202120210327210608.jpeg" alt="0"></p>
<p>在windows上cmd中执行go env，可能输出是这样的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/20210327215222.png" alt="image-20210327210802847"></p>
<p>如果没有在src目录下找到golang.org目录，新建一个。</p>
<h2><strong>4，安装gin工具</strong></h2>
<p>正常情况下，启动服务端后，在浏览器访问localhost:4000/hi，会看到文本的输出。</p>
<p>这是一位读者看到的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/20210327215316.png" alt="image-20210327215315987"></p>
<p>服务尚未启动。需要检查是否在当前项目的后端目录下，执行了debug.sh脚本。</p>
<p>如果执行debug.sh脚本，终端未被阻塞，可能脚本未执行成功。此时在终端里输入：</p>
<p>gin</p>
<p>查看有没有输出。如果输出：</p>
<p><img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/20210327215449.png" alt="image-20210327215449058"></p>
<p>则说明gin尚未安装成功。如果已经按书上第96页的步骤，安装了gin工具。出现这种问题，是因为没有把GOPATH/bin目录添加进windows系统变量PATH中。在windows机器上，右键单击“计算机”，选择“属性”-&gt;“高级系统设置”-&gt;“系统变量”，在当前用户下找到PATH变量，在尾部添加目录。</p>
<p>安装并设置环境后，再次执行gin指令，如果输出：</p>
<p><img src="./assets/202120210327210607.png" alt="0"></p>
<p>说明安装成功了。</p>
<h2><strong>5，如何更新sim.go</strong></h2>
<p>go get -u <a href="http://github.com/rixingyike/sim.go">github.com/rixingyike/sim.go</a></p>
<p>使用以上脚本更新sim.go类库，如果出现了以下输出：</p>
<p><img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/20210327215527.png" alt="image-20210327215527375"></p>
<p>不用管它，不影响继续征程。</p>
<h2><strong>6，在windows10上安装gcc</strong></h2>
<p>启动服务后，访问<a href="http://localhost:4000/hi%EF%BC%8C%E6%9C%89%E8%AF%BB%E8%80%85%E9%81%87%E5%88%B0%E8%BF%99%E6%A0%B7%E7%9A%84%E9%94%99%E8%AF%AF%EF%BC%9A">http://localhost:4000/hi，有读者遇到这样的错误：</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/20210327215618.png" alt="image-20210327215605004"></p>
<p>这是因为没有安装gcc编译器。win10解决方法：</p>
<p>1）去<a href="https://cygwin.com/install.html%EF%BC%8C%E4%B8%8B%E8%BD%BDsetup-x86_64.exe">https://cygwin.com/install.html，下载setup-x86_64.exe</a></p>
<p>2，下载后，选择网络安装。等列表加载后，在顶部的搜索框里输入gcc。</p>
<p><img src="https://cdn.jsdelivr.net/gh/rixingyike/images/2021/20210327215618.png" alt="image-20210327215618869"></p>
<p>在Devel这一组下选择gcc-g++:</p>
<p><img src="./assets/21928.jpeg" alt="0"></p>
<p>往后就一路默认安装。</p>
<p>完成安装后，在终端内输入gcc，会看到有内容输出。</p>
<p>至于下载时选择哪个镜像地址：</p>
<p><img src="./assets/21931.png" alt="0"></p>
<p>一般选择前面的，下载会比较快。</p>
<p>gcc安装后，在git <a href="http://xn--bashdebug-on3o469l64vrv0gy11a.sh">bash里再次执行debug.sh</a>（sh文件在windows系统的git bash里也是认的）。输出像这个样子：</p>
<p><img src="./assets/21934.jpeg" alt="0"></p>
<p>浏览器访问<a href="http://localhost:4000/hi%EF%BC%8C%E6%98%AF%E8%BF%99%E6%A0%B7%E7%9A%84%EF%BC%9A">http://localhost:4000/hi，是这样的：</a></p>
<p><img src="./assets/21938.png" alt="0"></p>
<p>作者用win10作了测试，以上安装gcc的流程可以跑通。</p>
<h2><strong>7，在win7系统上安装gcc</strong></h2>
<p><img src="./assets/21945.png" alt="0"></p>
<p>如果是win7 32位系统，按照上面的方法安装，可能会出现以下问题：</p>
<p><img src="./assets/21943.png" alt="0"></p>
<p>这是一位读者遇到的问题，作者也是第一次遇到。为了解决该问题，作者请读者在电脑上安装了远程工具teamviewer：<a href="https://www.teamviewer.com/zhCN/">https://www.teamviewer.com/zhCN/</a></p>
<p>作者在这位读者的电脑上进行远程操作。解决方法是：</p>
<p>1）首先，将系统变量里的cygwin去掉</p>
<p>2）然后，如果是win7 32位系统，去这里<a href="https://sourceforge.net/projects/mingw/%EF%BC%8C%E4%B8%8B%E8%BD%BDMinimalist">https://sourceforge.net/projects/mingw/，下载Minimalist</a> GNU for Windows，并安装之；如果是win7 64系统，去这里<a href="https://sourceforge.net/projects/mingw-w64%EF%BC%8C%E4%B8%8B%E8%BD%BD%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E5%B9%B6%E5%AE%89%E8%A3%85%E3%80%82">https://sourceforge.net/projects/mingw-w64，下载最新版本并安装。</a></p>
<p>3）安装以后，仍然是类似的方法，选择gcc-g++package安装</p>
<p><img src="./assets/21958.png" alt="0"></p>
<p>安装方法是选择后，再选择菜单里的apply change。选择后如下所示：</p>
<p><img src="./assets/21962.png" alt="0"></p>
<p>在终端里输入gcc --version，正常的输出：</p>
<p><img src="./assets/21965.png" alt="0"></p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[小程序从0到1：1月23日群问题集锦]]></title>
            <link>https://yishulun.com/./src/posts/2018/02.html</link>
            <guid>https://yishulun.com/./src/posts/2018/02.html</guid>
            <pubDate>Tue, 23 Jan 2018 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>小程序从0到1：1月23日群问题集锦</h1>
<h2><strong>1，打发下无聊时间，制作一个简单的小游戏，不难吧？</strong></h2>
<p>a)如果没有js基础的话，不行的，我在知乎Live课（<a href="https://www.zhihu.com/lives/930123989723004928/">如何从零开发一款「微信小游戏」</a>）里面贴了一个js基础教程的链接（<a href="http://www.shouce.ren/api/view/a/827%EF%BC%89%EF%BC%8C%E9%82%A3%E4%B8%AA%E8%B5%B7%E7%A0%81%E8%A6%81%E7%9C%8B%E4%B8%80%E4%B8%8B%E3%80%82">http://www.shouce.ren/api/view/a/827），那个起码要看一下。</a></p>
<p>b)还有在我的书《小程序从0到1》里面，第15章是关于js的入门，也建议看一下。</p>
<p>c)这两个都看了以后呢，你把我在Live课（<a href="https://www.zhihu.com/lives/930123989723004928/">如何从零开发一款「微信小游戏」</a>）里面发的那个demo，仔细研究一下，在本机上跑一跑。</p>
<h2><strong>2，微信的第三方平台是个什么样的存在？</strong></h2>
<p>公众平台第三方平台是为了让公众号或小程序运营者，在面向垂直行业需求时，可以一键授权给第三方平台（并且可以同时授权给多家第三方），通过第三方平台来完成业务，开放给所有通过开发者资质认证后的开发者使用。</p>
<p>从业务特征上来说，第三方平台必须如图所示：</p>
<p>​    <img src="./assets/22187.png" alt="0" style="zoom:50%;" /></p>
<h2><strong>3，这一段是做什么用的？服务端为什么要连接其它网址？</strong></h2>
<p>​    <img src="./assets/22191.jpeg" alt="0" style="zoom:50%;" /></p>
<p>在这里，git clone是为了从github上下载服务器端示例源码，方便在此源码的基础之上修改。</p>
<h2><strong>4，第2.9.5节说在”项目“，上单击”上传“按钮，没有上传按钮啊？</strong></h2>
<p>看下图的右边：</p>
<p>​    <img src="./assets/22198.png" alt="0" style="zoom:50%;" /></p>
<p>新旧版本的微信开发者工具在布局上存在一些差异。</p>
<h2><strong>5，第3章 计算皮相  ，这是一个计算器，为什么叫计算皮相？皮相是什么东西？</strong></h2>
<p>随便起的。</p>
<h2><strong>6，用sim.go可以给自己的数据库写类似豆瓣的API吗，我觉得最难的就是如何把数据库部署到API上？</strong></h2>
<p>第8章就讲到了从Sqlite3数据中取数据，并从分页接口取出。</p>
<h2><strong>7，豆瓣API不能调用了怎么办？</strong></h2>
<p>豆瓣API的网址</p>
<p><a href="https://developers.douban.com/wiki/?title=movie_v2#top250">https://developers.douban.com/wiki/?title=movie_v2#top250</a></p>
<p>豆豆电影中主要用到的接口有——</p>
<p>豆瓣电影详情接口：</p>
<p><a href="http://api.douban.com/v2/movie/subject/1764796">http://api.douban.com/v2/movie/subject/1764796</a></p>
<p>榜单：</p>
<p><a href="http://api.douban.com/v2/movie/in_theaters">http://api.douban.com/v2/movie/in_theaters</a></p>
<p><a href="http://api.douban.com/v2/movie/coming_soon">http://api.douban.com/v2/movie/coming_soon</a></p>
<p><a href="http://api.douban.com/v2/movie/top250">http://api.douban.com/v2/movie/top250</a></p>
<p>以上接口作者亲测，都还可用。不存在豆瓣倒闭或封杀小程序调用的情况。毕竟我们很渺小。</p>
<p>如果单一IP调用过多，可能被关小黑屋一天。有网友做了nginx代理，提供了代理接口，可以一看：</p>
<p><a href="https://github.com/zce/weapp-demo/blob/master/README.md">https://github.com/zce/weapp-demo/blob/master/README.md</a></p>
<h2><strong>8，关于第7章接口调用的问题</strong></h2>
<p>有读者完成了第七章的功课，修改了第二章的index页面，item页面的api url</p>
<p>1）<a href="http://localhost:4000/movie/bang/in_theaters">http://localhost:4000/movie/bang/in_theaters</a>  有数据返回</p>
<p>2）单部电影有数据返回，页面正常</p>
<p>问题是：</p>
<p><a href="http://localhost:4000/movie/bang/coming_soon">http://localhost:4000/movie/bang/coming_soon</a></p>
<p><a href="http://localhost:4000/movie/bang/top250">http://localhost:4000/movie/bang/top250</a></p>
<p>这两个没有数据返回， index页面后两项无显示。</p>
<p>榜单接口coming_soon、top250与in_theaters是类似的。如果后者能访问，前二者也可能是正常的。可以在小程序中使用console.log()查看服务器端接口返回的数据。然后进一步排查问题出在哪里。</p>
<h2><strong>9，为什么同样的代码，pc正常，手机端 onload就加载不到数据呢？</strong></h2>
<p>​    <img src="./assets/22225.jpeg" alt="0" style="zoom: 25%;" /></p>
<p>这种情况，首先要检测一下接口地址，如果接口地址使用了localhost，在手机上是没有localhost的。可以将手机与电脑的服务器端放在同一个网段，然后使用类似于“192.168.x.x”这样的局域网IP代替localhost。</p>
<h2><strong>10，怎么查找调试域名，书上第6.1.1节的方法试了，不行啊？</strong></h2>
<p>​    <img src="./assets/22232.jpeg" alt="0"></p>
<p>通过修改image组件的src属性为错误的地址，故意让程序出错，以此查看调试域名的方法，现在行不通了。在新版本的微信开发者工具中已经屏蔽了，毕竟这本是一个非官方的方法。</p>
<h2><strong>11，小程序中，怎么合并这两个对象啊？</strong></h2>
<pre><code class="language-js">var userinfo = {avatarUrl:&quot;1&quot;,
city:&quot;2&quot;,
country:&quot;China&quot;,
gender:1,
language:&quot;zh_CN&quot;,
nickName:&quot;3&quot;,
province:&quot;4&quot;}
var openid = {openId:'5',session_key:'6'}
</code></pre>
<p>用Object.assign()合并</p>
<h2><strong>12，go get <a href="http://github.com/rixingyike/sim.go">github.com/rixingyike/sim.go</a> 一直执行不成功？</strong></h2>
<p>出现“unrecognized import path '<a href="http://golang.org/x/net/contxt">golang.org/x/net/contxt</a>'”的错误</p>
<p>​    <img src="./assets/22245.png" alt="0"></p>
<p>在这篇群公告文章（/posts/2018/04.html）中讲了。</p>
<p>​    <img src="./assets/22250.png" alt="0" style="zoom:33%;" /></p>
<p>要仔细阅读群公告文章，这里都是别人踩过的坑。</p>
<h2><strong>13，如何从一个小程序能跳到另一个小程序？</strong></h2>
<p>使用接口：<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/api/navigateToMiniProgram.html">wx.navigateToMiniProgram(OBJECT)</a></p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[小程序从0到1：1月9日群问题集锦]]></title>
            <link>https://yishulun.com/./src/posts/2018/01.html</link>
            <guid>https://yishulun.com/./src/posts/2018/01.html</guid>
            <pubDate>Tue, 09 Jan 2018 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>小程序从0到1：1月9日群问题集锦</h1>
<p>目录</p>
<p>[TOC]</p>
<h2>1，如体在群内提问？</h2>
<p>可以参考一下在stackoverflow或github上提问的方法，一次把问题讲明白，用文字说明+截图的方式。目前在学习哪一章，遇到了什么问题，把运行截图贴出来。</p>
<h2>2，读者：“我用书上的方法为什么没有找到调试域名”？</h2>
<p><img src="./assets/22072.jpeg" alt="0"></p>
<p>可能新版本不好使了，毕竟这本是一个非官方的办法。</p>
<h2>3，读者：“go env 之类没问题，但是go get sim.go类库回车没反应..”</h2>
<img src="./assets/22079.jpeg" alt="0" style="zoom: 50%;" />
<p>这不叫没反应。</p>
<p>这位读者还是没仔细读文档，get是go语言的指令，如果运行出错，它会直接提示。这种情况，可能是网络被墙了，一直在请求中。按照群公告文档1的步骤做，里面有免翻墙安装google官方类库的方法。</p>
<h2>4，能不能加作者微信？</h2>
<p>可以加微信。</p>
<h2>5，读者：“ retrieveData函数放在哪个页面呢”</h2>
<p>微信开发者工具有全局搜索功能，选择菜单“编辑”-&gt;&quot;全局搜索&quot;</p>
<h2>6，读者：“豆豆电影项目最后只能在调试环境下运行，由于审核无法通过而无法真正上线运行，是这样嘛”</h2>
<p>需要有备案过的服务器加域名。（读者@杜创）</p>
<h2>7，“请问下，这个电子书有离线版本的吗？能不能下载下来看？”</h2>
<p>找到了告诉我，我举报盗版。</p>
<h2>8，在界面上绑定的值，如果设置默认值？</h2>
<p>缺少默认值的错误表现</p>
<img src="./assets/22120.png" alt="0" style="zoom:50%;" />
<p>例如weather.today.type：</p>
<p><img src="./assets/22100.jpeg" alt="0"></p>
<h2>9，读者“这都是些什么基础的人啊，之前还有人模板字符串不知道，本来还以为可以交流的..”</h2>
<p>术道有专攻，每个人的基础不一样，要尊重每一个人，求同存异。</p>
<h2>10，读者“我完全是按照书上来的啊，检查了几遍了，为什么还有错？”</h2>
<img src="./assets/22110.jpeg" alt="0" style="zoom: 50%;" />
<p>拼写不认真，80%的错误都是由于拼写不认真。例如，这里面的Style的首字母大写了，再如absolute写成abosolute了。写程序错一个字符都不行。</p>
<h2>11，想让134横排显示怎么弄，设置什么属性？</h2>
<p><img src="./assets/22124.jpeg" alt="0"></p>
<p>查flex布局相关。</p>
<h2>12，图片为何挤到了一起？</h2>
<img src="./assets/22128.jpeg" alt="0" style="zoom:50%;" />
<p>9.2版本的iPhone plus会出现以上问题。升级iOS固件版本，解决。</p>
<h2>13，读者“style中的最后一个分号可加可不加是吗？”</h2>
<img src="./assets/22135.jpeg" alt="0" style="zoom:50%;" />
<p>对。</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[十个Flex/Air疑难杂症及解决方案简略]]></title>
            <link>https://yishulun.com/./src/posts/2010/02.html</link>
            <guid>https://yishulun.com/./src/posts/2010/02.html</guid>
            <pubDate>Tue, 01 Jun 2010 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>十个Flex/Air疑难杂症及解决方案简略</h1>
<p>最近去一家台企，对方给我出了十道“难道”：</p>
<ol>
<li>在TileList中如果選擇檔過多，會出現捲軸，當拖動捲軸時，渲染的進度條會出現花屏現象；</li>
</ol>
<p>简体：在TileList中如果选择档过多，会出现卷轴，当拖动卷轴时，渲染的进度条会出现花屏现象；電子白板中，控制權轉移；</p>
<ol start="2">
<li>
<p>简体：电子白板中，控制权转移；電子白板中，畫面同步；</p>
</li>
<li>
<p>简体：电子白板中，画面同步；電子白板中，錄影；</p>
</li>
<li>
<p>简体：电子白板中，录影；FLASH置頂問題；</p>
</li>
<li>
<p>简体：FLASH的置顶问题;聊天表情無法复制粘贴，由于聊天表情是动态文本，所以添加到textflow中的是一个sprite对象；</p>
</li>
<li>
<p>简体：聊天表情無法复制粘贴，由于聊天表情是动态文本，所以添加到textflow中的是一个sprite对象；老板模式，当系统焦点离开air程序后，无法检测到系统的key_down事件；</p>
</li>
<li>
<p>简体：老板模式，当系统焦点离开air程序后，无法检测到系统的key_down事件；Air注册表操作(登陆启动look程序)；</p>
</li>
<li>
<p>简体：Air注册表操作(登陆启动look程序)；在1.5的air运行时环境下，中文不能输入问题，因为客户端可能已经安装1.5的运行时，在网页安装中只能检测客户端是否安装了运行时，却无法检测到版本信息或者更新运行时；</p>
</li>
<li>
<p>简体：在1.5的air运行时环境下，中文不能输入问题，因为客户端可能已经安装1.5的运行时，在网页安装中只能检测客户端是否安装了运行时，却无法检测到版本信息或者更新运行时隐藏window边框后，鼠标在拖动窗口边界改变窗口大小时，不能设置系统光标样式。</p>
</li>
<li>
<p>简体：隐藏window边框后，鼠标在拖动窗口边界改变窗口大小时，不能设置系统光标样式</p>
</li>
</ol>
<blockquote>
<p>PS：一种语言在发音上有几十种不同的方言风格，在书写上竟然也有两种截然不同的风格，不止何时可以统一。</p>
</blockquote>
<p><strong>杂症病因及解决方案简略：</strong></p>
<h2>1，ITEMRENDERER的花屏问题</h2>
<p>并非TileList有这个问题，在Flex3内，DataGrid，List，Tree等控件如果使用不当，均存在这个问题;在先前的fl组件包内的TileList组件也有类似阴影。根本原因在于，使用ItemRenderer的大数据控件，其在渲染时，并不会一次创建所有数据列/行的显示对象(ItemRenderer)，它仅会创建在屏幕上可见的数据列/行，并且重复利用这些显示对象，以提交运行时效率。</p>
<p>可以做这样一种代码实验，以帮助人们理解这种机制：在一个TileList控件内，它本身有滚动条，它的ItemRenderer也使其有滚动条，在多屏数据的情况下，任意滚动一个ItemRenderer的滚动条，然后滚动TileList的滚动条到另一屏，你会发现，虽然数据已经变了，你从未滚动过这个数据，但它与你先前滚动过的那个数据具有相同的滚动位置。</p>
<p>从严格意义上讲，这并不能算是Adobe的bug，因为如果你严格按照Adobe的官方说明使用，多数情况下，是不会出现的，因此这个bug的复现也颇具难度。从Flex SDk 3.5开始，Adobe Flex团队，对所有基于ItemRenderer实现的数据控件针对开发者遇到的问题进行了改良，优化了SDK内部控件实现方法，并且添加了一个offscreenExtraRowsOrColumns属性，该属性意为非显示区域的行或列数，用于帮助开发者在特定情况下遇到的花屏问题。</p>
<p>如果遇到这个问题，如果解决(方案按优先级自上向下排列)：</p>
<h3>1) 修改策划</h3>
<p>显示大数据时，传统滚动条是一个糟糕的设计，因为人的眼晴对于大量的，重复结构的数据，很难定位上次查看的位置，多数人都是边察看边用指在屏幕上做标记。此种情况下，</p>
<ul>
<li>
<p>a)要么不使用滚动条，使用翻页，用户每次翻页后，重新取数据、向数据控件赋值，在这种情况下，DataGrid，TileList等均不会出现花屏问题，因为压根儿就不会有滚动，但在此时，使用Repeater效率更高。</p>
</li>
<li>
<p>b)要么设计一种粗粒度滚动条，如下图示意：</p>
</li>
</ul>
<p>在这种粗粒度滚动中，每一个点相关于翻页设计中的一页，用户拖动时还相当有手感，相对传统滚动条要好许多，这种设计在许多产品中都已经开始使用。</p>
<h3>2）在更新DataProvider时手动刷新控件视图</h3>
<p>每次当data有变化，均手动再次设置一次ItemRenderer，大意如下：</p>
<pre><code class="language-js">list.itemRenderer = new ClassFactory(YourItemRenderer);
</code></pre>
<p>注：在Gumbo中，如果使用Bindable绑定数据，FB在编译时已经做了代码优化。所以，多数时候，按照官方方法可以避免很多问题。</p>
<h3>3）使用offscreenExtraRowsOrColumns属性调整</h3>
<p>这是最BT的方案，让人感觉是Adobe自己用算法难已处理了，所以请用户告诉控件目前有多少数据列/行在显示区外。具体用法请参照livedoc说明。</p>
<h2>2-4，电子白板问题简略</h2>
<p>在白板开发中，控制权转移，画面同步，录影属于基本功能点。在技术技巧上，录影使用ImageSnapshot取得数据，剩下的便是系统架构师的事情。白板若要做好，方方面面必须设计好，特别是多人同时在线应用。</p>
<p>最基本的白板实现方案是基于ShareObject，但这种实现是demo级的，既浪费资源性能又低，比较合理的设计，作者认为应该是这样：</p>
<ul>
<li>
<p>1）控制权转移实则是多人数据同步，数据同步不要使用SO，当控制权变化时，由Server处理并向Client广播，如果在同一时间内白板只充许有一人控制，此时仅需向二人广播，如果其它人也需要知道当前人控权者是谁，通过另外统一的状态广播实现。</p>
</li>
<li>
<p>2）画面同步必须设计出二种机制，一种为指令绘制型，另一种为图像同步型。对于后来进入观看白板的人用户，它第一次需要向server请求当前最新的白板画面，server选择一个最可靠的client的白板数据发给新来者，或者使用p2p技术直接由client端发送。指令绘制型用于在活动用户之间更新白板数据、动作。指令需自行设计，这种设计可以轻松实现白板重绘。</p>
</li>
<li>
<p>3）录影在这里有两种实现，一种为ImageSnapshot，另一种为指令重绘型。</p>
</li>
</ul>
<h2>5，FLASH的置顶问题</h2>
<p>默认情况下，在网页中swf对象之上放置不了浮动层，解决方案是修改FlashVars属性值，把wmode修改为opaque，同时对照其它对象，排列z-index。</p>
<h2>6，聊天表情無法复制粘贴，由于聊天表情是动态文本，所以添加到TEXTFLOW中的是一个SPRITE对象</h2>
<p>这个问题没有一步到位的方案，属于架构师考虑的设计问题。自定义一种输入框，自定义一套emoticon标签，每一个表情用一个自定义标签标识，监听输入框的copy与paste事件，送入剪辑板的数据仅包含emoticon标签，而不是图像数据，在paste时进行解析、替换。</p>
<h2>7，老板模式，当系统焦点离开AIR程序后，无法检测到系统的KEY_DOWN事件</h2>
<p>系统焦点离开AIR后，即使在AIR中有KEY_DOWN事情监听也无济于事。解决方案是，rumtime升级到AIR 2.0，在AIR程序启动时，同时启动一个C++ native progress，当AIR程序最小化至系统托盘后，由C++程序负责监听系统按键，以此实现AIR程度快捷键呼出。</p>
<h2>8，AIR注册表操作(登陆启动LOOK程序)</h2>
<p>Air直接写不了，解决方案有两种方向：</p>
<ul>
<li>1）与问题7同，使用nvtive progress写注册表</li>
<li>2）不使用AIR，使用替换解决方案Flex4U</li>
</ul>
<h2>9，在1.5的AIR运行时环境下，中文不能输入问题</h2>
<p>因为客户端可能已经安装1.5的运行时，在网页安装中只能检测客户端是否安装了运行时，却无法检测到版本信息或者更新运行时</p>
<p>这里面有二个问题，第一个，对于必须要求rumtime为2.0的air程序，在编译时指定，强制用户升级。<br>
第二个，在网页中安装air，如何知道用户的air rumtime版本？</p>
<p>Adobe的air网页在线安装是通过这个swf实现的：</p>
<p><a href="http://airdownload.adobe.com/air/browserapi/air.swf">http://airdownload.adobe.com/air/browserapi/air.swf</a></p>
<p>下载，反编译后，里面使用一个叫做ProductManager的类进行客户端环境的签别，验证。一共有两个类文件：<a href="http://AIR.xn--asAIRLCEndpoint-gl3x.as">AIR.as与AIRLCEndpoint.as</a>。</p>
<p>从原理上讲，可以hack反编译之后的源码，重新编译为自已的air.swf，然后自定义bridge网页安装实现。</p>
<h2>10，隐藏WINDOW边框后，鼠标在拖动窗口边界改变窗口大小时，不能设置系统光标样式</h2>
<p>这个问题不复杂。如果不使用系统镶边，自定义光标显示对象，添加进显示列表，并添加事情监听实现缩放与拖动逻辑。在livedoc中官方曾见有示例，有兴趣的朋友可以查一查。</p>
<p>2010年6月</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[命名空间：如何控制未知方法的调用]]></title>
            <link>https://yishulun.com/./src/posts/2010/01.html</link>
            <guid>https://yishulun.com/./src/posts/2010/01.html</guid>
            <pubDate>Sat, 01 May 2010 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>命名空间：如何控制未知方法的调用</h1>
<p>命名空间对于程序员来讲，应当不会陌生，几乎每写一行代码，就要用到一止一个命名空间。AS3默认大约打开了6个命名空间。</p>
<h2>1，AS3提供的常用的7个命名空间</h2>
<p>internal,private,protected,public,static,as3，前5个命名空间作为类属性访问控制说明，在AS3中 是默认打开的。最后一个命名空间as3，默认也是被打开的，一般很少显式用到它。flash_proxy命名空间在控制动态方法调用时很有用，默认它是关 闭的。</p>
<p>internal作为默认的命名空间，当程序员未显式使用访问控制说明时，它即被默认。</p>
<h2>2，如何继承Proxy实现匿名方法调用的控制</h2>
<pre><code class="language-js">package
{
  import flash.display.Sprite;
  /**
   * @author LIYI &lt;http://yishulun.com/&gt;
   * Email: 9830131@qq.com
   */
  public class ProxyTest extends Sprite {
    public function ProxyTest() {
      super();
      var obj :MyClass = new MyClass();
      trace( obj.hello('sban') );
      // output: hello,sban
    }
  }
}
import flash.utils.Proxy;
import flash.utils.flash_proxy;

class MyClass extends Proxy {
  use namespace flash_proxy;
	override flash_proxy function callProperty(name:*, ...parameters):* {
    if ((name as QName).localName == 'hello') {
        return &quot;hello,&quot; + parameters[0];
    }
    return null;
	}
}
</code></pre>
<p>上例代码演示了如何标题问题。需要指出，如果使用FB编译，需要反选&quot;启用严格类型检查&quot;，否则编译不过。</p>
<h2>3，如何自定义与使用命名空间</h2>
<p>在单独一个文件中定义，一般位于*.core子包中：</p>
<pre><code class="language-js">package sban.as3Expert.core {
    public namespace as3internal = &quot;https://yishulun.com/as3internal/2008&quot;;
}
</code></pre>
<p>namespace是FP内部一个特殊的基元类型，它有一个URI值，如果程序员在定义时不指定，编译器将随意分配一个，尽管如此，你也不要让编译器帮你指定，因为在多数情况下你需要明确知道你定义的命名空间是什么。</p>
<p>namespace可以理解为值类型，只要URI值相同，便是相同的namespace。</p>
<p>使用自定义的namespace之前，先引入，然后使用use namespace关键字：</p>
<pre><code class="language-js">import sban.as3Expert.core.as3internal;
use namespace as3internal;
</code></pre>
<h2>4，包是什么？</h2>
<p>在AS2中，包路径并不是以package单独定义的，它位于Class Name之前，可以理解为类名称的一部分，如下：</p>
<pre><code class="language-js">class flash.display.BitmapData {}
</code></pre>
<p>在AS3中，包路径虽然以package关键字单独定义，但也可以把它理解为类名称的一部分，package与命名空间没有任何关系。AS3使用package定义包路径，与在AS2中使用class定义prototype继承机制的类对象一样，仅是语法甜头。</p>
<h2>5，命名空间的无处不在</h2>
<p>在AS3中，名字并不是唯一的标识符。在AS3中，name的含义往往包括两个部分：命名空间与名称标识。</p>
<pre><code class="language-js">public var s : String;
</code></pre>
<p>对于上面这例简短的代码，它已经包括两个命名空间，这两个命名空间含于两个QName中。QName是FP中内部名称的一种，在小标题2中，我们可以看到它。一个QName包括两个值，一个localName，是代码字面值，另一个是命名空间的uri值。</p>
<p>在上例代码中，包括一个命名空间为public、localName为s的QName，及一个命名空间为public、localName为String的QName。</p>
<p>2010年5月</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[动态语言的基石之函数闭包]]></title>
            <link>https://yishulun.com/./src/posts/2008/01.html</link>
            <guid>https://yishulun.com/./src/posts/2008/01.html</guid>
            <pubDate>Thu, 01 May 2008 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>动态语言的基石之函数闭包</h1>
<p>闭包(Closure)是函数(或方法)及其执行环境的组合体，它不仅包括函数(或方法)本身，也包括函数(或方法)运行时的上下文词汇环境。闭包是所有动态语言的基石，闭包实现了函数(或方法)可以作为参数传递给函数(或方法)。</p>
<h2>1，用一个代码实验例示闭包概念</h2>
<p>在AS3中，共种三种闭包：</p>
<p>1）函数闭包(Function Closure)</p>
<p>2）方法闭包(Method Closure)</p>
<p>3）类闭包(Class Closure)</p>
<pre><code class="language-js">public class Closure extends Sprite {
  public function Closure() {
   super();
   init();
  }
	private var author :String = &quot;sban&quot;;
	private var onMouseClick2 :Function = function(e :MouseEvent) : void {
		trace(&quot;author:&quot; + author, &quot;this:&quot; + this);//author:undefined this:[object global]
	};
	private function init() :void {
		var onMouseClick1 : Function = function(e :MouseEvent) : void {
			trace(&quot;author:&quot; + author, &quot;this:&quot; + this);//author:sban this:[object global]
		};
		this.stage.addEventListener(MouseEvent.CLICK, onMouseClick2);
	}
	private function onMouseClick(e :MouseEvent) :void {
		trace(&quot;author:&quot; + author, &quot;this:&quot; + this);//author:sban this:[object Closure]
	}
}
</code></pre>
<p>在上例代码中，分别以onMouseClick，onMouseClick1，onMouseClick2为listener向stage添加click事件监听，trace结果如代码中注释。其中，onMouseClick是方法闭包，onMouseClick1与onMouseClick2是函数闭包。这里有一个问题，为什么在onMouseClick2中author的输出结果是undefined？</p>
<h3>2，三类闭包的区分</h3>
<p>在AS3中，任何一个函数(或方法)调用，至少会有一个this参数，这几乎是所有动态语言一惯的规则，不同的是，有的语言对程序员是可见的，如Python，有的则不可见，如AS3。</p>
<p><strong>1) 方法闭包</strong></p>
<p>所有类实例的方法，作为参数传递时，均是方法闭包，隐匿的第一个this参数永远是类实例本身，如上例代码中的onMouseClick便是方法闭包，所以它的this输出为[object Closure]。</p>
<p><strong>2) 函数闭包</strong></p>
<p>所有匿名方法(包括局部变量方法，类变量方法，见上)，全局方法(包括位于根包下的全局方法，位于子包下的全局方法，见下)均是函数闭包，所有函数闭包的第一个参数如果是null，将被默认替换为Global对象，所以我们看到的输出均是[object global] 。</p>
<pre><code class="language-js">package {
  import flash.events.MouseEvent;
  function onMouseClick3(e :MouseEvent) :void {
    trace(&quot;this:&quot; + this);//this:[object global]
  }
}
package sban.as3Expert {
  import flash.events.MouseEvent;
  public function onMouseClick4(e :MouseEvent) {
    trace(&quot;this:&quot; + this);//this:[object global]
  }
}
</code></pre>
<p>对于位于子包下的函数，可以这样直接使用：</p>
<pre><code class="language-js">this.stage.addEventListener(MouseEvent.CLICK, sban.as3Expert.onMouseClick4);
</code></pre>
<p><strong>3）类闭包</strong></p>
<p>这是三类闭包中最简单的一种，也是最容易区分的一种，可能也是价值最低的一种，貌似根本不应该归为闭包类别。在AS3中，所有显式对象类型转换均是类闭包，如下：</p>
<pre><code class="language-js">// if obj is Closure which type anotation is Object
var obj1 :Closure = Closure(obj);
</code></pre>
<p>Closure在这里不是操作符，也不是别的什么东西，在这里应该把它理解为一个特殊的方法。这个方法第一个参数仍然为this，第二个参数是将被作类型转换的对象，在上例代码中为obj。</p>
<h3>3，改变函数闭包的this参数的一种情况</h3>
<p>在函数闭包中，this参数(null)通常被默默置换为global对象，在某些情况下，程序员可以传递真实的this参数进去，而不是null，从而避免被替换为global对象。</p>
<p>在Array的forEach, every, map, some, filter这些API中，第一个参数为函数对象，第二个参数为第一个参数的this对象，当程序员指定第二个参数时，便可以在第一个函数内访问this上下文环境的变量，如果不指定，便不能再其内使用this。</p>
<pre><code class="language-js">public function ArrayForEachThis() {
  super();
  var arr :Array = [1,2,3];
  arr.forEach( function (item :int,index :int=-1,arr :Array = null) :void {
     trace(item, this.author)
   }
   //,this
  );
}
private var author :String = &quot;sban&quot;;
</code></pre>
<p>编码规范：在使用Array的forEach, every, map, some, filter这些API时，必须在第二个参数位传递this进去。</p>
<h3>4，为什么在onMouseClick2中author的输出是undefined？</h3>
<p>所有AS3程序员都应当知道，在AS3运行时，有一个作用域链，该作用域链自global始，在运行时变量首先从最近的链点查找，如果未找到，再向上查找，直到找到或到达global链点。</p>
<p>onMouseClick2函数的运行时作用域链为：</p>
<pre><code>onMouseClick2闭包-&gt;global
</code></pre>
<p>在这个链条内，根本不存在author变量，所以onMouseClick2的输出为undefined。</p>
<p>而onMouseClick1的作用域链为：</p>
<pre><code>onMouseClick1-&gt;init-&gt;Closure-&gt;global
</code></pre>
<p>onMouseClick的作用域链为：</p>
<pre><code>onMouseClick-&gt;Closure-&gt;global
</code></pre>
<p>这两个作用域链均包括author变量，所以onMouseClick1与onMouseClick均不会输出undefined。</p>
<p>2008年5日</p>
<blockquote>
<p>2021更新：AS3与js同属于ECMAScript语言，按理说在闭包概念上也应该是一致的。但从上文来说，AS3的闭包概念更宏大一些，貌似把类、方法、匿名函数都包括进去了。在js中，所谓闭包就是一个函数+不属于这个函数但被这个函数用到的上下文环境变量，两者绑在一起，闭合在一起，可以在程序中像一个独立的包裹一样传来传去。这篇小文是以前写AS3代码写的，关于三个闭包的分类叫法，并非我独创的，我记录当时Adobe文档或社区里也是这么分类的。俱往矣。</p>
</blockquote>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[像Ruby一样简易行码：使用Prototype扩展原生对象]]></title>
            <link>https://yishulun.com/./src/posts/2008/02.html</link>
            <guid>https://yishulun.com/./src/posts/2008/02.html</guid>
            <pubDate>Thu, 01 May 2008 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>像Ruby一样简易行码：使用Prototype扩展原生对象</h1>
<p>AS3是基于ECMAScript标准的语言，Adobe团队在遵从此标准的同时，使其向Java靠拢具有Class-Base的特征，因此，AS3是一门很奇特的语言，它既像Javascript，又像Java（Java与Javascript是两门完全不同的语言）。</p>
<h2>1，Ruby的collect方法</h2>
<p>Ruiby的行码简易，让很多程序员爱不释手。</p>
<pre><code class="language-ruby">#!/usr/bin/ruby
puts [1,2,3,4,5,6].collect{|x| 10*x}
</code></pre>
<p>上例Ruby代码把数组中的每一个元素的值乘以10，然后打印结果。</p>
<pre><code class="language-js">10
20
30
40
50
</code></pre>
<h2>2，在AS3中实现collect方法</h2>
<p>那么在AS3中，我们能否以类似的方法（collect）操作数组？答案是可以的。Array本身是动态、可继承对象，我们可以继承它，自己实现collect方法；除此之外，我们还可以使用Prototype扩展Array的API。</p>
<pre><code class="language-js">Array.prototype.collect = function(f:Function) : Array {
	var r:Array = [];
	for each(var i:* in this) r.push(f(i));
	return r;
};
Array.prototype.setPropertyIsEnumerable('collect', false);
trace( [1,2,3,4,5].collect(function(i:int):int {return i*10;}) );
// output: 10,20,30,40,50
</code></pre>
<p>扩展Prototype实现collect方法，这种手段更加巧妙，但它从效率上讲，它逊于以继承的方式扩展Array。</p>
<h2>3，其它对象如何扩展</h2>
<p>因为Array是非final对象，所以除了使用扩展原型(prototype)的方法之外，我们还可以使用继承的方法扩展其本身并不支持的API。但是，在AS3中的其它基本对象，例如基元类型String、Number、int等，它们是final对象，是不可被继承的，仅能使用prototype扩展。<br>
因为Array是动态对象，所以直接在Array对象上调用collect方法，并不会引发编译报警，但对于非动态对象，如String、Number等，在调用时需转化为Object对象，例如：</p>
<pre><code class="language-js">Object(2).minutes().ago();
</code></pre>
<p>或：</p>
<pre><code class="language-js">var x:* = 2;
x.minutes().ago();
</code></pre>
<p>在AS3中，所有对象均基于Object，任何对象都具有prototype，即任何对象均可以使用原型扩展并不存在的API。</p>
<h2>4，Prototype扩展的弊端</h2>
<p>方便在企业项目开发中并不是唯一考虑的因素，效率在多数情况下比之占有更大的比重。使用Prototype扩展至少有以下三个方面的弊端：</p>
<ul>
<li>1）屏蔽了编译时强类型检查，代码错误的机率升高，项目风险增大。</li>
<li>2）某些对象不得不作额外的类型转换，虽然这种转换并无性能的损耗，但却让你多敲了几个键盘，偏离了简易行码的本宗。</li>
<li>3）基于Prototype的继承与Class-Base的继承，在AVM中是两种完全不同的实现，Adobe团队在AVM2中正是为了解决Prototype的低效，才引入了Class-Base的机制，显然这种不被官方、社区推崇的方法并不适当在企业项目中应用。</li>
</ul>
<p>扩展阅读：Modifying Core Types in ActionScript 3 Using the Prototype Object</p>
<p>2008年5月</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[AS3中的八种基元类型]]></title>
            <link>https://yishulun.com/./src/posts/2008/03.html</link>
            <guid>https://yishulun.com/./src/posts/2008/03.html</guid>
            <pubDate>Thu, 01 May 2008 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>AS3中的八种基元类型</h1>
<h2>一，八种基元类型</h2>
<p>何谓基元类型？即是一门语言中最基本基本的数据类型，其它数据类型均是以此为基础定义的，并且可以作为变量注释类型或函数返回类型。在AS3中，共有八种基元类型：</p>
<p>[此有图，但已被岁月冲走]</p>
<p>1）Boolean</p>
<p>布尔类型，仅有true与false两个值。默认值为false。特殊值NaN,undefined,null,字符串空值(”),0转换为Boolean后均为false。</p>
<p>2）Number</p>
<p>默认值为NaN。Number为64位的浮点数值类型，按IEEE-754标准设计。在IEEE-754标准中，一个符号位，11个指数位，52位有效数字位。Number仅有52位有效数位，为什么可以表示最大为253的精度呢？</p>
<p>3）uint</p>
<p>默认值为0。unit表示32位的无符号整数。uint的正数范围比int大，但它在多数场合并不适合代替int。</p>
<p>4）int</p>
<p>默认值也是0。int应该是AS3中使用最广泛的数值类型。</p>
<p>5）String</p>
<p>默认值为null。C#中有一个isNullOrEmpty方法，在AS3中，字符串null与空值，转换为Boolean，均是false。</p>
<p>6）*(任意类型)</p>
<p>它有一个特殊的值，undefined。在变量类型注释或函数返回注释中，使用*表示，它可以是任意子实际类型。</p>
<p>7）Object</p>
<p>在AS3中，一切皆是Object，所有Flash Player定义的，AS3中定义的对象均继承于它。默认值为null。</p>
<p>8）void(无类型)</p>
<p>Adobe官方在《flash as3 programming》中对此类型有如下描述：</p>
<blockquote>
<p>void 数据类型仅包含一个值：undefined。</p>
</blockquote>
<p>这个描述是不恰切的，undefined作为AS3语言中一个特殊的值，是所有原本要定义却未定义的变量的默认值，而不是void类型的默认值。void作为唯一一个仅能作为函数返回类型注释的基元类型，既然表示‘无’，便应该没有任何值。</p>
<p>void仅能作为函数返回类型注释，这使它位列八种基元类型的理由不是那么充分，但除此之外，我们不知道还能把它归到哪一类别里。</p>
<h2>二，Number与int, uint的性能对比</h2>
<p>我辈非Adobe官方，仅能使用实验的方法。为了测试三个数值类型的运算性能，<a href="https://yishulun.com/">作者</a> 设计了这样一个代码实验：</p>
<pre><code class="language-js">public function IntegerTest() {
	super();

	var t1:Number = new Date().getTime();
	for (var j:int=0; j&lt;100000000; j++) {
		//
	}
	var t2:Number = new Date().getTime();
	trace(&quot;Number:&quot;, t2 - t1);//1373

	t1 = new Date().getTime();
	for (var k:int=0; k&lt;100000000; k++) {
		//
	}
	t2 = new Date().getTime();
	trace(&quot;int:&quot;, t2 - t1);//1297

	t1 = new Date().getTime();
	for (var n:uint=0; n&lt;100000000; n++) {
		//
	}
	t2 = new Date().getTime();
	trace(&quot;uint:&quot;, t2 - t1);//2624
}
</code></pre>
<p>这个代码实验，分别使用Number，int，uint进行一亿次的递增与大小判断，实验结果表明，int的效率最高，Number与之相差无几，uint的效率最低，几乎比int、Number慢两倍左右。</p>
<p>但是这个实验的结果是值得怀疑的，因为AS3的编译器有可能对三个作用类似的for作了优化。使用SWFScan扫描swf文件，反编译出来的源码为：</p>
<pre><code class="language-js">public function IntegerTest() {
	super();
	var loc0:* = getTime();
	var loc1:* = 0;
	while(loc1 &lt; 100000000)
	{
	    loc1 = loc1 + 1;
	}
	var loc2:* = getTime();
	loc0 = getTime();
	var loc3:* = 0;
	while(loc3 &lt; 100000000)
	{
	    loc3 = loc3 + 1;
	}
	loc2 = getTime();
	loc0 = getTime();
	var loc4:* = 0;
	while(loc4 &lt; 100000000)
	{
	    loc4 = loc4 + 1;
	}
	loc2 = getTime();
	return;
}
</code></pre>
<p>从反编译出来的源码看，三个for循环的代码是一样的。当然这时候，我们假定反编译工具没有问题。</p>
<p>可能我们需要改进一下这个实验：</p>
<pre><code class="language-js">var n1 :Number = 0;
var t1:Number = new Date().getTime();
for (var j:int=0; j&lt;100000000; j++)
{
	n1 = j + 1.0 * 10 - 1.0 * 10;
}
var t2:Number = new Date().getTime();
trace(n1, &quot;Number:&quot;, t2 - t1);//99999999 Number: 17889

var n2 :int = 0;
t1 = new Date().getTime();
for (var k:int=0; k&lt;100000000; k++)
{
	n2 = k + 1 * 10 - 1 * 10;
}
t2 = new Date().getTime();
trace(n2, &quot;int:&quot;, t2 - t1);//99999999 int: 19729

var n3 :uint = 0;
t1 = new Date().getTime();
for (var n:uint=0; n&lt;100000000; n++)
{
	n3 = n + 1 * 10 - 1 * 10;
}
t2 = new Date().getTime();
trace(n3, &quot;uint:&quot;, t2 - t1);//99999999 uint: 21455
</code></pre>
<p>我修改的依据是：</p>
<p>1）针对同一个问题，用不同方法或原则，实现3个并行方案</p>
<p>2）3个方案的输出结果相同</p>
<p>从实验结果来看，Number的效率最高，int随之，uint最慢。这个结果虽然基于实验，却不能令人信服。</p>
<p>推测：在AS3中，所有内部运算均是以Number进行的，这种推测可以解释上述反编译代码相同的现象。如果推测正确的话，使用不同数值类型的效率差异是由于类型转换造成的，而不是由于本身运算造成的，因运算过程中的类型转换而耗费的CPU应该远高于运算本身，如果Adobe为了避免在运算过程中的频繁类型转换而在运算式内部默认使用Number进行运算也是完全符合逻辑的。</p>
<p>在<a href="https://yishulun.com/">作者</a>之前，已经有不少前辈做过类似的数组类型效率代码实验，有兴趣的朋友可以Google一下，但他们的实验结果却不尽相同。所以，拿Number，int与uint进行效率实验是没有意义的，因为实验本身可能存在问题，或许三条起跑线并不一致，所以也无法评定最终结果。</p>
<h2>三，数值类型运用最佳实践</h2>
<p>1）在for循环中使用int类型</p>
<p>2）定义颜色变量时，使用uint</p>
<p>3）定义枚举变量时，使用uint</p>
<p>4）动态改变显示对象的x,y属性时，使用int</p>
<p>5）在进行复杂的算术运算时，各算术因子均使用Number</p>
<p>6）尽要不用使用Number用在if中作大小，等于判断</p>
<h2>四，哪些是值类型，哪些是引用类型？</h2>
<p>在AS3中，虽然所有数据类型均继承于Object，也就是说它们均具有Object拥有的属性和方法，Boolean也不例外，但是除Object以外的所有基元类型均是值类型，当软件工作者创建一个值类型变量时，并未创建一个对象，AS3在内部把它们作为值来对待，这减少了创建对象的开销，这使基元类型的使用效率更高。</p>
<p>即使显式调用值基元类型的构造函数，如new String(&quot;liyi&quot;)、new Number(123)，也并未实际创建对象。</p>
<p>所有基元类型均是值类型。Object并不一定是引用类型，近一步判定取决于它的实际数据。Array，XML，XMLList，Function，Event，Error，Class，DisplayObject等均是引用对象。</p>
<p>在AS3中，明确哪些对象是引用类型，具有十分重要的意义，当你开发十万行代码以上的项目时，便会认同我的说法。</p>
<h2>五，变量的类型并不取决于变量类型注释</h2>
<p>在AS3中，变量类型注释是给编译器用的，它并不能决定变量的真实类型。在<a href="http://livedocs.adobe.com/flash/9.0/main/wwhelp/wwhimpl/common/html/wwhelp.htm?context=LiveDocs_Parts&amp;file=00000092.html">这里</a>有位英雄写了这样一则评论：</p>
<pre><code class="language-js">I've been trying to make an example that displays the difference between a shallow and deep copy. So far I haven't been able to find any difference between using the slice/concat methods and the clone function provided in this section. Can someone take a look at my code and tell me what I'm doing wrong?

//-- CLONING ARRAYS --\\ 
trace(&quot;**Cloning Arrays **&quot;);
var proto:Object = true;
var original:Array = new Array();

original = [proto];
var shallow:Array = original.slice();
var deep:Array = clone(original);
trace(&quot;\tDeep copy = &quot; + deep); // output: true 
trace(&quot;\tShallow copy = &quot; + shallow); // output: true 
trace(&quot;\n***VALUE CHANGED***&quot;);

proto = false; // object value is changed 
trace(&quot;\tDeep copy = &quot; + deep); // output: true 
trace(&quot;\tShallow copy = &quot; + shallow); // output: true &lt;-- should be false ?? 

// Clone function 
import flash.utils.ByteArray;
function clone(source:Object):* // function for deep copy {
  var myBA:ByteArray = new ByteArray();
  myBA.writeObject(source);
  myBA.position = 0;
  return(myBA.readObject());
}
maybe I'm just confused as to what deep and shallow copies are any explanations would be great thanks.
</code></pre>
<p>他使用Adobe提供的ByteArray clone方法对数组进行深拷贝，当他改变proto的值为false时，却发现shallow[0]并没有改变。在这里，proto的变量注释虽为Object，但它其实并不是Object，而是Boolean，proto的真实类型取决于它真实的值，由于他以布尔值true实例化proto，所以proto论为了Boolean类型。在AS3中，Boolean并非引用类型。</p>
<p>把这位英雄的代码稍作两处改动，如下：</p>
<pre><code class="language-js">//-- CLONING ARRAYS --\\
trace(&quot;**Cloning Arrays **&quot;);
var proto: Object = [true];
var original:Array = new Array();
original = [proto];
var shallow:Array = original.slice();
var deep:Array = clone(original);

trace(&quot;\tDeep copy = &quot; + deep); // output: true
trace(&quot;\tShallow copy = &quot; + shallow); // output: true

trace(&quot;\n***VALUE CHANGED***&quot;);
proto[0] = false; // object value is changed

trace(&quot;\tDeep copy = &quot; + deep); // output: true
trace(&quot;\tShallow copy = &quot; + shallow); // output: false
</code></pre>
<p>这样由于Array是引用类型，所以输出便如期许了。</p>
<h2>六，问题</h2>
<p>1）Number仅有52位有效数位，为什么可以表示最大为253的精度呢？</p>
<p>2）值基元类型如Number，String等，既然是值，为什么又有Object的方法呢？在AVM内部是如何实现的？</p>
<p>3）为什么定义颜色值使用uint，而不使用int或Number？</p>
<p>4）为什么不能使用Number动态改变显示对象的坐标？</p>
<p>2008年5月</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[AS3中的一些基本定义，Function与Method的区别]]></title>
            <link>https://yishulun.com/./src/posts/2008/04.html</link>
            <guid>https://yishulun.com/./src/posts/2008/04.html</guid>
            <pubDate>Thu, 01 May 2008 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>AS3中的一些基本定义，Function与Method的区别</h1>
<p>Adobe在官方英文文档中，并未专意对一些基本作区别说明；多数自动翻译或中文翻译，又存在翻译不当之处，古人有云，差之毫厘，缪以千里。且先试问一句，Function与Method有何区别？</p>
<p>Function与Method翻译成中文，不知如何翻译，使用英文更好。function在AS3中，是定义函数的关键字，但它定义的不一定是Function，也可能是Method。</p>
<h2>1，Method与Function的区别</h2>
<p>使用function关键字在Class内部显式定义的方法，称为Method，而除此之外使用function关键字定义的方法皆称为 Function。Function类似于js中的function方法。如此区分概念，有助于理解AS3的闭包（closure）概念。</p>
<h2>2，Property是什么</h2>
<p>在AS3中，Property不应该理解为类的属性，而应该理解为类的元素，包括变量，方法，setter/getter方法。从一个角度讲，在 AS3中，Class没有属性，平常所用的x,y,width,height等不应该称为&quot;属性&quot;，它们是setter/getter方法。这样理解，更 有助于理解trait对象。</p>
<h2>3，什么是类型注释(Type Annotation)？</h2>
<p>type annotation翻译为类型声明是不恰切的，type annotation仅是给编译器用的，代码量虽然增加了，换来的是性能的提升与代码的易读，这与注释的功能是类似的，翻译为类型注释更贴切。</p>
<pre><code>var s :String = &quot;sban&quot;;
</code></pre>
<p>在上例中，String即是类型注释，或变量类型注释。</p>
<pre><code>public function getWidth() : uint {
    //...
}
</code></pre>
<p>在上例中，uint即是类型注释，或返回类型注释。</p>
<p>2008年5月</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[E4X用法简要]]></title>
            <link>https://yishulun.com/./src/posts/2008/05.html</link>
            <guid>https://yishulun.com/./src/posts/2008/05.html</guid>
            <pubDate>Thu, 01 May 2008 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>E4X用法简要</h1>
<p>E4X语法是AS3对ECMAScript标准最前卫的实现，也是目前所有高级编程语言中操作XML最为方便的方式之一。仅仅因为AS3实现了E4X，作为程序员至少也应该了解它一下，因为它是那样的简洁、优雅。</p>
<p>因为AS3实现的是ECMAScript 357 for XML标准（ECMAScript对XML的扩展标准），简称为E4X。自有E4X以来，AS2程序员应该忘掉以前惯用的XMLDocument、 XMLNode、XMLParser 和 XMLTag。在AS3中，操作XML仅需要记住两个类：XML与XMLList。</p>
<p><strong>主要概念：</strong></p>
<ol>
<li>
<p>元素(Element，或称为节点Node)：XML 文档中的单个项目，它被标识为开始标签和结束标签之间包含的内容（包括标签）。XML 元素可以包含文本数据或其它元素，也可以为空。</p>
</li>
<li>
<p>属性 (Attribute)：与元素关联的命名值，它以 attributename=&quot;value&quot; 格式写入到元<br>
素的开始标签中，而不是编写为嵌套在元素内的单独子元素。</p>
</li>
</ol>
<p>设有如下XML：</p>
<pre><code class="language-xml">var myXML:XML =
    &lt;order&gt;
        &lt;item id='1' author='sban'&gt;
            &lt;menuName&gt;burger&lt;/menuName&gt;
            &lt;price&gt;3.95&lt;/price&gt;                            
            &lt;title&gt;as3 expert&lt;/title&gt;
        &lt;/item&gt;
        &lt;item id='2'&gt;
            &lt;menuName&gt;fries&lt;/menuName&gt;
            &lt;price&gt;1.45&lt;/price&gt;
        &lt;/item&gt;
    &lt;/order&gt;;
</code></pre>
<p>下面以实例讲解几个主要的E4X操作方法：</p>
<h2>1，查找包括指定属性的元素列表</h2>
<pre><code class="language-js">var items :XMLList = myXML.item.(hasOwnProperty('@author'));
</code></pre>
<p>上例代码仅返回第一个item节点。</p>
<h2>2，查找指定属性的值为X的元素列表</h2>
<pre><code class="language-js">var items :XMLList = myXML.item.(@id == 1);
</code></pre>
<p>上例代码仅返回第一个item节点。</p>
<h2>3，在查找条件中使用并、或、四则运算</h2>
<pre><code class="language-js">var items :XMLList = myXML.item.(@id == 1 || @id == 2);
var items :XMLList = myXML.item.(@id == 1 &amp;&amp; @id == 2);
var items :XMLList = myXML.item.(@id &gt;= 1);
</code></pre>
<h2>4，查找含有指定节点名称的元素列表</h2>
<pre><code class="language-js"> var items :XMLList = myXML.item.(hasOwnProperty('title'));
</code></pre>
<h2>5，如果有命名空间，在读取元素时必须加命名空间前缀</h2>
<p>把用例XML修改为如下：</p>
<pre><code class="language-xml">var myXML:XML =
    &lt;s:order xmlns:s=&quot;https://yishulun.com/as3expert&quot;&gt;
      &lt;s:item id=&quot;1&quot; author=&quot;sban&quot;&gt;
        &lt;s:menuName&gt;burger&lt;/menuName&gt;
        &lt;s:price&gt;3.95&lt;/price&gt;
        &lt;s:title&gt;as3 expert&lt;/title&gt;
      &lt;/s:item&gt;
      &lt;s:item id=&quot;2&quot;&gt;
        &lt;s:menuName&gt;fries&lt;/menuName&gt;
        &lt;s:price&gt;1.45&lt;/price&gt;
      &lt;/s:item&gt;
    &lt;/s:order&gt;;
</code></pre>
<p>此时，问题1的答案便为：</p>
<pre><code class="language-js">var ns :Namespace = new Namespace(&quot;s&quot;, &quot;https://yishulun.com/as3expert&quot;);
var items :XMLList = myXML.ns::item.(hasOwnProperty('@author'));
</code></pre>
<p>其它操作与之类似。</p>
<h2>6，如何向XMLList中推入一个元素</h2>
<p>简单，使用加号：</p>
<pre><code class="language-xml">items += &lt;s:item id=&quot;3&quot; xmlns:s=&quot;https://yishulun.com/as3expert&quot;&gt;
    &lt;s:menuName&gt;gumbo&lt;/menuName&gt;
    &lt;s:price&gt;2.45&lt;/price&gt;
  &lt;/s:item&gt;;
</code></pre>
<h2>7，如何从XMLList中删除一个元素</h2>
<p>删除不能使用减号(why?)，须使用delete关键字：</p>
<pre><code>delete items.(@id == 1)[0];
delete不能作用于XMLList对象，操作对象必须是XML。
</code></pre>
<h2>8，如何在XMLList中指定位置插入XML</h2>
<p>先把XMLList包装为XML，然后使用XML的appendChild，prependChild，insertChildAfter，insertChildBefore方法实现。</p>
<h2>9，如何获取子子节点列表或属性列表</h2>
<pre><code class="language-js">var items :XMLList = myXML..ns::menuName;
var ids :XMLList = myXML..@id;
</code></pre>
<p>2008年5月</p>
<blockquote>
<p>2021更新：AS3原生支持的E4X语法，操作XML太方便了。现在跨系统数据交换基本都是使用json格式了，e4x这么好用的原生语法也很少使用了。</p>
</blockquote>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[Flash Player的垃圾内存回收机制：能否强制回收？]]></title>
            <link>https://yishulun.com/./src/posts/2008/06.html</link>
            <guid>https://yishulun.com/./src/posts/2008/06.html</guid>
            <pubDate>Thu, 01 May 2008 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>Flash Player的垃圾内存回收机制：能否强制回收？</h1>
<p>在Adobe Flash Player 10中，AS3的内部垃圾回收机制是怎样的？程序员可以强制FP回收内存吗？答案是否定的，但有方法。</p>
<h3>1. 毛主席请猫吃辣椒的故事</h3>
<p>建国初期，国家正在对资本主义工商业进行社会主义改造，毛泽东问周恩来、刘少奇等，如何才能让猫吃辣椒？刘少奇说，把猫逮住，用筷子捅下去。周总理说，先把猫饿上三天，然后把辣椒裹在肉里给它吃。毛主席都不赞成这两种做法，毛主席说，把辣椒抹在猫屁股上，猫觉得辣自然就去会舔，而且还会因为这样做而兴奋不已。</p>
<h3>2. 强制垃圾内存回收的代码</h3>
<p>AS3程序员没有办法强制Flash Player进行垃圾回收，但有一种类似于毛主席请猫吃辣椒的方法可以使用。</p>
<p>MoonSpirit在天地会撰写过一篇关于强制垃圾回收的文章：[<a href="http://flash.9ria.com/viewthread.php?tid=234">as hack技术]垃圾回收机强制执行</a>。文中例证，使用LocalConnection连接非法地址，并捕获导常，可以强制进行垃圾回收。<a href="https://yishulun.com/">作者</a>在MoonSpirit的基础上，简单修改了一下代码，如下：</p>
<pre><code class="language-js">package {
	import flash.display.Bitmap;
	import flash.display.BitmapData;
	import flash.display.Sprite;
	import flash.net.LocalConnection;

	/**
	 * @author LIYI https://yishulun.com/
	 * 修改自MoonSpirit的强制垃圾回收测试代码
	 */
	public class GarbageCollectionTest extends Sprite {
		private const SQR_AMOUNT : int = 10000; // 方块数量        
		private var _container_sp : Sprite;// 容器sprite
		private var _sqrList: Array;// 所有方块的引用

		// 强制垃圾回收使用的对象
		private var conn1 :LocalConnection;
		private var conn2 :LocalConnection;

		public function GarbageCollectionTest() {
			init( );
		}

		private function init( ) : void{
			_container_sp = new Sprite( );
			addChild(_container_sp);
			//initNoBitmapDataView( );// 峰值4111K，手动回收两次变为9K
			initBitmapDataView( );// 峰值14K，最小为14K，手动回收基本无变化
		}

		// 初始化 通过通常手段 显示
		private function initNoBitmapDataView( ) : void {
			layoutTenThousandSqr( );

			unLayoutTenThousandSqr( );
			_sqrList = null;
			removeChild(_container_sp);
			_container_sp = null;
		}

		// 初始化 通过BitmapData快照 显示
		private function initBitmapDataView( ) : void {
			layoutTenThousandSqr( );

			unLayoutTenThousandSqr( );
			_sqrList = null;
			removeChild(_container_sp);
			_container_sp = null;

			doClearance( );
		}

		private function layoutTenThousandSqr( ) : void {
			_sqrList = new Array( );
			for(var i : int = 0; i &lt; SQR_AMOUNT; i++){
				_sqrList.push(new Sprite());
				_sqrList[i].graphics.beginFill(0xff0000);
				_sqrList[i].graphics.drawRect(0,0,100,100);
				_sqrList[i].graphics.endFill();
				_container_sp.addChild(_sqrList[i]);
			}
		}

		// 不显示
		private function unLayoutTenThousandSqr( ) : void {
			for(var i : int = 0; i &lt; SQR_AMOUNT; i++){
				_container_sp.removeChild(_sqrList[i]);
				delete _sqrList[i];
			}
		}

		// 精髓，垃圾回收机强制调用
		private function doClearance( ) : void {
			trace(&quot;clear&quot;);
			try{
				conn1 = new LocalConnection();
				conn1.connect(&quot;liyi garbage collection 1&quot;);
				conn2 = new LocalConnection();
				conn2.connect(&quot;liyi garbage collection 1&quot;);
			}catch(e :*){}
			finally{
				conn1 = null;
				conn2 = null;
			}
		}
	}
}
</code></pre>
<p>然后呢，作者调用doClearance方法，这次无论是否手动回收，内存占用无变化，如下图所示，这说明doClearance方法已经强制了垃圾内存回收，它作用了！</p>
<p>[此处有图，但被岁月冲走了]</p>
<p>那么，为什么创建两次没用的LocalConnection可以强制回收内存呢？</p>
<h3>3. AS3垃圾内存回收机制</h3>
<p>在Flash Player初始化运行时，会向操作系统申请一大块内存，如果程序很小，有可能根本用不了这么多内存，但FP在开始时不考虑这些，大多数情况下，第一次申请的内存总是不够用的。第一次申请的内存大小，与操作系统、浏览器环境有关。</p>
<p>当Flash Player发现已经申请的内存不够用时，它会再向操作系统申请一大块内存。但在申请之前，请注意，FP会尝试进行垃圾内存回收。那么它是如何回收的呢？</p>
<p>Flash Player在内部使用<strong>懒惰式引用计数回收方案</strong>进行垃圾内存回收，<strong>懒惰式</strong>指：FP并不会一次把所有可以回收的对象全部回收，它一次仅会回收一部分，如果内存不够用，它会向操作系统申请，如果系统无内存了，它会再次回收，如果全部回收了仍不够用，Game Over!<strong>引用计数</strong>指：FP在内部给每个对象标记一个记号，当没有任何对象引用此对象时，它即是可以被回收的；如果一个容器内有许多相互关联的对象，当把这个容器从显示列表中移除，并且置为null后，它也是可以被回收的。</p>
<p>在小节2中，<a href="https://yishulun.com/">作者</a>问到为什么要手动单击两次“运行垃圾回收器”按钮，这是由于FP垃圾回收机制的<strong>懒惰</strong>性造成的。</p>
<p>在清楚了FP的内部垃圾回收机制之后，我们便可以回答，为什么创建两次没用的LocalConnection，并且连接并不存在的地址，故意抛出异常然后捕获，可以强制垃圾回收呢？因为，在AS3中LocalConnection是比较占用内存的对象，两次创建该类对象并尝试进行连接的内存开销大小足以请Flash Player重新向操作系统申请内存，而在申请之前，FP会尝试回收。原理即是这么简单，非独使用LocalConnection可以，其它较耗内存的对象也可以。</p>
<p>2008年5月</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
        <item>
            <title><![CDATA[AS3事件机制概述]]></title>
            <link>https://yishulun.com/./src/posts/2009/01.html</link>
            <guid>https://yishulun.com/./src/posts/2009/01.html</guid>
            <pubDate>Thu, 01 May 2008 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>AS3事件机制概述</h1>
<p>目录<br>
[TOC]</p>
<p>事件机制是AS3的核心功能之一，没有充分掌握事件机制的方方面面，就不能算是精通AS3语言。</p>
<h2>1，AS3事件机制的主要成员</h2>
<ul>
<li>IEventDispatcher：事件派发对象接口，定义了添加、派发、移除、是否监听指定事件、是否触发指定事件接口</li>
<li>EventDispatcher：事件派发对象接口的实现者，用户无法撇开EventDispatcher而自行实现IEventDispatcher接口，无法直接继承</li>
<li>EventDispatcher时，必须把EventDispatcher作为实例变量。</li>
<li>Event：事件基类，所有事件类均基于此类实现</li>
</ul>
<h2>2，观察者模式</h2>
<p>AS3事件机制实现的是观察者模式。</p>
<p>IEventDispatcher充当了Subject角色，EventDispatcher相当于ConcreteSubject对象，Event相当于Observer，ConcreteSbserver相当于Event的子类。Attach相当于addEventListener，Detach相当于removeEventListener，Notify相当于dispatchEvent。Event没有Update。</p>
<h2>3，显示列表中事件流的三个阶段</h2>
<p>在一个事件的整个生命周期内，共分为三个阶段：</p>
<p>在捕获阶段与冒泡阶段均可能经过N个节点，在目标阶段仅可能有一个节点。</p>
<p>使用stopPropagation可阻止对事件流中当前节点的后续节点中的所有事件侦听器进行处理。使用stopImmediatePropagation可阻止对事件流中当前节点中和所有后续节点中的事件侦听器进行处理。</p>
<p>显示列表中事件流三阶段与事件机制本身没有直接关系。在AS3显示列表中，为什么要有事件流，为什么不是直接到达目标对象？</p>
<h2>4，IEventDispatcher接口讲解</h2>
<p>AS3事件机制的精髓基本全在这个接口中。</p>
<pre><code class="language-js">addEventListener(type:String, listener:Function, useCapture:Boolean = false, priority:int = 0, useWeakReference:Boolean = false):void
</code></pre>
<p>使用 EventDispatcher 对象注册事件侦听器对象，以使侦听器能够接收事件通知。</p>
<p>最常用的是前面二个参数。第三个参数标识该监听器是否会在捕获阶段被触发。第四个参数priority标识该同类事情监听器被调用的优化级。第五个参数标识该监听器是否易于被回收，默认为false，并且永远应该默认为false，如果监听器可以被回收，应该手动处理，而不是交给Flash Player。</p>
<p>对于监听同一类事件的监听器，priority高者优化被调用。在FP及Flex SDK中，priority最大不会超过200，因此，如果要设置top level的事件监听，此值应该设置在200以上。</p>
<p>在大型应用中，最好把各个层所要用到的priority分一下组，例如200-220分派给Core Level。</p>
<pre><code>removeEventListener(type:String, listener:Function, useCapture:Boolean = false):void
// 从 EventDispatcher 对象中删除侦听器
</code></pre>
<p>如果在addEventListener时，useCapture为true，此时在removeEventListener时，useCapture参数应与之相同。EventDispatcher内部维护了两个listener集合，一个盛装useCapture为false的listener，另一个盛装为true的。</p>
<h2>5，Event类实例化讲解</h2>
<pre><code class="language-js">Event(type:String, bubbles:Boolean = false, cancelable:Boolean = false)
</code></pre>
<p>创建一个作为参数传递给事件侦听器的 Event 对象。</p>
<p>Event 类的方法可以在事件侦听器函数中使用以影响事件对象的行为。某些事件有关联的默认行为。例如，doubleClick 事件有关联的默认行为，此行为突出显示事件发生时鼠标指针下的词。通过调用 preventDefault() 方法，您的事件侦听器可以取消此行为。通过调用 stopPropogation() 或 stopImmediatePropogation() 方法，还可以使当前事件侦听器成为要处理事件的最后一个事件侦听器。</p>
<p>cancelable标识该事件是否可阻止与取消。一般FP定义的内部事件类型均不可以取消，如CANCEL，CLOSE，OPEN，ADDED等，一般IMG事件均可以取消，如CLOSING，EXITING等，凡是可以取消的事件，均有一个关联的可以取消的行为。开发者在自定义事件也应遵守这一规则。</p>
<p>开发者应当保证type在应用程序中是唯一的，bubbles用于标识事件在到达目标对象后是否仍向下传递。</p>
<p>Event对象在事情流结束之后，如果没有其它引用，即可被GC回收。当前Event需要二次派发时，使用clone方法复制事件。</p>
<h2>6，MouseEvent事件</h2>
<p>鼠标事件是FP内InactiveObject对象内在支持的事件，这个事情由InactiveObject实例化、派发，并且总是bubble等于true的。对于不需要鼠标事件的对象，应当把mouseChildren与mouseEnabled设为flase，以优化程序性能。</p>
<h2>7，Flash Player内部对事件的强力支持</h2>
<p>FP本身是多线程的，只不过目前未对开发者开放API。在FP内部，有一个线程专门用于处理事件，事件的处理总是在桢周期的前期进行，并且不会受到其它线程的影响。</p>
<p>FP是异步的，Event的派发与listener的执行并不是紧密衔接的，当你派发一个事件之后，不能指望监听这个Event的Listener马上执行。<br>
PureMVC放弃AS3内部支持的事情机制不用，自己用观察者模式实现了一套Command体系，是对FP中独立事件线程的非合理浪费。</p>
<h2>8，事件与代的概念</h2>
<p>在FP内部，从宏观上讲，总是派发一拔事件，处理一拔代码，然后再派发一拔事件，再处理一拔代码，如此反复，看起来事件具有代(generation)的概念。代与事件流有关，也与桢周期内的执行模式有关。</p>
<h2>9，为什么要有事件流三阶段？</h2>
<p>当用户在FP中单击时，宿主环境仅能告诉FP用户进行了单击行为以及单击的坐标，却并不能告诉FP到底单击了哪一个对象，哪一个MC，这是不可能的，因为是什么对象、有什么对象，只有FP自已知道。</p>
<p>在FP中，共有两种渲染模式，一种为保留模式，另一种为立即模式，无论是哪一种渲染模式，FP交给浏览器或操作系统的最终渲染内容总是一张张图片，FP像幻灯片放映一样向用户展示互动与动画。所以，当用户单击时，永远只是单击点，看得见的点，FP拿到这些点之后，在内部的显示列表结构上遍历，首先从上向下走，只要当前显示对象囊括了单击点，并且是透明的（下面还有显示对象），便一直往下走，直到目标对象，然后再原路一路向上走，这便是事件机制的三阶段。</p>
<p>由于显示对象可以是透明的，FP并不知道开发者设想的用户真正想单击的是不是目标对象，有可能是捕获阶段的对象，同样的对象也有可能想在冒泡阶段处理，为了提供更大的灵活性，FP在显示列表中实现了事件流的三步机制，数以千万开发者的实践证明它是非常有阶值的。</p>
<p>单击之外的其它鼠标事情与之类似。</p>
<h2>10，优化程序性能的第一准则</h2>
<p>及时移除不再需要的事情监听，是保证垃圾回收、优化程序性能的最浅显、最容易、最为开发者所忽视的行码准则之一。以下代码是通用的，在函数内部移除事件监听的方法：</p>
<p>e.currentTarget.removeEventListener(e.type, arguments.callee);</p>
<h2>11，停止冒泡事情的派发</h2>
<p>除了移除不必要的事情监听，停止冒泡事情的继续派发也是提高程序运行效率的常用方法之一。该方法多用于MouseEvent事情，代码为：</p>
<pre><code class="language-js">e.stopPropagation();
or
e.stopImmediatePropagation();
</code></pre>
<p>但是事情冒泡有时却是十分有用的，在某处阻止了事件冒泡，有可能因此另一处的监听无法触发，这种bug十分隐蔽。</p>
<p>2009年5月27日</p>
]]></content:encoded>
            <author>coderliyi@gmail.com (LIYI)</author>
        </item>
    </channel>
</rss>