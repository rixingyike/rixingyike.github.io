import{_ as s,o as a,c as p,Q as n}from"./chunks/framework.25d5caa7.js";const o="/assets/image-20230923192404581.014a15d3.png",l="/assets/image-20230923193325205.de12a8f1.png",e="/assets/image-20230923193548972.abb3faa5.png",t="/assets/image-20230923194108099.2df5456d.png",v=JSON.parse('{"title":"Bun 1.0使用介绍（二）","description":"","frontmatter":{"date":"2023-09-23T16:27:50.000Z","tags":["技术栈"]},"headers":[],"relativePath":"posts/2023/06.md","filePath":"posts/2023/06.md"}'),c={name:"posts/2023/06.md"},r=n(`<h1 id="bun-1-0使用介绍-二" tabindex="-1">Bun 1.0使用介绍（二） <a class="header-anchor" href="#bun-1-0使用介绍-二" aria-label="Permalink to &quot;Bun 1.0使用介绍（二）&quot;">​</a></h1><p>继续<a href="https://yishulun.com/posts/2023/05.html" target="_blank" rel="noreferrer">上一篇</a>的内容，下面介绍Bun相比于传统技术栈框架及工具，具体有哪些优势。</p><h2 id="初始化" tabindex="-1">初始化 <a class="header-anchor" href="#初始化" aria-label="Permalink to &quot;初始化&quot;">​</a></h2><p>bun的初始化简单直接，使用下列指令会直接将当前目录初始化一个bun项目工程：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">bun</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">init</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">-y</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">bun</span><span style="color:#24292E;"> </span><span style="color:#032F62;">init</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">-y</span></span></code></pre></div><p>参数-y代表静默，不需要提问，所有初始化产生的副任用产品都在当前目录下，所有配置在完成后都可以在文件中修改。init指令会产生lock文件、package.json文件、tsconfig.json配置文件等。bun默认使用TS作为开发语言。</p><h2 id="运行指令-空间换时间" tabindex="-1">运行指令：空间换时间 <a class="header-anchor" href="#运行指令-空间换时间" aria-label="Permalink to &quot;运行指令：空间换时间&quot;">​</a></h2><p>目录初始化以后会有一个index.ts文件：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">console.log(&quot;Hello via Bun!&quot;);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">console.log(&quot;Hello via Bun!&quot;);</span></span></code></pre></div><p>以监听方式运行它：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">bun</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">--watch</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">run</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">index.ts</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">bun</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">--watch</span><span style="color:#24292E;"> </span><span style="color:#032F62;">run</span><span style="color:#24292E;"> </span><span style="color:#032F62;">index.ts</span></span></code></pre></div><p>监听方式大家都懂，当我们修改源码后，bun会监测到改动并自动运行代码。这是运行单个文件，也可以在package.json中添加小脚本：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">&quot;scripts&quot;</span><span style="color:#79B8FF;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">{</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#B392F0;">&quot;dev&quot;</span><span style="color:#79B8FF;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;bun --watch run index.ts&quot;</span></span>
<span class="line"><span style="color:#E1E4E8;"> },</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">&quot;scripts&quot;</span><span style="color:#005CC5;">:</span><span style="color:#24292E;"> </span><span style="color:#032F62;">{</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#6F42C1;">&quot;dev&quot;</span><span style="color:#005CC5;">:</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;bun --watch run index.ts&quot;</span></span>
<span class="line"><span style="color:#24292E;"> },</span></span></code></pre></div><p>此时通过bun dev运行，与前一个运行指令效果是等同的。</p><p>bun有一个参数--smol，文档说加上这个参数，可以少占用内存。这让我怀疑bun在各方面之所以速度表现优秀，在于它大量采用了“空间换时间”的优化方案，它在运行之后，内存占用必定有很多。</p><p>于是，我通过活动监测器查看bun的内存占用：</p><p><img src="`+o+'" alt="image-20230923192404581"></p><p>注意，这里有两个bun，这是使用watch启动的特征，一个是守护进程，一个是真正的应用进程。上面那个PID为98344的应该是守护进程，而下面那个PID为98345的是应用程序的进程。</p><p>我分别添加--smol参数与不添加参数，做两次测试，发现内存变化寥寥。使用smol参数与否，貌似并没有明显影响内存占用。</p><p>也可能是当前这个只打印一行“hello world”的程序太简单了，下面我换一个稍微复杂的博客程序进行测试，首次是一般模式：</p><p><img src="'+l+'" alt="image-20230923193325205"></p><p>占用了约730MB内存了，好家伙，快到一个G的内存了。</p><p>然后看启用了smol模式的内存占用：</p><p><img src="'+e+`" alt="image-20230923193548972"></p><p>占用了约722MB内存！我不能说smol这个参数没有作用，毕竟同样的项目是少了几MB的。</p><p>注意，在测试的时候，前后两次使用的指令是这样的：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">bun</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">run</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">--watch</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">--bun</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">vitepress</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">dev</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">src</span></span>
<span class="line"><span style="color:#B392F0;">bun</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">run</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">--smol</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">--watch</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">--bun</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">vitepress</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">dev</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">src</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">bun</span><span style="color:#24292E;"> </span><span style="color:#032F62;">run</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">--watch</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">--bun</span><span style="color:#24292E;"> </span><span style="color:#032F62;">vitepress</span><span style="color:#24292E;"> </span><span style="color:#032F62;">dev</span><span style="color:#24292E;"> </span><span style="color:#032F62;">src</span></span>
<span class="line"><span style="color:#6F42C1;">bun</span><span style="color:#24292E;"> </span><span style="color:#032F62;">run</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">--smol</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">--watch</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">--bun</span><span style="color:#24292E;"> </span><span style="color:#032F62;">vitepress</span><span style="color:#24292E;"> </span><span style="color:#032F62;">dev</span><span style="color:#24292E;"> </span><span style="color:#032F62;">src</span></span></code></pre></div><p>两次的指令都加上了--bun参数，这个参数代表使用bun作为JS语言的运行时，而非默认的Node.js。</p><p>下面，我们回到vitepress的普通运行模式，不再使用bun这个运行时了，使用Node.js，指令是这样的：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">bun</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">run</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">--watch</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">vitepress</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">dev</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">src</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">bun</span><span style="color:#24292E;"> </span><span style="color:#032F62;">run</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">--watch</span><span style="color:#24292E;"> </span><span style="color:#032F62;">vitepress</span><span style="color:#24292E;"> </span><span style="color:#032F62;">dev</span><span style="color:#24292E;"> </span><span style="color:#032F62;">src</span></span></code></pre></div><p>或者直接使用旧脚本：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">vitepress</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">dev</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">src</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">vitepress</span><span style="color:#24292E;"> </span><span style="color:#032F62;">dev</span><span style="color:#24292E;"> </span><span style="color:#032F62;">src</span></span></code></pre></div><p>这是在使用Node.js作为JS的运行时，它的内存占用一下就降下来了：</p><p><img src="`+t+'" alt="image-20230923194108099"></p><p>只有182MB！</p><p>从730MB降到了182MB，<strong>说明bun为了提高运行效率，很有可能狠狠地采用了“空间换时间”的策略</strong>。这个世界能量是守恒的，在一个地方占优了，必然在另一个地方会有所损耗，这是肯定的。为什么别的运行时都没有smol参数，bun为什么专门搞一个smol参数？</p>',36),i=[r];function y(E,d,u,h,F,b){return a(),p("div",null,i)}const C=s(c,[["render",y]]);export{v as __pageData,C as default};
